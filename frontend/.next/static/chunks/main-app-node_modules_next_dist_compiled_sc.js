"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["main-app-node_modules_next_dist_compiled_sc"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/scheduler/cjs/scheduler.development.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/scheduler/cjs/scheduler.development.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var enableSchedulerDebugging = false;\n        var enableProfiling = false;\n        var frameYieldMs = 5;\n        var userBlockingPriorityTimeout = 250;\n        var normalPriorityTimeout = 5000;\n        var lowPriorityTimeout = 10000;\n        function push(heap, node) {\n            var index = heap.length;\n            heap.push(node);\n            siftUp(heap, node, index);\n        }\n        function peek(heap) {\n            return heap.length === 0 ? null : heap[0];\n        }\n        function pop(heap) {\n            if (heap.length === 0) {\n                return null;\n            }\n            var first = heap[0];\n            var last = heap.pop();\n            if (last !== first) {\n                heap[0] = last;\n                siftDown(heap, last, 0);\n            }\n            return first;\n        }\n        function siftUp(heap, node, i) {\n            var index = i;\n            while(index > 0){\n                var parentIndex = index - 1 >>> 1;\n                var parent = heap[parentIndex];\n                if (compare(parent, node) > 0) {\n                    // The parent is larger. Swap positions.\n                    heap[parentIndex] = node;\n                    heap[index] = parent;\n                    index = parentIndex;\n                } else {\n                    // The parent is smaller. Exit.\n                    return;\n                }\n            }\n        }\n        function siftDown(heap, node, i) {\n            var index = i;\n            var length = heap.length;\n            var halfLength = length >>> 1;\n            while(index < halfLength){\n                var leftIndex = (index + 1) * 2 - 1;\n                var left = heap[leftIndex];\n                var rightIndex = leftIndex + 1;\n                var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n                if (compare(left, node) < 0) {\n                    if (rightIndex < length && compare(right, left) < 0) {\n                        heap[index] = right;\n                        heap[rightIndex] = node;\n                        index = rightIndex;\n                    } else {\n                        heap[index] = left;\n                        heap[leftIndex] = node;\n                        index = leftIndex;\n                    }\n                } else if (rightIndex < length && compare(right, node) < 0) {\n                    heap[index] = right;\n                    heap[rightIndex] = node;\n                    index = rightIndex;\n                } else {\n                    // Neither child is smaller. Exit.\n                    return;\n                }\n            }\n        }\n        function compare(a, b) {\n            // Compare sort index first, then task id.\n            var diff = a.sortIndex - b.sortIndex;\n            return diff !== 0 ? diff : a.id - b.id;\n        }\n        // TODO: Use symbols?\n        var ImmediatePriority = 1;\n        var UserBlockingPriority = 2;\n        var NormalPriority = 3;\n        var LowPriority = 4;\n        var IdlePriority = 5;\n        function markTaskErrored(task, ms) {}\n        /* eslint-disable no-var */ exports.unstable_now = void 0;\n        var hasPerformanceNow = typeof performance === \"object\" && typeof performance.now === \"function\";\n        if (hasPerformanceNow) {\n            var localPerformance = performance;\n            exports.unstable_now = function() {\n                return localPerformance.now();\n            };\n        } else {\n            var localDate = Date;\n            var initialTime = localDate.now();\n            exports.unstable_now = function() {\n                return localDate.now() - initialTime;\n            };\n        } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n        // Math.pow(2, 30) - 1\n        // 0b111111111111111111111111111111\n        var maxSigned31BitInt = 1073741823; // Tasks are stored on a min heap\n        var taskQueue = [];\n        var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n        var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\n        var currentTask = null;\n        var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n        var isPerformingWork = false;\n        var isHostCallbackScheduled = false;\n        var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n        var localSetTimeout = typeof setTimeout === \"function\" ? setTimeout : null;\n        var localClearTimeout = typeof clearTimeout === \"function\" ? clearTimeout : null;\n        var localSetImmediate = typeof setImmediate !== \"undefined\" ? setImmediate : null; // IE and Node.js + jsdom\n        typeof navigator !== \"undefined\" && // $FlowFixMe[prop-missing]\n        navigator.scheduling !== undefined && // $FlowFixMe[incompatible-type]\n        navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n        function advanceTimers(currentTime) {\n            // Check for tasks that are no longer delayed and add them to the queue.\n            var timer = peek(timerQueue);\n            while(timer !== null){\n                if (timer.callback === null) {\n                    // Timer was cancelled.\n                    pop(timerQueue);\n                } else if (timer.startTime <= currentTime) {\n                    // Timer fired. Transfer to the task queue.\n                    pop(timerQueue);\n                    timer.sortIndex = timer.expirationTime;\n                    push(taskQueue, timer);\n                } else {\n                    // Remaining timers are pending.\n                    return;\n                }\n                timer = peek(timerQueue);\n            }\n        }\n        function handleTimeout(currentTime) {\n            isHostTimeoutScheduled = false;\n            advanceTimers(currentTime);\n            if (!isHostCallbackScheduled) {\n                if (peek(taskQueue) !== null) {\n                    isHostCallbackScheduled = true;\n                    requestHostCallback();\n                } else {\n                    var firstTimer = peek(timerQueue);\n                    if (firstTimer !== null) {\n                        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n                    }\n                }\n            }\n        }\n        function flushWork(initialTime) {\n            isHostCallbackScheduled = false;\n            if (isHostTimeoutScheduled) {\n                // We scheduled a timeout but it's no longer needed. Cancel it.\n                isHostTimeoutScheduled = false;\n                cancelHostTimeout();\n            }\n            isPerformingWork = true;\n            var previousPriorityLevel = currentPriorityLevel;\n            try {\n                var currentTime;\n                if (enableProfiling) ;\n                else {\n                    // No catch in prod code path.\n                    return workLoop(initialTime);\n                }\n            } finally{\n                currentTask = null;\n                currentPriorityLevel = previousPriorityLevel;\n                isPerformingWork = false;\n            }\n        }\n        function workLoop(initialTime) {\n            var currentTime = initialTime;\n            advanceTimers(currentTime);\n            currentTask = peek(taskQueue);\n            while(currentTask !== null && !enableSchedulerDebugging){\n                if (currentTask.expirationTime > currentTime && shouldYieldToHost()) {\n                    break;\n                } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                var callback = currentTask.callback;\n                if (typeof callback === \"function\") {\n                    // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    currentTask.callback = null; // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    currentPriorityLevel = currentTask.priorityLevel; // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n                    var continuationCallback = callback(didUserCallbackTimeout);\n                    currentTime = exports.unstable_now();\n                    if (typeof continuationCallback === \"function\") {\n                        // If a continuation is returned, immediately yield to the main thread\n                        // regardless of how much time is left in the current time slice.\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        currentTask.callback = continuationCallback;\n                        advanceTimers(currentTime);\n                        return true;\n                    } else {\n                        if (currentTask === peek(taskQueue)) {\n                            pop(taskQueue);\n                        }\n                        advanceTimers(currentTime);\n                    }\n                } else {\n                    pop(taskQueue);\n                }\n                currentTask = peek(taskQueue);\n            } // Return whether there's additional work\n            if (currentTask !== null) {\n                return true;\n            } else {\n                var firstTimer = peek(timerQueue);\n                if (firstTimer !== null) {\n                    requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n                }\n                return false;\n            }\n        }\n        function unstable_runWithPriority(priorityLevel, eventHandler) {\n            switch(priorityLevel){\n                case ImmediatePriority:\n                case UserBlockingPriority:\n                case NormalPriority:\n                case LowPriority:\n                case IdlePriority:\n                    break;\n                default:\n                    priorityLevel = NormalPriority;\n            }\n            var previousPriorityLevel = currentPriorityLevel;\n            currentPriorityLevel = priorityLevel;\n            try {\n                return eventHandler();\n            } finally{\n                currentPriorityLevel = previousPriorityLevel;\n            }\n        }\n        function unstable_next(eventHandler) {\n            var priorityLevel;\n            switch(currentPriorityLevel){\n                case ImmediatePriority:\n                case UserBlockingPriority:\n                case NormalPriority:\n                    // Shift down to normal priority\n                    priorityLevel = NormalPriority;\n                    break;\n                default:\n                    // Anything lower than normal priority should remain at the current level.\n                    priorityLevel = currentPriorityLevel;\n                    break;\n            }\n            var previousPriorityLevel = currentPriorityLevel;\n            currentPriorityLevel = priorityLevel;\n            try {\n                return eventHandler();\n            } finally{\n                currentPriorityLevel = previousPriorityLevel;\n            }\n        }\n        function unstable_wrapCallback(callback) {\n            var parentPriorityLevel = currentPriorityLevel; // $FlowFixMe[incompatible-return]\n            // $FlowFixMe[missing-this-annot]\n            return function() {\n                // This is a fork of runWithPriority, inlined for performance.\n                var previousPriorityLevel = currentPriorityLevel;\n                currentPriorityLevel = parentPriorityLevel;\n                try {\n                    return callback.apply(this, arguments);\n                } finally{\n                    currentPriorityLevel = previousPriorityLevel;\n                }\n            };\n        }\n        function unstable_scheduleCallback(priorityLevel, callback, options) {\n            var currentTime = exports.unstable_now();\n            var startTime;\n            if (typeof options === \"object\" && options !== null) {\n                var delay = options.delay;\n                if (typeof delay === \"number\" && delay > 0) {\n                    startTime = currentTime + delay;\n                } else {\n                    startTime = currentTime;\n                }\n            } else {\n                startTime = currentTime;\n            }\n            var timeout;\n            switch(priorityLevel){\n                case ImmediatePriority:\n                    // Times out immediately\n                    timeout = -1;\n                    break;\n                case UserBlockingPriority:\n                    // Eventually times out\n                    timeout = userBlockingPriorityTimeout;\n                    break;\n                case IdlePriority:\n                    // Never times out\n                    timeout = maxSigned31BitInt;\n                    break;\n                case LowPriority:\n                    // Eventually times out\n                    timeout = lowPriorityTimeout;\n                    break;\n                case NormalPriority:\n                default:\n                    // Eventually times out\n                    timeout = normalPriorityTimeout;\n                    break;\n            }\n            var expirationTime = startTime + timeout;\n            var newTask = {\n                id: taskIdCounter++,\n                callback: callback,\n                priorityLevel: priorityLevel,\n                startTime: startTime,\n                expirationTime: expirationTime,\n                sortIndex: -1\n            };\n            if (startTime > currentTime) {\n                // This is a delayed task.\n                newTask.sortIndex = startTime;\n                push(timerQueue, newTask);\n                if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n                    // All tasks are delayed, and this is the task with the earliest delay.\n                    if (isHostTimeoutScheduled) {\n                        // Cancel an existing timeout.\n                        cancelHostTimeout();\n                    } else {\n                        isHostTimeoutScheduled = true;\n                    } // Schedule a timeout.\n                    requestHostTimeout(handleTimeout, startTime - currentTime);\n                }\n            } else {\n                newTask.sortIndex = expirationTime;\n                push(taskQueue, newTask);\n                // wait until the next time we yield.\n                if (!isHostCallbackScheduled && !isPerformingWork) {\n                    isHostCallbackScheduled = true;\n                    requestHostCallback();\n                }\n            }\n            return newTask;\n        }\n        function unstable_pauseExecution() {}\n        function unstable_continueExecution() {\n            if (!isHostCallbackScheduled && !isPerformingWork) {\n                isHostCallbackScheduled = true;\n                requestHostCallback();\n            }\n        }\n        function unstable_getFirstCallbackNode() {\n            return peek(taskQueue);\n        }\n        function unstable_cancelCallback(task) {\n            // remove from the queue because you can't remove arbitrary nodes from an\n            // array based heap, only the first one.)\n            task.callback = null;\n        }\n        function unstable_getCurrentPriorityLevel() {\n            return currentPriorityLevel;\n        }\n        var isMessageLoopRunning = false;\n        var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n        // thread, like user events. By default, it yields multiple times per frame.\n        // It does not attempt to align with frame boundaries, since most tasks don't\n        // need to be frame aligned; for those that do, use requestAnimationFrame.\n        var frameInterval = frameYieldMs;\n        var startTime = -1;\n        function shouldYieldToHost() {\n            var timeElapsed = exports.unstable_now() - startTime;\n            if (timeElapsed < frameInterval) {\n                // The main thread has only been blocked for a really short amount of time;\n                // smaller than a single frame. Don't yield yet.\n                return false;\n            } // The main thread has been blocked for a non-negligible amount of time. We\n            return true;\n        }\n        function requestPaint() {}\n        function forceFrameRate(fps) {\n            if (fps < 0 || fps > 125) {\n                // Using console['error'] to evade Babel and ESLint\n                console[\"error\"](\"forceFrameRate takes a positive int between 0 and 125, \" + \"forcing frame rates higher than 125 fps is not supported\");\n                return;\n            }\n            if (fps > 0) {\n                frameInterval = Math.floor(1000 / fps);\n            } else {\n                // reset the framerate\n                frameInterval = frameYieldMs;\n            }\n        }\n        var performWorkUntilDeadline = function() {\n            if (isMessageLoopRunning) {\n                var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n                // has been blocked.\n                startTime = currentTime; // If a scheduler task throws, exit the current browser task so the\n                // error can be observed.\n                //\n                // Intentionally not using a try-catch, since that makes some debugging\n                // techniques harder. Instead, if `flushWork` errors, then `hasMoreWork` will\n                // remain true, and we'll continue the work loop.\n                var hasMoreWork = true;\n                try {\n                    hasMoreWork = flushWork(currentTime);\n                } finally{\n                    if (hasMoreWork) {\n                        // If there's more work, schedule the next message event at the end\n                        // of the preceding one.\n                        schedulePerformWorkUntilDeadline();\n                    } else {\n                        isMessageLoopRunning = false;\n                    }\n                }\n            } // Yielding to the browser will give it a chance to paint, so we can\n        };\n        var schedulePerformWorkUntilDeadline;\n        if (typeof localSetImmediate === \"function\") {\n            // Node.js and old IE.\n            // There's a few reasons for why we prefer setImmediate.\n            //\n            // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n            // (Even though this is a DOM fork of the Scheduler, you could get here\n            // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n            // https://github.com/facebook/react/issues/20756\n            //\n            // But also, it runs earlier which is the semantic we want.\n            // If other browsers ever implement it, it's better to use it.\n            // Although both of these would be inferior to native scheduling.\n            schedulePerformWorkUntilDeadline = function() {\n                localSetImmediate(performWorkUntilDeadline);\n            };\n        } else if (typeof MessageChannel !== \"undefined\") {\n            // DOM and Worker environments.\n            // We prefer MessageChannel because of the 4ms setTimeout clamping.\n            var channel = new MessageChannel();\n            var port = channel.port2;\n            channel.port1.onmessage = performWorkUntilDeadline;\n            schedulePerformWorkUntilDeadline = function() {\n                port.postMessage(null);\n            };\n        } else {\n            // We should only fallback here in non-browser environments.\n            schedulePerformWorkUntilDeadline = function() {\n                // $FlowFixMe[not-a-function] nullable value\n                localSetTimeout(performWorkUntilDeadline, 0);\n            };\n        }\n        function requestHostCallback() {\n            if (!isMessageLoopRunning) {\n                isMessageLoopRunning = true;\n                schedulePerformWorkUntilDeadline();\n            }\n        }\n        function requestHostTimeout(callback, ms) {\n            // $FlowFixMe[not-a-function] nullable value\n            taskTimeoutID = localSetTimeout(function() {\n                callback(exports.unstable_now());\n            }, ms);\n        }\n        function cancelHostTimeout() {\n            // $FlowFixMe[not-a-function] nullable value\n            localClearTimeout(taskTimeoutID);\n            taskTimeoutID = -1;\n        }\n        var unstable_Profiling = null;\n        exports.unstable_IdlePriority = IdlePriority;\n        exports.unstable_ImmediatePriority = ImmediatePriority;\n        exports.unstable_LowPriority = LowPriority;\n        exports.unstable_NormalPriority = NormalPriority;\n        exports.unstable_Profiling = unstable_Profiling;\n        exports.unstable_UserBlockingPriority = UserBlockingPriority;\n        exports.unstable_cancelCallback = unstable_cancelCallback;\n        exports.unstable_continueExecution = unstable_continueExecution;\n        exports.unstable_forceFrameRate = forceFrameRate;\n        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n        exports.unstable_next = unstable_next;\n        exports.unstable_pauseExecution = unstable_pauseExecution;\n        exports.unstable_requestPaint = requestPaint;\n        exports.unstable_runWithPriority = unstable_runWithPriority;\n        exports.unstable_scheduleCallback = unstable_scheduleCallback;\n        exports.unstable_shouldYield = shouldYieldToHost;\n        exports.unstable_wrapCallback = unstable_wrapCallback;\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUMsR0FFRDtBQUVBLElBQUlBLElBQXFDLEVBQUU7SUFDeEM7UUFFTztRQUVWLHlDQUF5QyxHQUN6QyxJQUNFLE9BQU9DLG1DQUFtQyxlQUMxQyxPQUFPQSwrQkFBK0JDLDJCQUEyQixLQUMvRCxZQUNGO1lBQ0FELCtCQUErQkMsMkJBQTJCLENBQUMsSUFBSUM7UUFDakU7UUFDVSxJQUFJQywyQkFBMkI7UUFDekMsSUFBSUMsa0JBQWtCO1FBQ3RCLElBQUlDLGVBQWU7UUFDbkIsSUFBSUMsOEJBQThCO1FBQ2xDLElBQUlDLHdCQUF3QjtRQUM1QixJQUFJQyxxQkFBcUI7UUFFekIsU0FBU0MsS0FBS0MsSUFBSSxFQUFFQyxJQUFJO1lBQ3RCLElBQUlDLFFBQVFGLEtBQUtHLE1BQU07WUFDdkJILEtBQUtELElBQUksQ0FBQ0U7WUFDVkcsT0FBT0osTUFBTUMsTUFBTUM7UUFDckI7UUFDQSxTQUFTRyxLQUFLTCxJQUFJO1lBQ2hCLE9BQU9BLEtBQUtHLE1BQU0sS0FBSyxJQUFJLE9BQU9ILElBQUksQ0FBQyxFQUFFO1FBQzNDO1FBQ0EsU0FBU00sSUFBSU4sSUFBSTtZQUNmLElBQUlBLEtBQUtHLE1BQU0sS0FBSyxHQUFHO2dCQUNyQixPQUFPO1lBQ1Q7WUFFQSxJQUFJSSxRQUFRUCxJQUFJLENBQUMsRUFBRTtZQUNuQixJQUFJUSxPQUFPUixLQUFLTSxHQUFHO1lBRW5CLElBQUlFLFNBQVNELE9BQU87Z0JBQ2xCUCxJQUFJLENBQUMsRUFBRSxHQUFHUTtnQkFDVkMsU0FBU1QsTUFBTVEsTUFBTTtZQUN2QjtZQUVBLE9BQU9EO1FBQ1Q7UUFFQSxTQUFTSCxPQUFPSixJQUFJLEVBQUVDLElBQUksRUFBRVMsQ0FBQztZQUMzQixJQUFJUixRQUFRUTtZQUVaLE1BQU9SLFFBQVEsRUFBRztnQkFDaEIsSUFBSVMsY0FBY1QsUUFBUSxNQUFNO2dCQUNoQyxJQUFJVSxTQUFTWixJQUFJLENBQUNXLFlBQVk7Z0JBRTlCLElBQUlFLFFBQVFELFFBQVFYLFFBQVEsR0FBRztvQkFDN0Isd0NBQXdDO29CQUN4Q0QsSUFBSSxDQUFDVyxZQUFZLEdBQUdWO29CQUNwQkQsSUFBSSxDQUFDRSxNQUFNLEdBQUdVO29CQUNkVixRQUFRUztnQkFDVixPQUFPO29CQUNMLCtCQUErQjtvQkFDL0I7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsU0FBU0YsU0FBU1QsSUFBSSxFQUFFQyxJQUFJLEVBQUVTLENBQUM7WUFDN0IsSUFBSVIsUUFBUVE7WUFDWixJQUFJUCxTQUFTSCxLQUFLRyxNQUFNO1lBQ3hCLElBQUlXLGFBQWFYLFdBQVc7WUFFNUIsTUFBT0QsUUFBUVksV0FBWTtnQkFDekIsSUFBSUMsWUFBWSxDQUFDYixRQUFRLEtBQUssSUFBSTtnQkFDbEMsSUFBSWMsT0FBT2hCLElBQUksQ0FBQ2UsVUFBVTtnQkFDMUIsSUFBSUUsYUFBYUYsWUFBWTtnQkFDN0IsSUFBSUcsUUFBUWxCLElBQUksQ0FBQ2lCLFdBQVcsRUFBRSx3RUFBd0U7Z0JBRXRHLElBQUlKLFFBQVFHLE1BQU1mLFFBQVEsR0FBRztvQkFDM0IsSUFBSWdCLGFBQWFkLFVBQVVVLFFBQVFLLE9BQU9GLFFBQVEsR0FBRzt3QkFDbkRoQixJQUFJLENBQUNFLE1BQU0sR0FBR2dCO3dCQUNkbEIsSUFBSSxDQUFDaUIsV0FBVyxHQUFHaEI7d0JBQ25CQyxRQUFRZTtvQkFDVixPQUFPO3dCQUNMakIsSUFBSSxDQUFDRSxNQUFNLEdBQUdjO3dCQUNkaEIsSUFBSSxDQUFDZSxVQUFVLEdBQUdkO3dCQUNsQkMsUUFBUWE7b0JBQ1Y7Z0JBQ0YsT0FBTyxJQUFJRSxhQUFhZCxVQUFVVSxRQUFRSyxPQUFPakIsUUFBUSxHQUFHO29CQUMxREQsSUFBSSxDQUFDRSxNQUFNLEdBQUdnQjtvQkFDZGxCLElBQUksQ0FBQ2lCLFdBQVcsR0FBR2hCO29CQUNuQkMsUUFBUWU7Z0JBQ1YsT0FBTztvQkFDTCxrQ0FBa0M7b0JBQ2xDO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLFNBQVNKLFFBQVFNLENBQUMsRUFBRUMsQ0FBQztZQUNuQiwwQ0FBMEM7WUFDMUMsSUFBSUMsT0FBT0YsRUFBRUcsU0FBUyxHQUFHRixFQUFFRSxTQUFTO1lBQ3BDLE9BQU9ELFNBQVMsSUFBSUEsT0FBT0YsRUFBRUksRUFBRSxHQUFHSCxFQUFFRyxFQUFFO1FBQ3hDO1FBRUEscUJBQXFCO1FBQ3JCLElBQUlDLG9CQUFvQjtRQUN4QixJQUFJQyx1QkFBdUI7UUFDM0IsSUFBSUMsaUJBQWlCO1FBQ3JCLElBQUlDLGNBQWM7UUFDbEIsSUFBSUMsZUFBZTtRQUVuQixTQUFTQyxnQkFBZ0JDLElBQUksRUFBRUMsRUFBRSxHQUNqQztRQUVBLHlCQUF5QixHQUN6QkMsb0JBQW9CLEdBQUcsS0FBSztRQUM1QixJQUFJRSxvQkFDSixPQUFPQyxnQkFBZ0IsWUFBWSxPQUFPQSxZQUFZQyxHQUFHLEtBQUs7UUFFOUQsSUFBSUYsbUJBQW1CO1lBQ3JCLElBQUlHLG1CQUFtQkY7WUFFdkJILG9CQUFvQixHQUFHO2dCQUNyQixPQUFPSyxpQkFBaUJELEdBQUc7WUFDN0I7UUFDRixPQUFPO1lBQ0wsSUFBSUUsWUFBWUM7WUFDaEIsSUFBSUMsY0FBY0YsVUFBVUYsR0FBRztZQUUvQkosb0JBQW9CLEdBQUc7Z0JBQ3JCLE9BQU9NLFVBQVVGLEdBQUcsS0FBS0k7WUFDM0I7UUFDRixFQUFFLHFFQUFxRTtRQUN2RSxzQkFBc0I7UUFDdEIsbUNBQW1DO1FBR25DLElBQUlDLG9CQUFvQixZQUFZLGlDQUFpQztRQUVyRSxJQUFJQyxZQUFZLEVBQUU7UUFDbEIsSUFBSUMsYUFBYSxFQUFFLEVBQUUsNkRBQTZEO1FBRWxGLElBQUlDLGdCQUFnQixHQUFHLGlEQUFpRDtRQUN4RSxJQUFJQyxjQUFjO1FBQ2xCLElBQUlDLHVCQUF1QnBCLGdCQUFnQiw2REFBNkQ7UUFFeEcsSUFBSXFCLG1CQUFtQjtRQUN2QixJQUFJQywwQkFBMEI7UUFDOUIsSUFBSUMseUJBQXlCLE9BQU8sOEVBQThFO1FBRWxILElBQUlDLGtCQUFrQixPQUFPQyxlQUFlLGFBQWFBLGFBQWE7UUFDdEUsSUFBSUMsb0JBQW9CLE9BQU9DLGlCQUFpQixhQUFhQSxlQUFlO1FBQzVFLElBQUlDLG9CQUFvQixPQUFPQyxpQkFBaUIsY0FBY0EsZUFBZSxNQUFNLHlCQUF5QjtRQUU1RyxPQUFPQyxjQUFjLGVBQWUsMkJBQTJCO1FBQy9EQSxVQUFVQyxVQUFVLEtBQUtDLGFBQWEsZ0NBQWdDO1FBQ3RFRixVQUFVQyxVQUFVLENBQUNFLGNBQWMsS0FBS0QsWUFBWUYsVUFBVUMsVUFBVSxDQUFDRSxjQUFjLENBQUNDLElBQUksQ0FBQ0osVUFBVUMsVUFBVSxJQUFJO1FBRXJILFNBQVNJLGNBQWNDLFdBQVc7WUFDaEMsd0VBQXdFO1lBQ3hFLElBQUlDLFFBQVExRCxLQUFLc0M7WUFFakIsTUFBT29CLFVBQVUsS0FBTTtnQkFDckIsSUFBSUEsTUFBTUMsUUFBUSxLQUFLLE1BQU07b0JBQzNCLHVCQUF1QjtvQkFDdkIxRCxJQUFJcUM7Z0JBQ04sT0FBTyxJQUFJb0IsTUFBTUUsU0FBUyxJQUFJSCxhQUFhO29CQUN6QywyQ0FBMkM7b0JBQzNDeEQsSUFBSXFDO29CQUNKb0IsTUFBTXpDLFNBQVMsR0FBR3lDLE1BQU1HLGNBQWM7b0JBQ3RDbkUsS0FBSzJDLFdBQVdxQjtnQkFDbEIsT0FBTztvQkFDTCxnQ0FBZ0M7b0JBQ2hDO2dCQUNGO2dCQUVBQSxRQUFRMUQsS0FBS3NDO1lBQ2Y7UUFDRjtRQUVBLFNBQVN3QixjQUFjTCxXQUFXO1lBQ2hDYix5QkFBeUI7WUFDekJZLGNBQWNDO1lBRWQsSUFBSSxDQUFDZCx5QkFBeUI7Z0JBQzVCLElBQUkzQyxLQUFLcUMsZUFBZSxNQUFNO29CQUM1Qk0sMEJBQTBCO29CQUMxQm9CO2dCQUNGLE9BQU87b0JBQ0wsSUFBSUMsYUFBYWhFLEtBQUtzQztvQkFFdEIsSUFBSTBCLGVBQWUsTUFBTTt3QkFDdkJDLG1CQUFtQkgsZUFBZUUsV0FBV0osU0FBUyxHQUFHSDtvQkFDM0Q7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsU0FBU1MsVUFBVS9CLFdBQVc7WUFHNUJRLDBCQUEwQjtZQUUxQixJQUFJQyx3QkFBd0I7Z0JBQzFCLCtEQUErRDtnQkFDL0RBLHlCQUF5QjtnQkFDekJ1QjtZQUNGO1lBRUF6QixtQkFBbUI7WUFDbkIsSUFBSTBCLHdCQUF3QjNCO1lBRTVCLElBQUk7Z0JBQ0YsSUFBSWdCO2dCQUFhLElBQUlwRTtxQkFBd0I7b0JBQzNDLDhCQUE4QjtvQkFDOUIsT0FBT2dGLFNBQVNsQztnQkFDbEI7WUFDRixTQUFVO2dCQUNSSyxjQUFjO2dCQUNkQyx1QkFBdUIyQjtnQkFDdkIxQixtQkFBbUI7WUFDckI7UUFDRjtRQUVBLFNBQVMyQixTQUFTbEMsV0FBVztZQUMzQixJQUFJc0IsY0FBY3RCO1lBQ2xCcUIsY0FBY0M7WUFDZGpCLGNBQWN4QyxLQUFLcUM7WUFFbkIsTUFBT0csZ0JBQWdCLFFBQVEsQ0FBRXBELHlCQUE0QjtnQkFDM0QsSUFBSW9ELFlBQVlxQixjQUFjLEdBQUdKLGVBQWVhLHFCQUFxQjtvQkFFbkU7Z0JBQ0YsRUFBRSx5REFBeUQ7Z0JBRzNELElBQUlYLFdBQVduQixZQUFZbUIsUUFBUTtnQkFFbkMsSUFBSSxPQUFPQSxhQUFhLFlBQVk7b0JBQ2xDLHlEQUF5RDtvQkFDekRuQixZQUFZbUIsUUFBUSxHQUFHLE1BQU0seURBQXlEO29CQUV0RmxCLHVCQUF1QkQsWUFBWStCLGFBQWEsRUFBRSx5REFBeUQ7b0JBRTNHLElBQUlDLHlCQUF5QmhDLFlBQVlxQixjQUFjLElBQUlKO29CQUUzRCxJQUFJZ0IsdUJBQXVCZCxTQUFTYTtvQkFDcENmLGNBQWM5QixRQUFRQyxZQUFZO29CQUVsQyxJQUFJLE9BQU82Qyx5QkFBeUIsWUFBWTt3QkFDOUMsc0VBQXNFO3dCQUN0RSxpRUFBaUU7d0JBQ2pFLHlEQUF5RDt3QkFDekRqQyxZQUFZbUIsUUFBUSxHQUFHYzt3QkFFdkJqQixjQUFjQzt3QkFDZCxPQUFPO29CQUNULE9BQU87d0JBRUwsSUFBSWpCLGdCQUFnQnhDLEtBQUtxQyxZQUFZOzRCQUNuQ3BDLElBQUlvQzt3QkFDTjt3QkFFQW1CLGNBQWNDO29CQUNoQjtnQkFDRixPQUFPO29CQUNMeEQsSUFBSW9DO2dCQUNOO2dCQUVBRyxjQUFjeEMsS0FBS3FDO1lBQ3JCLEVBQUUseUNBQXlDO1lBRzNDLElBQUlHLGdCQUFnQixNQUFNO2dCQUN4QixPQUFPO1lBQ1QsT0FBTztnQkFDTCxJQUFJd0IsYUFBYWhFLEtBQUtzQztnQkFFdEIsSUFBSTBCLGVBQWUsTUFBTTtvQkFDdkJDLG1CQUFtQkgsZUFBZUUsV0FBV0osU0FBUyxHQUFHSDtnQkFDM0Q7Z0JBRUEsT0FBTztZQUNUO1FBQ0Y7UUFFQSxTQUFTaUIseUJBQXlCSCxhQUFhLEVBQUVJLFlBQVk7WUFDM0QsT0FBUUo7Z0JBQ04sS0FBS3BEO2dCQUNMLEtBQUtDO2dCQUNMLEtBQUtDO2dCQUNMLEtBQUtDO2dCQUNMLEtBQUtDO29CQUNIO2dCQUVGO29CQUNFZ0QsZ0JBQWdCbEQ7WUFDcEI7WUFFQSxJQUFJK0Msd0JBQXdCM0I7WUFDNUJBLHVCQUF1QjhCO1lBRXZCLElBQUk7Z0JBQ0YsT0FBT0k7WUFDVCxTQUFVO2dCQUNSbEMsdUJBQXVCMkI7WUFDekI7UUFDRjtRQUVBLFNBQVNRLGNBQWNELFlBQVk7WUFDakMsSUFBSUo7WUFFSixPQUFROUI7Z0JBQ04sS0FBS3RCO2dCQUNMLEtBQUtDO2dCQUNMLEtBQUtDO29CQUNILGdDQUFnQztvQkFDaENrRCxnQkFBZ0JsRDtvQkFDaEI7Z0JBRUY7b0JBQ0UsMEVBQTBFO29CQUMxRWtELGdCQUFnQjlCO29CQUNoQjtZQUNKO1lBRUEsSUFBSTJCLHdCQUF3QjNCO1lBQzVCQSx1QkFBdUI4QjtZQUV2QixJQUFJO2dCQUNGLE9BQU9JO1lBQ1QsU0FBVTtnQkFDUmxDLHVCQUF1QjJCO1lBQ3pCO1FBQ0Y7UUFFQSxTQUFTUyxzQkFBc0JsQixRQUFRO1lBQ3JDLElBQUltQixzQkFBc0JyQyxzQkFBc0Isa0NBQWtDO1lBQ2xGLGlDQUFpQztZQUVqQyxPQUFPO2dCQUNMLDhEQUE4RDtnQkFDOUQsSUFBSTJCLHdCQUF3QjNCO2dCQUM1QkEsdUJBQXVCcUM7Z0JBRXZCLElBQUk7b0JBQ0YsT0FBT25CLFNBQVNvQixLQUFLLENBQUMsSUFBSSxFQUFFQztnQkFDOUIsU0FBVTtvQkFDUnZDLHVCQUF1QjJCO2dCQUN6QjtZQUNGO1FBQ0Y7UUFFQSxTQUFTYSwwQkFBMEJWLGFBQWEsRUFBRVosUUFBUSxFQUFFdUIsT0FBTztZQUNqRSxJQUFJekIsY0FBYzlCLFFBQVFDLFlBQVk7WUFDdEMsSUFBSWdDO1lBRUosSUFBSSxPQUFPc0IsWUFBWSxZQUFZQSxZQUFZLE1BQU07Z0JBQ25ELElBQUlDLFFBQVFELFFBQVFDLEtBQUs7Z0JBRXpCLElBQUksT0FBT0EsVUFBVSxZQUFZQSxRQUFRLEdBQUc7b0JBQzFDdkIsWUFBWUgsY0FBYzBCO2dCQUM1QixPQUFPO29CQUNMdkIsWUFBWUg7Z0JBQ2Q7WUFDRixPQUFPO2dCQUNMRyxZQUFZSDtZQUNkO1lBRUEsSUFBSTJCO1lBRUosT0FBUWI7Z0JBQ04sS0FBS3BEO29CQUNILHdCQUF3QjtvQkFDeEJpRSxVQUFVLENBQUM7b0JBQ1g7Z0JBRUYsS0FBS2hFO29CQUNILHVCQUF1QjtvQkFDdkJnRSxVQUFVN0Y7b0JBQ1Y7Z0JBRUYsS0FBS2dDO29CQUNILGtCQUFrQjtvQkFDbEI2RCxVQUFVaEQ7b0JBQ1Y7Z0JBRUYsS0FBS2Q7b0JBQ0gsdUJBQXVCO29CQUN2QjhELFVBQVUzRjtvQkFDVjtnQkFFRixLQUFLNEI7Z0JBQ0w7b0JBQ0UsdUJBQXVCO29CQUN2QitELFVBQVU1RjtvQkFDVjtZQUNKO1lBRUEsSUFBSXFFLGlCQUFpQkQsWUFBWXdCO1lBQ2pDLElBQUlDLFVBQVU7Z0JBQ1puRSxJQUFJcUI7Z0JBQ0pvQixVQUFVQTtnQkFDVlksZUFBZUE7Z0JBQ2ZYLFdBQVdBO2dCQUNYQyxnQkFBZ0JBO2dCQUNoQjVDLFdBQVcsQ0FBQztZQUNkO1lBRUEsSUFBSTJDLFlBQVlILGFBQWE7Z0JBQzNCLDBCQUEwQjtnQkFDMUI0QixRQUFRcEUsU0FBUyxHQUFHMkM7Z0JBQ3BCbEUsS0FBSzRDLFlBQVkrQztnQkFFakIsSUFBSXJGLEtBQUtxQyxlQUFlLFFBQVFnRCxZQUFZckYsS0FBS3NDLGFBQWE7b0JBQzVELHVFQUF1RTtvQkFDdkUsSUFBSU0sd0JBQXdCO3dCQUMxQiw4QkFBOEI7d0JBQzlCdUI7b0JBQ0YsT0FBTzt3QkFDTHZCLHlCQUF5QjtvQkFDM0IsRUFBRSxzQkFBc0I7b0JBR3hCcUIsbUJBQW1CSCxlQUFlRixZQUFZSDtnQkFDaEQ7WUFDRixPQUFPO2dCQUNMNEIsUUFBUXBFLFNBQVMsR0FBRzRDO2dCQUNwQm5FLEtBQUsyQyxXQUFXZ0Q7Z0JBQ2hCLHFDQUFxQztnQkFHckMsSUFBSSxDQUFDMUMsMkJBQTJCLENBQUNELGtCQUFrQjtvQkFDakRDLDBCQUEwQjtvQkFDMUJvQjtnQkFDRjtZQUNGO1lBRUEsT0FBT3NCO1FBQ1Q7UUFFQSxTQUFTQywyQkFDVDtRQUVBLFNBQVNDO1lBRVAsSUFBSSxDQUFDNUMsMkJBQTJCLENBQUNELGtCQUFrQjtnQkFDakRDLDBCQUEwQjtnQkFDMUJvQjtZQUNGO1FBQ0Y7UUFFQSxTQUFTeUI7WUFDUCxPQUFPeEYsS0FBS3FDO1FBQ2Q7UUFFQSxTQUFTb0Qsd0JBQXdCaEUsSUFBSTtZQUNuQyx5RUFBeUU7WUFDekUseUNBQXlDO1lBR3pDQSxLQUFLa0MsUUFBUSxHQUFHO1FBQ2xCO1FBRUEsU0FBUytCO1lBQ1AsT0FBT2pEO1FBQ1Q7UUFFQSxJQUFJa0QsdUJBQXVCO1FBQzNCLElBQUlDLGdCQUFnQixDQUFDLEdBQUcsd0VBQXdFO1FBQ2hHLDRFQUE0RTtRQUM1RSw2RUFBNkU7UUFDN0UsMEVBQTBFO1FBRTFFLElBQUlDLGdCQUFnQnZHO1FBQ3BCLElBQUlzRSxZQUFZLENBQUM7UUFFakIsU0FBU1U7WUFDUCxJQUFJd0IsY0FBY25FLFFBQVFDLFlBQVksS0FBS2dDO1lBRTNDLElBQUlrQyxjQUFjRCxlQUFlO2dCQUMvQiwyRUFBMkU7Z0JBQzNFLGdEQUFnRDtnQkFDaEQsT0FBTztZQUNULEVBQUUsMkVBQTJFO1lBRzdFLE9BQU87UUFDVDtRQUVBLFNBQVNFLGdCQUVUO1FBRUEsU0FBU0MsZUFBZUMsR0FBRztZQUN6QixJQUFJQSxNQUFNLEtBQUtBLE1BQU0sS0FBSztnQkFDeEIsbURBQW1EO2dCQUNuREMsT0FBTyxDQUFDLFFBQVEsQ0FBQyw0REFBNEQ7Z0JBQzdFO1lBQ0Y7WUFFQSxJQUFJRCxNQUFNLEdBQUc7Z0JBQ1hKLGdCQUFnQk0sS0FBS0MsS0FBSyxDQUFDLE9BQU9IO1lBQ3BDLE9BQU87Z0JBQ0wsc0JBQXNCO2dCQUN0QkosZ0JBQWdCdkc7WUFDbEI7UUFDRjtRQUVBLElBQUkrRywyQkFBMkI7WUFDN0IsSUFBSVYsc0JBQXNCO2dCQUN4QixJQUFJbEMsY0FBYzlCLFFBQVFDLFlBQVksSUFBSSwwRUFBMEU7Z0JBQ3BILG9CQUFvQjtnQkFFcEJnQyxZQUFZSCxhQUFhLG1FQUFtRTtnQkFDNUYseUJBQXlCO2dCQUN6QixFQUFFO2dCQUNGLHVFQUF1RTtnQkFDdkUsNkVBQTZFO2dCQUM3RSxpREFBaUQ7Z0JBRWpELElBQUk2QyxjQUFjO2dCQUVsQixJQUFJO29CQUNGQSxjQUFjcEMsVUFBVVQ7Z0JBQzFCLFNBQVU7b0JBQ1IsSUFBSTZDLGFBQWE7d0JBQ2YsbUVBQW1FO3dCQUNuRSx3QkFBd0I7d0JBQ3hCQztvQkFDRixPQUFPO3dCQUNMWix1QkFBdUI7b0JBQ3pCO2dCQUNGO1lBQ0YsRUFBRSxvRUFBb0U7UUFDeEU7UUFFQSxJQUFJWTtRQUVKLElBQUksT0FBT3RELHNCQUFzQixZQUFZO1lBQzNDLHNCQUFzQjtZQUN0Qix3REFBd0Q7WUFDeEQsRUFBRTtZQUNGLDRFQUE0RTtZQUM1RSx1RUFBdUU7WUFDdkUscUVBQXFFO1lBQ3JFLGlEQUFpRDtZQUNqRCxFQUFFO1lBQ0YsMkRBQTJEO1lBQzNELDhEQUE4RDtZQUM5RCxpRUFBaUU7WUFDakVzRCxtQ0FBbUM7Z0JBQ2pDdEQsa0JBQWtCb0Q7WUFDcEI7UUFDRixPQUFPLElBQUksT0FBT0csbUJBQW1CLGFBQWE7WUFDaEQsK0JBQStCO1lBQy9CLG1FQUFtRTtZQUNuRSxJQUFJQyxVQUFVLElBQUlEO1lBQ2xCLElBQUlFLE9BQU9ELFFBQVFFLEtBQUs7WUFDeEJGLFFBQVFHLEtBQUssQ0FBQ0MsU0FBUyxHQUFHUjtZQUUxQkUsbUNBQW1DO2dCQUNqQ0csS0FBS0ksV0FBVyxDQUFDO1lBQ25CO1FBQ0YsT0FBTztZQUNMLDREQUE0RDtZQUM1RFAsbUNBQW1DO2dCQUNqQyw0Q0FBNEM7Z0JBQzVDMUQsZ0JBQWdCd0QsMEJBQTBCO1lBQzVDO1FBQ0Y7UUFFQSxTQUFTdEM7WUFDUCxJQUFJLENBQUM0QixzQkFBc0I7Z0JBQ3pCQSx1QkFBdUI7Z0JBQ3ZCWTtZQUNGO1FBQ0Y7UUFFQSxTQUFTdEMsbUJBQW1CTixRQUFRLEVBQUVqQyxFQUFFO1lBQ3RDLDRDQUE0QztZQUM1Q2tFLGdCQUFnQi9DLGdCQUFnQjtnQkFDOUJjLFNBQVNoQyxRQUFRQyxZQUFZO1lBQy9CLEdBQUdGO1FBQ0w7UUFFQSxTQUFTeUM7WUFDUCw0Q0FBNEM7WUFDNUNwQixrQkFBa0I2QztZQUNsQkEsZ0JBQWdCLENBQUM7UUFDbkI7UUFDQSxJQUFJbUIscUJBQXFCO1FBRXpCcEYsNkJBQTZCLEdBQUdKO1FBQ2hDSSxrQ0FBa0MsR0FBR1I7UUFDckNRLDRCQUE0QixHQUFHTDtRQUMvQkssK0JBQStCLEdBQUdOO1FBQ2xDTSwwQkFBMEIsR0FBR29GO1FBQzdCcEYscUNBQXFDLEdBQUdQO1FBQ3hDTywrQkFBK0IsR0FBRzhEO1FBQ2xDOUQsa0NBQWtDLEdBQUc0RDtRQUNyQzVELCtCQUErQixHQUFHcUU7UUFDbENyRSx3Q0FBd0MsR0FBRytEO1FBQzNDL0QscUNBQXFDLEdBQUc2RDtRQUN4QzdELHFCQUFxQixHQUFHaUQ7UUFDeEJqRCwrQkFBK0IsR0FBRzJEO1FBQ2xDM0QsNkJBQTZCLEdBQUdvRTtRQUNoQ3BFLGdDQUFnQyxHQUFHK0M7UUFDbkMvQyxpQ0FBaUMsR0FBR3NEO1FBQ3BDdEQsNEJBQTRCLEdBQUcyQztRQUMvQjNDLDZCQUE2QixHQUFHa0Q7UUFDdEIseUNBQXlDLEdBQ25ELElBQ0UsT0FBTzVGLG1DQUFtQyxlQUMxQyxPQUFPQSwrQkFBK0J1SSwwQkFBMEIsS0FDOUQsWUFDRjtZQUNBdkksK0JBQStCdUksMEJBQTBCLENBQUMsSUFBSXJJO1FBQ2hFO0lBRUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3NjaGVkdWxlci9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzPzdhM2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgICB2YXIgZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nID0gZmFsc2U7XG52YXIgZW5hYmxlUHJvZmlsaW5nID0gZmFsc2U7XG52YXIgZnJhbWVZaWVsZE1zID0gNTtcbnZhciB1c2VyQmxvY2tpbmdQcmlvcml0eVRpbWVvdXQgPSAyNTA7XG52YXIgbm9ybWFsUHJpb3JpdHlUaW1lb3V0ID0gNTAwMDtcbnZhciBsb3dQcmlvcml0eVRpbWVvdXQgPSAxMDAwMDtcblxuZnVuY3Rpb24gcHVzaChoZWFwLCBub2RlKSB7XG4gIHZhciBpbmRleCA9IGhlYXAubGVuZ3RoO1xuICBoZWFwLnB1c2gobm9kZSk7XG4gIHNpZnRVcChoZWFwLCBub2RlLCBpbmRleCk7XG59XG5mdW5jdGlvbiBwZWVrKGhlYXApIHtcbiAgcmV0dXJuIGhlYXAubGVuZ3RoID09PSAwID8gbnVsbCA6IGhlYXBbMF07XG59XG5mdW5jdGlvbiBwb3AoaGVhcCkge1xuICBpZiAoaGVhcC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBmaXJzdCA9IGhlYXBbMF07XG4gIHZhciBsYXN0ID0gaGVhcC5wb3AoKTtcblxuICBpZiAobGFzdCAhPT0gZmlyc3QpIHtcbiAgICBoZWFwWzBdID0gbGFzdDtcbiAgICBzaWZ0RG93bihoZWFwLCBsYXN0LCAwKTtcbiAgfVxuXG4gIHJldHVybiBmaXJzdDtcbn1cblxuZnVuY3Rpb24gc2lmdFVwKGhlYXAsIG5vZGUsIGkpIHtcbiAgdmFyIGluZGV4ID0gaTtcblxuICB3aGlsZSAoaW5kZXggPiAwKSB7XG4gICAgdmFyIHBhcmVudEluZGV4ID0gaW5kZXggLSAxID4+PiAxO1xuICAgIHZhciBwYXJlbnQgPSBoZWFwW3BhcmVudEluZGV4XTtcblxuICAgIGlmIChjb21wYXJlKHBhcmVudCwgbm9kZSkgPiAwKSB7XG4gICAgICAvLyBUaGUgcGFyZW50IGlzIGxhcmdlci4gU3dhcCBwb3NpdGlvbnMuXG4gICAgICBoZWFwW3BhcmVudEluZGV4XSA9IG5vZGU7XG4gICAgICBoZWFwW2luZGV4XSA9IHBhcmVudDtcbiAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBwYXJlbnQgaXMgc21hbGxlci4gRXhpdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2lmdERvd24oaGVhcCwgbm9kZSwgaSkge1xuICB2YXIgaW5kZXggPSBpO1xuICB2YXIgbGVuZ3RoID0gaGVhcC5sZW5ndGg7XG4gIHZhciBoYWxmTGVuZ3RoID0gbGVuZ3RoID4+PiAxO1xuXG4gIHdoaWxlIChpbmRleCA8IGhhbGZMZW5ndGgpIHtcbiAgICB2YXIgbGVmdEluZGV4ID0gKGluZGV4ICsgMSkgKiAyIC0gMTtcbiAgICB2YXIgbGVmdCA9IGhlYXBbbGVmdEluZGV4XTtcbiAgICB2YXIgcmlnaHRJbmRleCA9IGxlZnRJbmRleCArIDE7XG4gICAgdmFyIHJpZ2h0ID0gaGVhcFtyaWdodEluZGV4XTsgLy8gSWYgdGhlIGxlZnQgb3IgcmlnaHQgbm9kZSBpcyBzbWFsbGVyLCBzd2FwIHdpdGggdGhlIHNtYWxsZXIgb2YgdGhvc2UuXG5cbiAgICBpZiAoY29tcGFyZShsZWZ0LCBub2RlKSA8IDApIHtcbiAgICAgIGlmIChyaWdodEluZGV4IDwgbGVuZ3RoICYmIGNvbXBhcmUocmlnaHQsIGxlZnQpIDwgMCkge1xuICAgICAgICBoZWFwW2luZGV4XSA9IHJpZ2h0O1xuICAgICAgICBoZWFwW3JpZ2h0SW5kZXhdID0gbm9kZTtcbiAgICAgICAgaW5kZXggPSByaWdodEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVhcFtpbmRleF0gPSBsZWZ0O1xuICAgICAgICBoZWFwW2xlZnRJbmRleF0gPSBub2RlO1xuICAgICAgICBpbmRleCA9IGxlZnRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJpZ2h0SW5kZXggPCBsZW5ndGggJiYgY29tcGFyZShyaWdodCwgbm9kZSkgPCAwKSB7XG4gICAgICBoZWFwW2luZGV4XSA9IHJpZ2h0O1xuICAgICAgaGVhcFtyaWdodEluZGV4XSA9IG5vZGU7XG4gICAgICBpbmRleCA9IHJpZ2h0SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5laXRoZXIgY2hpbGQgaXMgc21hbGxlci4gRXhpdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIC8vIENvbXBhcmUgc29ydCBpbmRleCBmaXJzdCwgdGhlbiB0YXNrIGlkLlxuICB2YXIgZGlmZiA9IGEuc29ydEluZGV4IC0gYi5zb3J0SW5kZXg7XG4gIHJldHVybiBkaWZmICE9PSAwID8gZGlmZiA6IGEuaWQgLSBiLmlkO1xufVxuXG4vLyBUT0RPOiBVc2Ugc3ltYm9scz9cbnZhciBJbW1lZGlhdGVQcmlvcml0eSA9IDE7XG52YXIgVXNlckJsb2NraW5nUHJpb3JpdHkgPSAyO1xudmFyIE5vcm1hbFByaW9yaXR5ID0gMztcbnZhciBMb3dQcmlvcml0eSA9IDQ7XG52YXIgSWRsZVByaW9yaXR5ID0gNTtcblxuZnVuY3Rpb24gbWFya1Rhc2tFcnJvcmVkKHRhc2ssIG1zKSB7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuZXhwb3J0cy51bnN0YWJsZV9ub3cgPSB2b2lkIDA7XG52YXIgaGFzUGVyZm9ybWFuY2VOb3cgPSAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG50eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XG5cbmlmIChoYXNQZXJmb3JtYW5jZU5vdykge1xuICB2YXIgbG9jYWxQZXJmb3JtYW5jZSA9IHBlcmZvcm1hbmNlO1xuXG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhbFBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIGxvY2FsRGF0ZSA9IERhdGU7XG4gIHZhciBpbml0aWFsVGltZSA9IGxvY2FsRGF0ZS5ub3coKTtcblxuICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbG9jYWxEYXRlLm5vdygpIC0gaW5pdGlhbFRpbWU7XG4gIH07XG59IC8vIE1heCAzMSBiaXQgaW50ZWdlci4gVGhlIG1heCBpbnRlZ2VyIHNpemUgaW4gVjggZm9yIDMyLWJpdCBzeXN0ZW1zLlxuLy8gTWF0aC5wb3coMiwgMzApIC0gMVxuLy8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcblxuXG52YXIgbWF4U2lnbmVkMzFCaXRJbnQgPSAxMDczNzQxODIzOyAvLyBUYXNrcyBhcmUgc3RvcmVkIG9uIGEgbWluIGhlYXBcblxudmFyIHRhc2tRdWV1ZSA9IFtdO1xudmFyIHRpbWVyUXVldWUgPSBbXTsgLy8gSW5jcmVtZW50aW5nIGlkIGNvdW50ZXIuIFVzZWQgdG8gbWFpbnRhaW4gaW5zZXJ0aW9uIG9yZGVyLlxuXG52YXIgdGFza0lkQ291bnRlciA9IDE7IC8vIFBhdXNpbmcgdGhlIHNjaGVkdWxlciBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZy5cbnZhciBjdXJyZW50VGFzayA9IG51bGw7XG52YXIgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTsgLy8gVGhpcyBpcyBzZXQgd2hpbGUgcGVyZm9ybWluZyB3b3JrLCB0byBwcmV2ZW50IHJlLWVudHJhbmNlLlxuXG52YXIgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xudmFyIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG52YXIgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IGZhbHNlOyAvLyBDYXB0dXJlIGxvY2FsIHJlZmVyZW5jZXMgdG8gbmF0aXZlIEFQSXMsIGluIGNhc2UgYSBwb2x5ZmlsbCBvdmVycmlkZXMgdGhlbS5cblxudmFyIGxvY2FsU2V0VGltZW91dCA9IHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gc2V0VGltZW91dCA6IG51bGw7XG52YXIgbG9jYWxDbGVhclRpbWVvdXQgPSB0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gY2xlYXJUaW1lb3V0IDogbnVsbDtcbnZhciBsb2NhbFNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnID8gc2V0SW1tZWRpYXRlIDogbnVsbDsgLy8gSUUgYW5kIE5vZGUuanMgKyBqc2RvbVxuXG50eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbm5hdmlnYXRvci5zY2hlZHVsaW5nICE9PSB1bmRlZmluZWQgJiYgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV1cbm5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nICE9PSB1bmRlZmluZWQgPyBuYXZpZ2F0b3Iuc2NoZWR1bGluZy5pc0lucHV0UGVuZGluZy5iaW5kKG5hdmlnYXRvci5zY2hlZHVsaW5nKSA6IG51bGw7XG5cbmZ1bmN0aW9uIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpIHtcbiAgLy8gQ2hlY2sgZm9yIHRhc2tzIHRoYXQgYXJlIG5vIGxvbmdlciBkZWxheWVkIGFuZCBhZGQgdGhlbSB0byB0aGUgcXVldWUuXG4gIHZhciB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG5cbiAgd2hpbGUgKHRpbWVyICE9PSBudWxsKSB7XG4gICAgaWYgKHRpbWVyLmNhbGxiYWNrID09PSBudWxsKSB7XG4gICAgICAvLyBUaW1lciB3YXMgY2FuY2VsbGVkLlxuICAgICAgcG9wKHRpbWVyUXVldWUpO1xuICAgIH0gZWxzZSBpZiAodGltZXIuc3RhcnRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBUaW1lciBmaXJlZC4gVHJhbnNmZXIgdG8gdGhlIHRhc2sgcXVldWUuXG4gICAgICBwb3AodGltZXJRdWV1ZSk7XG4gICAgICB0aW1lci5zb3J0SW5kZXggPSB0aW1lci5leHBpcmF0aW9uVGltZTtcbiAgICAgIHB1c2godGFza1F1ZXVlLCB0aW1lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbWFpbmluZyB0aW1lcnMgYXJlIHBlbmRpbmcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoY3VycmVudFRpbWUpIHtcbiAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IGZhbHNlO1xuICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcblxuICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkKSB7XG4gICAgaWYgKHBlZWsodGFza1F1ZXVlKSAhPT0gbnVsbCkge1xuICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEhvc3RDYWxsYmFjaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmlyc3RUaW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG5cbiAgICAgIGlmIChmaXJzdFRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBmaXJzdFRpbWVyLnN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hXb3JrKGluaXRpYWxUaW1lKSB7XG5cblxuICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIGlmIChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkKSB7XG4gICAgLy8gV2Ugc2NoZWR1bGVkIGEgdGltZW91dCBidXQgaXQncyBubyBsb25nZXIgbmVlZGVkLiBDYW5jZWwgaXQuXG4gICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGNhbmNlbEhvc3RUaW1lb3V0KCk7XG4gIH1cblxuICBpc1BlcmZvcm1pbmdXb3JrID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuXG4gIHRyeSB7XG4gICAgdmFyIGN1cnJlbnRUaW1lOyBpZiAoZW5hYmxlUHJvZmlsaW5nKSA7IGVsc2Uge1xuICAgICAgLy8gTm8gY2F0Y2ggaW4gcHJvZCBjb2RlIHBhdGguXG4gICAgICByZXR1cm4gd29ya0xvb3AoaW5pdGlhbFRpbWUpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50VGFzayA9IG51bGw7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdvcmtMb29wKGluaXRpYWxUaW1lKSB7XG4gIHZhciBjdXJyZW50VGltZSA9IGluaXRpYWxUaW1lO1xuICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG5cbiAgd2hpbGUgKGN1cnJlbnRUYXNrICE9PSBudWxsICYmICEoZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nICkpIHtcbiAgICBpZiAoY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPiBjdXJyZW50VGltZSAmJiBzaG91bGRZaWVsZFRvSG9zdCgpKSB7XG4gICAgICAvLyBUaGlzIGN1cnJlbnRUYXNrIGhhc24ndCBleHBpcmVkLCBhbmQgd2UndmUgcmVhY2hlZCB0aGUgZGVhZGxpbmUuXG4gICAgICBicmVhaztcbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICB2YXIgY2FsbGJhY2sgPSBjdXJyZW50VGFzay5jYWxsYmFjaztcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBudWxsOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50VGFzay5wcmlvcml0eUxldmVsOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuICAgICAgdmFyIGRpZFVzZXJDYWxsYmFja1RpbWVvdXQgPSBjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZTtcblxuICAgICAgdmFyIGNvbnRpbnVhdGlvbkNhbGxiYWNrID0gY2FsbGJhY2soZGlkVXNlckNhbGxiYWNrVGltZW91dCk7XG4gICAgICBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG5cbiAgICAgIGlmICh0eXBlb2YgY29udGludWF0aW9uQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSWYgYSBjb250aW51YXRpb24gaXMgcmV0dXJuZWQsIGltbWVkaWF0ZWx5IHlpZWxkIHRvIHRoZSBtYWluIHRocmVhZFxuICAgICAgICAvLyByZWdhcmRsZXNzIG9mIGhvdyBtdWNoIHRpbWUgaXMgbGVmdCBpbiB0aGUgY3VycmVudCB0aW1lIHNsaWNlLlxuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBjb250aW51YXRpb25DYWxsYmFjaztcblxuICAgICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGlmIChjdXJyZW50VGFzayA9PT0gcGVlayh0YXNrUXVldWUpKSB7XG4gICAgICAgICAgcG9wKHRhc2tRdWV1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcG9wKHRhc2tRdWV1ZSk7XG4gICAgfVxuXG4gICAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG4gIH0gLy8gUmV0dXJuIHdoZXRoZXIgdGhlcmUncyBhZGRpdGlvbmFsIHdvcmtcblxuXG4gIGlmIChjdXJyZW50VGFzayAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICAgIGlmIChmaXJzdFRpbWVyICE9PSBudWxsKSB7XG4gICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eShwcmlvcml0eUxldmVsLCBldmVudEhhbmRsZXIpIHtcbiAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgfVxuXG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX25leHQoZXZlbnRIYW5kbGVyKSB7XG4gIHZhciBwcmlvcml0eUxldmVsO1xuXG4gIHN3aXRjaCAoY3VycmVudFByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICAgIC8vIFNoaWZ0IGRvd24gdG8gbm9ybWFsIHByaW9yaXR5XG4gICAgICBwcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBBbnl0aGluZyBsb3dlciB0aGFuIG5vcm1hbCBwcmlvcml0eSBzaG91bGQgcmVtYWluIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuICAgICAgcHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcblxuICB0cnkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV93cmFwQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgdmFyIHBhcmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAvLyAkRmxvd0ZpeE1lW21pc3NpbmctdGhpcy1hbm5vdF1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRoaXMgaXMgYSBmb3JrIG9mIHJ1bldpdGhQcmlvcml0eSwgaW5saW5lZCBmb3IgcGVyZm9ybWFuY2UuXG4gICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcGFyZW50UHJpb3JpdHlMZXZlbDtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gIHZhciBzdGFydFRpbWU7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgdmFyIGRlbGF5ID0gb3B0aW9ucy5kZWxheTtcblxuICAgIGlmICh0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInICYmIGRlbGF5ID4gMCkge1xuICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWUgKyBkZWxheTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG5cbiAgdmFyIHRpbWVvdXQ7XG5cbiAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICAgIC8vIFRpbWVzIG91dCBpbW1lZGlhdGVseVxuICAgICAgdGltZW91dCA9IC0xO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgLy8gRXZlbnR1YWxseSB0aW1lcyBvdXRcbiAgICAgIHRpbWVvdXQgPSB1c2VyQmxvY2tpbmdQcmlvcml0eVRpbWVvdXQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgLy8gTmV2ZXIgdGltZXMgb3V0XG4gICAgICB0aW1lb3V0ID0gbWF4U2lnbmVkMzFCaXRJbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTG93UHJpb3JpdHk6XG4gICAgICAvLyBFdmVudHVhbGx5IHRpbWVzIG91dFxuICAgICAgdGltZW91dCA9IGxvd1ByaW9yaXR5VGltZW91dDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRXZlbnR1YWxseSB0aW1lcyBvdXRcbiAgICAgIHRpbWVvdXQgPSBub3JtYWxQcmlvcml0eVRpbWVvdXQ7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHN0YXJ0VGltZSArIHRpbWVvdXQ7XG4gIHZhciBuZXdUYXNrID0ge1xuICAgIGlkOiB0YXNrSWRDb3VudGVyKyssXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIHByaW9yaXR5TGV2ZWw6IHByaW9yaXR5TGV2ZWwsXG4gICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgIHNvcnRJbmRleDogLTFcbiAgfTtcblxuICBpZiAoc3RhcnRUaW1lID4gY3VycmVudFRpbWUpIHtcbiAgICAvLyBUaGlzIGlzIGEgZGVsYXllZCB0YXNrLlxuICAgIG5ld1Rhc2suc29ydEluZGV4ID0gc3RhcnRUaW1lO1xuICAgIHB1c2godGltZXJRdWV1ZSwgbmV3VGFzayk7XG5cbiAgICBpZiAocGVlayh0YXNrUXVldWUpID09PSBudWxsICYmIG5ld1Rhc2sgPT09IHBlZWsodGltZXJRdWV1ZSkpIHtcbiAgICAgIC8vIEFsbCB0YXNrcyBhcmUgZGVsYXllZCwgYW5kIHRoaXMgaXMgdGhlIHRhc2sgd2l0aCB0aGUgZWFybGllc3QgZGVsYXkuXG4gICAgICBpZiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCkge1xuICAgICAgICAvLyBDYW5jZWwgYW4gZXhpc3RpbmcgdGltZW91dC5cbiAgICAgICAgY2FuY2VsSG9zdFRpbWVvdXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgfSAvLyBTY2hlZHVsZSBhIHRpbWVvdXQuXG5cblxuICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIHN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV3VGFzay5zb3J0SW5kZXggPSBleHBpcmF0aW9uVGltZTtcbiAgICBwdXNoKHRhc2tRdWV1ZSwgbmV3VGFzayk7XG4gICAgLy8gd2FpdCB1bnRpbCB0aGUgbmV4dCB0aW1lIHdlIHlpZWxkLlxuXG5cbiAgICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkICYmICFpc1BlcmZvcm1pbmdXb3JrKSB7XG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0SG9zdENhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld1Rhc2s7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uKCkge1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbigpIHtcblxuICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkICYmICFpc1BlcmZvcm1pbmdXb3JrKSB7XG4gICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSgpIHtcbiAgcmV0dXJuIHBlZWsodGFza1F1ZXVlKTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2sodGFzaykge1xuICAvLyByZW1vdmUgZnJvbSB0aGUgcXVldWUgYmVjYXVzZSB5b3UgY2FuJ3QgcmVtb3ZlIGFyYml0cmFyeSBub2RlcyBmcm9tIGFuXG4gIC8vIGFycmF5IGJhc2VkIGhlYXAsIG9ubHkgdGhlIGZpcnN0IG9uZS4pXG5cblxuICB0YXNrLmNhbGxiYWNrID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKSB7XG4gIHJldHVybiBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbn1cblxudmFyIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG52YXIgdGFza1RpbWVvdXRJRCA9IC0xOyAvLyBTY2hlZHVsZXIgcGVyaW9kaWNhbGx5IHlpZWxkcyBpbiBjYXNlIHRoZXJlIGlzIG90aGVyIHdvcmsgb24gdGhlIG1haW5cbi8vIHRocmVhZCwgbGlrZSB1c2VyIGV2ZW50cy4gQnkgZGVmYXVsdCwgaXQgeWllbGRzIG11bHRpcGxlIHRpbWVzIHBlciBmcmFtZS5cbi8vIEl0IGRvZXMgbm90IGF0dGVtcHQgdG8gYWxpZ24gd2l0aCBmcmFtZSBib3VuZGFyaWVzLCBzaW5jZSBtb3N0IHRhc2tzIGRvbid0XG4vLyBuZWVkIHRvIGJlIGZyYW1lIGFsaWduZWQ7IGZvciB0aG9zZSB0aGF0IGRvLCB1c2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxuXG52YXIgZnJhbWVJbnRlcnZhbCA9IGZyYW1lWWllbGRNcztcbnZhciBzdGFydFRpbWUgPSAtMTtcblxuZnVuY3Rpb24gc2hvdWxkWWllbGRUb0hvc3QoKSB7XG4gIHZhciB0aW1lRWxhcHNlZCA9IGV4cG9ydHMudW5zdGFibGVfbm93KCkgLSBzdGFydFRpbWU7XG5cbiAgaWYgKHRpbWVFbGFwc2VkIDwgZnJhbWVJbnRlcnZhbCkge1xuICAgIC8vIFRoZSBtYWluIHRocmVhZCBoYXMgb25seSBiZWVuIGJsb2NrZWQgZm9yIGEgcmVhbGx5IHNob3J0IGFtb3VudCBvZiB0aW1lO1xuICAgIC8vIHNtYWxsZXIgdGhhbiBhIHNpbmdsZSBmcmFtZS4gRG9uJ3QgeWllbGQgeWV0LlxuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUaGUgbWFpbiB0aHJlYWQgaGFzIGJlZW4gYmxvY2tlZCBmb3IgYSBub24tbmVnbGlnaWJsZSBhbW91bnQgb2YgdGltZS4gV2VcblxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0UGFpbnQoKSB7XG5cbn1cblxuZnVuY3Rpb24gZm9yY2VGcmFtZVJhdGUoZnBzKSB7XG4gIGlmIChmcHMgPCAwIHx8IGZwcyA+IDEyNSkge1xuICAgIC8vIFVzaW5nIGNvbnNvbGVbJ2Vycm9yJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuICAgIGNvbnNvbGVbJ2Vycm9yJ10oJ2ZvcmNlRnJhbWVSYXRlIHRha2VzIGEgcG9zaXRpdmUgaW50IGJldHdlZW4gMCBhbmQgMTI1LCAnICsgJ2ZvcmNpbmcgZnJhbWUgcmF0ZXMgaGlnaGVyIHRoYW4gMTI1IGZwcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGZwcyA+IDApIHtcbiAgICBmcmFtZUludGVydmFsID0gTWF0aC5mbG9vcigxMDAwIC8gZnBzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXNldCB0aGUgZnJhbWVyYXRlXG4gICAgZnJhbWVJbnRlcnZhbCA9IGZyYW1lWWllbGRNcztcbiAgfVxufVxuXG52YXIgcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICBpZiAoaXNNZXNzYWdlTG9vcFJ1bm5pbmcpIHtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpOyAvLyBLZWVwIHRyYWNrIG9mIHRoZSBzdGFydCB0aW1lIHNvIHdlIGNhbiBtZWFzdXJlIGhvdyBsb25nIHRoZSBtYWluIHRocmVhZFxuICAgIC8vIGhhcyBiZWVuIGJsb2NrZWQuXG5cbiAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTsgLy8gSWYgYSBzY2hlZHVsZXIgdGFzayB0aHJvd3MsIGV4aXQgdGhlIGN1cnJlbnQgYnJvd3NlciB0YXNrIHNvIHRoZVxuICAgIC8vIGVycm9yIGNhbiBiZSBvYnNlcnZlZC5cbiAgICAvL1xuICAgIC8vIEludGVudGlvbmFsbHkgbm90IHVzaW5nIGEgdHJ5LWNhdGNoLCBzaW5jZSB0aGF0IG1ha2VzIHNvbWUgZGVidWdnaW5nXG4gICAgLy8gdGVjaG5pcXVlcyBoYXJkZXIuIEluc3RlYWQsIGlmIGBmbHVzaFdvcmtgIGVycm9ycywgdGhlbiBgaGFzTW9yZVdvcmtgIHdpbGxcbiAgICAvLyByZW1haW4gdHJ1ZSwgYW5kIHdlJ2xsIGNvbnRpbnVlIHRoZSB3b3JrIGxvb3AuXG5cbiAgICB2YXIgaGFzTW9yZVdvcmsgPSB0cnVlO1xuXG4gICAgdHJ5IHtcbiAgICAgIGhhc01vcmVXb3JrID0gZmx1c2hXb3JrKGN1cnJlbnRUaW1lKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGhhc01vcmVXb3JrKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3MgbW9yZSB3b3JrLCBzY2hlZHVsZSB0aGUgbmV4dCBtZXNzYWdlIGV2ZW50IGF0IHRoZSBlbmRcbiAgICAgICAgLy8gb2YgdGhlIHByZWNlZGluZyBvbmUuXG4gICAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBZaWVsZGluZyB0byB0aGUgYnJvd3NlciB3aWxsIGdpdmUgaXQgYSBjaGFuY2UgdG8gcGFpbnQsIHNvIHdlIGNhblxufTtcblxudmFyIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lO1xuXG5pZiAodHlwZW9mIGxvY2FsU2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIE5vZGUuanMgYW5kIG9sZCBJRS5cbiAgLy8gVGhlcmUncyBhIGZldyByZWFzb25zIGZvciB3aHkgd2UgcHJlZmVyIHNldEltbWVkaWF0ZS5cbiAgLy9cbiAgLy8gVW5saWtlIE1lc3NhZ2VDaGFubmVsLCBpdCBkb2Vzbid0IHByZXZlbnQgYSBOb2RlLmpzIHByb2Nlc3MgZnJvbSBleGl0aW5nLlxuICAvLyAoRXZlbiB0aG91Z2ggdGhpcyBpcyBhIERPTSBmb3JrIG9mIHRoZSBTY2hlZHVsZXIsIHlvdSBjb3VsZCBnZXQgaGVyZVxuICAvLyB3aXRoIGEgbWl4IG9mIE5vZGUuanMgMTUrLCB3aGljaCBoYXMgYSBNZXNzYWdlQ2hhbm5lbCwgYW5kIGpzZG9tLilcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDc1NlxuICAvL1xuICAvLyBCdXQgYWxzbywgaXQgcnVucyBlYXJsaWVyIHdoaWNoIGlzIHRoZSBzZW1hbnRpYyB3ZSB3YW50LlxuICAvLyBJZiBvdGhlciBicm93c2VycyBldmVyIGltcGxlbWVudCBpdCwgaXQncyBiZXR0ZXIgdG8gdXNlIGl0LlxuICAvLyBBbHRob3VnaCBib3RoIG9mIHRoZXNlIHdvdWxkIGJlIGluZmVyaW9yIHRvIG5hdGl2ZSBzY2hlZHVsaW5nLlxuICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsb2NhbFNldEltbWVkaWF0ZShwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUpO1xuICB9O1xufSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIERPTSBhbmQgV29ya2VyIGVudmlyb25tZW50cy5cbiAgLy8gV2UgcHJlZmVyIE1lc3NhZ2VDaGFubmVsIGJlY2F1c2Ugb2YgdGhlIDRtcyBzZXRUaW1lb3V0IGNsYW1waW5nLlxuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICB2YXIgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lO1xuXG4gIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgIHBvcnQucG9zdE1lc3NhZ2UobnVsbCk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBXZSBzaG91bGQgb25seSBmYWxsYmFjayBoZXJlIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy5cbiAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtub3QtYS1mdW5jdGlvbl0gbnVsbGFibGUgdmFsdWVcbiAgICBsb2NhbFNldFRpbWVvdXQocGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lLCAwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVxdWVzdEhvc3RDYWxsYmFjaygpIHtcbiAgaWYgKCFpc01lc3NhZ2VMb29wUnVubmluZykge1xuICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gdHJ1ZTtcbiAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RIb3N0VGltZW91dChjYWxsYmFjaywgbXMpIHtcbiAgLy8gJEZsb3dGaXhNZVtub3QtYS1mdW5jdGlvbl0gbnVsbGFibGUgdmFsdWVcbiAgdGFza1RpbWVvdXRJRCA9IGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2soZXhwb3J0cy51bnN0YWJsZV9ub3coKSk7XG4gIH0sIG1zKTtcbn1cblxuZnVuY3Rpb24gY2FuY2VsSG9zdFRpbWVvdXQoKSB7XG4gIC8vICRGbG93Rml4TWVbbm90LWEtZnVuY3Rpb25dIG51bGxhYmxlIHZhbHVlXG4gIGxvY2FsQ2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpO1xuICB0YXNrVGltZW91dElEID0gLTE7XG59XG52YXIgdW5zdGFibGVfUHJvZmlsaW5nID0gbnVsbDtcblxuZXhwb3J0cy51bnN0YWJsZV9JZGxlUHJpb3JpdHkgPSBJZGxlUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5ID0gSW1tZWRpYXRlUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX0xvd1ByaW9yaXR5ID0gTG93UHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5ID0gTm9ybWFsUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX1Byb2ZpbGluZyA9IHVuc3RhYmxlX1Byb2ZpbGluZztcbmV4cG9ydHMudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHkgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2sgPSB1bnN0YWJsZV9jYW5jZWxDYWxsYmFjaztcbmV4cG9ydHMudW5zdGFibGVfY29udGludWVFeGVjdXRpb24gPSB1bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbjtcbmV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmb3JjZUZyYW1lUmF0ZTtcbmV4cG9ydHMudW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwgPSB1bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbDtcbmV4cG9ydHMudW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUgPSB1bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZTtcbmV4cG9ydHMudW5zdGFibGVfbmV4dCA9IHVuc3RhYmxlX25leHQ7XG5leHBvcnRzLnVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uID0gdW5zdGFibGVfcGF1c2VFeGVjdXRpb247XG5leHBvcnRzLnVuc3RhYmxlX3JlcXVlc3RQYWludCA9IHJlcXVlc3RQYWludDtcbmV4cG9ydHMudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5ID0gdW5zdGFibGVfcnVuV2l0aFByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrID0gdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaztcbmV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSBzaG91bGRZaWVsZFRvSG9zdDtcbmV4cG9ydHMudW5zdGFibGVfd3JhcENhbGxiYWNrID0gdW5zdGFibGVfd3JhcENhbGxiYWNrO1xuICAgICAgICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgXG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsInJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCIsIkVycm9yIiwiZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nIiwiZW5hYmxlUHJvZmlsaW5nIiwiZnJhbWVZaWVsZE1zIiwidXNlckJsb2NraW5nUHJpb3JpdHlUaW1lb3V0Iiwibm9ybWFsUHJpb3JpdHlUaW1lb3V0IiwibG93UHJpb3JpdHlUaW1lb3V0IiwicHVzaCIsImhlYXAiLCJub2RlIiwiaW5kZXgiLCJsZW5ndGgiLCJzaWZ0VXAiLCJwZWVrIiwicG9wIiwiZmlyc3QiLCJsYXN0Iiwic2lmdERvd24iLCJpIiwicGFyZW50SW5kZXgiLCJwYXJlbnQiLCJjb21wYXJlIiwiaGFsZkxlbmd0aCIsImxlZnRJbmRleCIsImxlZnQiLCJyaWdodEluZGV4IiwicmlnaHQiLCJhIiwiYiIsImRpZmYiLCJzb3J0SW5kZXgiLCJpZCIsIkltbWVkaWF0ZVByaW9yaXR5IiwiVXNlckJsb2NraW5nUHJpb3JpdHkiLCJOb3JtYWxQcmlvcml0eSIsIkxvd1ByaW9yaXR5IiwiSWRsZVByaW9yaXR5IiwibWFya1Rhc2tFcnJvcmVkIiwidGFzayIsIm1zIiwiZXhwb3J0cyIsInVuc3RhYmxlX25vdyIsImhhc1BlcmZvcm1hbmNlTm93IiwicGVyZm9ybWFuY2UiLCJub3ciLCJsb2NhbFBlcmZvcm1hbmNlIiwibG9jYWxEYXRlIiwiRGF0ZSIsImluaXRpYWxUaW1lIiwibWF4U2lnbmVkMzFCaXRJbnQiLCJ0YXNrUXVldWUiLCJ0aW1lclF1ZXVlIiwidGFza0lkQ291bnRlciIsImN1cnJlbnRUYXNrIiwiY3VycmVudFByaW9yaXR5TGV2ZWwiLCJpc1BlcmZvcm1pbmdXb3JrIiwiaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQiLCJpc0hvc3RUaW1lb3V0U2NoZWR1bGVkIiwibG9jYWxTZXRUaW1lb3V0Iiwic2V0VGltZW91dCIsImxvY2FsQ2xlYXJUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwibG9jYWxTZXRJbW1lZGlhdGUiLCJzZXRJbW1lZGlhdGUiLCJuYXZpZ2F0b3IiLCJzY2hlZHVsaW5nIiwidW5kZWZpbmVkIiwiaXNJbnB1dFBlbmRpbmciLCJiaW5kIiwiYWR2YW5jZVRpbWVycyIsImN1cnJlbnRUaW1lIiwidGltZXIiLCJjYWxsYmFjayIsInN0YXJ0VGltZSIsImV4cGlyYXRpb25UaW1lIiwiaGFuZGxlVGltZW91dCIsInJlcXVlc3RIb3N0Q2FsbGJhY2siLCJmaXJzdFRpbWVyIiwicmVxdWVzdEhvc3RUaW1lb3V0IiwiZmx1c2hXb3JrIiwiY2FuY2VsSG9zdFRpbWVvdXQiLCJwcmV2aW91c1ByaW9yaXR5TGV2ZWwiLCJ3b3JrTG9vcCIsInNob3VsZFlpZWxkVG9Ib3N0IiwicHJpb3JpdHlMZXZlbCIsImRpZFVzZXJDYWxsYmFja1RpbWVvdXQiLCJjb250aW51YXRpb25DYWxsYmFjayIsInVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSIsImV2ZW50SGFuZGxlciIsInVuc3RhYmxlX25leHQiLCJ1bnN0YWJsZV93cmFwQ2FsbGJhY2siLCJwYXJlbnRQcmlvcml0eUxldmVsIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJ1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrIiwib3B0aW9ucyIsImRlbGF5IiwidGltZW91dCIsIm5ld1Rhc2siLCJ1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbiIsInVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uIiwidW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUiLCJ1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayIsInVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsIiwiaXNNZXNzYWdlTG9vcFJ1bm5pbmciLCJ0YXNrVGltZW91dElEIiwiZnJhbWVJbnRlcnZhbCIsInRpbWVFbGFwc2VkIiwicmVxdWVzdFBhaW50IiwiZm9yY2VGcmFtZVJhdGUiLCJmcHMiLCJjb25zb2xlIiwiTWF0aCIsImZsb29yIiwicGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lIiwiaGFzTW9yZVdvcmsiLCJzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSIsIk1lc3NhZ2VDaGFubmVsIiwiY2hhbm5lbCIsInBvcnQiLCJwb3J0MiIsInBvcnQxIiwib25tZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJ1bnN0YWJsZV9Qcm9maWxpbmciLCJ1bnN0YWJsZV9JZGxlUHJpb3JpdHkiLCJ1bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSIsInVuc3RhYmxlX0xvd1ByaW9yaXR5IiwidW5zdGFibGVfTm9ybWFsUHJpb3JpdHkiLCJ1bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSIsInVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlIiwidW5zdGFibGVfcmVxdWVzdFBhaW50IiwidW5zdGFibGVfc2hvdWxkWWllbGQiLCJyZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/scheduler/cjs/scheduler.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/scheduler/index.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/scheduler/index.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/scheduler/cjs/scheduler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2NoZWR1bGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDBLQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3NjaGVkdWxlci9pbmRleC5qcz84MmU0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/scheduler/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/stacktrace-parser/stack-trace-parser.cjs.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/stacktrace-parser/stack-trace-parser.cjs.js ***!
  \*************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(()=>{\n    \"use strict\";\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var e = {};\n    (()=>{\n        var r = e;\n        Object.defineProperty(r, \"__esModule\", {\n            value: true\n        });\n        var n = \"<unknown>\";\n        function parse(e) {\n            var r = e.split(\"\\n\");\n            return r.reduce(function(e, r) {\n                var n = parseChrome(r) || parseWinjs(r) || parseGecko(r) || parseNode(r) || parseJSC(r);\n                if (n) {\n                    e.push(n);\n                }\n                return e;\n            }, []);\n        }\n        var a = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\/|[a-z]:\\\\|\\\\\\\\).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\n        var l = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n        function parseChrome(e) {\n            var r = a.exec(e);\n            if (!r) {\n                return null;\n            }\n            var u = r[2] && r[2].indexOf(\"native\") === 0;\n            var t = r[2] && r[2].indexOf(\"eval\") === 0;\n            var i = l.exec(r[2]);\n            if (t && i != null) {\n                r[2] = i[1];\n                r[3] = i[2];\n                r[4] = i[3];\n            }\n            return {\n                file: !u ? r[2] : null,\n                methodName: r[1] || n,\n                arguments: u ? [\n                    r[2]\n                ] : [],\n                lineNumber: r[3] ? +r[3] : null,\n                column: r[4] ? +r[4] : null\n            };\n        }\n        var u = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n        function parseWinjs(e) {\n            var r = u.exec(e);\n            if (!r) {\n                return null;\n            }\n            return {\n                file: r[2],\n                methodName: r[1] || n,\n                arguments: [],\n                lineNumber: +r[3],\n                column: r[4] ? +r[4] : null\n            };\n        }\n        var t = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\n        var i = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n        function parseGecko(e) {\n            var r = t.exec(e);\n            if (!r) {\n                return null;\n            }\n            var a = r[3] && r[3].indexOf(\" > eval\") > -1;\n            var l = i.exec(r[3]);\n            if (a && l != null) {\n                r[3] = l[1];\n                r[4] = l[2];\n                r[5] = null;\n            }\n            return {\n                file: r[3],\n                methodName: r[1] || n,\n                arguments: r[2] ? r[2].split(\",\") : [],\n                lineNumber: r[4] ? +r[4] : null,\n                column: r[5] ? +r[5] : null\n            };\n        }\n        var s = /^\\s*(?:([^@]*)(?:\\((.*?)\\))?@)?(\\S.*?):(\\d+)(?::(\\d+))?\\s*$/i;\n        function parseJSC(e) {\n            var r = s.exec(e);\n            if (!r) {\n                return null;\n            }\n            return {\n                file: r[3],\n                methodName: r[1] || n,\n                arguments: [],\n                lineNumber: +r[4],\n                column: r[5] ? +r[5] : null\n            };\n        }\n        var o = /^\\s*at (?:((?:\\[object object\\])?[^\\\\/]+(?: \\[as \\S+\\])?) )?\\(?(.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n        function parseNode(e) {\n            var r = o.exec(e);\n            if (!r) {\n                return null;\n            }\n            return {\n                file: r[2],\n                methodName: r[1] || n,\n                arguments: [],\n                lineNumber: +r[3],\n                column: r[4] ? +r[4] : null\n            };\n        }\n        r.parse = parse;\n    })();\n    module.exports = e;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc3RhY2t0cmFjZS1wYXJzZXIvc3RhY2stdHJhY2UtcGFyc2VyLmNqcy5qcyIsIm1hcHBpbmdzIjoiOztBQUFDO0lBQUs7SUFBYSxJQUFHLE9BQU9BLHdCQUFzQixhQUFZQSxvQkFBb0JDLEVBQUUsR0FBQ0MsU0FBU0EsR0FBQztJQUFJLElBQUlDLElBQUUsQ0FBQztJQUFHO1FBQUssSUFBSUMsSUFBRUQ7UUFBRUUsT0FBT0MsY0FBYyxDQUFDRixHQUFFLGNBQWE7WUFBQ0csT0FBTTtRQUFJO1FBQUcsSUFBSUMsSUFBRTtRQUFZLFNBQVNDLE1BQU1OLENBQUM7WUFBRSxJQUFJQyxJQUFFRCxFQUFFTyxLQUFLLENBQUM7WUFBTSxPQUFPTixFQUFFTyxNQUFNLENBQUUsU0FBU1IsQ0FBQyxFQUFDQyxDQUFDO2dCQUFFLElBQUlJLElBQUVJLFlBQVlSLE1BQUlTLFdBQVdULE1BQUlVLFdBQVdWLE1BQUlXLFVBQVVYLE1BQUlZLFNBQVNaO2dCQUFHLElBQUdJLEdBQUU7b0JBQUNMLEVBQUVjLElBQUksQ0FBQ1Q7Z0JBQUU7Z0JBQUMsT0FBT0w7WUFBQyxHQUFHLEVBQUU7UUFBQztRQUFDLElBQUllLElBQUU7UUFBNEksSUFBSUMsSUFBRTtRQUFnQyxTQUFTUCxZQUFZVCxDQUFDO1lBQUUsSUFBSUMsSUFBRWMsRUFBRUUsSUFBSSxDQUFDakI7WUFBRyxJQUFHLENBQUNDLEdBQUU7Z0JBQUMsT0FBTztZQUFJO1lBQUMsSUFBSWlCLElBQUVqQixDQUFDLENBQUMsRUFBRSxJQUFFQSxDQUFDLENBQUMsRUFBRSxDQUFDa0IsT0FBTyxDQUFDLGNBQVk7WUFBRSxJQUFJQyxJQUFFbkIsQ0FBQyxDQUFDLEVBQUUsSUFBRUEsQ0FBQyxDQUFDLEVBQUUsQ0FBQ2tCLE9BQU8sQ0FBQyxZQUFVO1lBQUUsSUFBSUUsSUFBRUwsRUFBRUMsSUFBSSxDQUFDaEIsQ0FBQyxDQUFDLEVBQUU7WUFB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O1lBQUUsSUFBSUMsSUFBRTJCLEVBQUVYLElBQUksQ0FBQ2pCO1lBQUcsSUFBRyxDQUFDQyxHQUFFO2dCQUFDLE9BQU87WUFBSTtZQUFDLE9BQU07Z0JBQUNxQixNQUFLckIsQ0FBQyxDQUFDLEVBQUU7Z0JBQUNzQixZQUFXdEIsQ0FBQyxDQUFDLEVBQUUsSUFBRUk7Z0JBQUVtQixXQUFVLEVBQUU7Z0JBQUNDLFlBQVcsQ0FBQ3hCLENBQUMsQ0FBQyxFQUFFO2dCQUFDeUIsUUFBT3pCLENBQUMsQ0FBQyxFQUFFLEdBQUMsQ0FBQ0EsQ0FBQyxDQUFDLEVBQUUsR0FBQztZQUFJO1FBQUM7UUFBQ0EsRUFBRUssS0FBSyxHQUFDQTtJQUFLO0lBQUt1QixPQUFPQyxPQUFPLEdBQUM5QjtBQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc3RhY2t0cmFjZS1wYXJzZXIvc3RhY2stdHJhY2UtcGFyc2VyLmNqcy5qcz9mZTBlIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO2lmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgZT17fTsoKCk9Pnt2YXIgcj1lO09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dmFyIG49XCI8dW5rbm93bj5cIjtmdW5jdGlvbiBwYXJzZShlKXt2YXIgcj1lLnNwbGl0KFwiXFxuXCIpO3JldHVybiByLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXt2YXIgbj1wYXJzZUNocm9tZShyKXx8cGFyc2VXaW5qcyhyKXx8cGFyc2VHZWNrbyhyKXx8cGFyc2VOb2RlKHIpfHxwYXJzZUpTQyhyKTtpZihuKXtlLnB1c2gobil9cmV0dXJuIGV9KSxbXSl9dmFyIGE9L15cXHMqYXQgKC4qPykgP1xcKCgoPzpmaWxlfGh0dHBzP3xibG9ifGNocm9tZS1leHRlbnNpb258bmF0aXZlfGV2YWx8d2VicGFja3w8YW5vbnltb3VzPnxcXC98W2Etel06XFxcXHxcXFxcXFxcXCkuKj8pKD86OihcXGQrKSk/KD86OihcXGQrKSk/XFwpP1xccyokL2k7dmFyIGw9L1xcKChcXFMqKSg/OjooXFxkKykpKD86OihcXGQrKSlcXCkvO2Z1bmN0aW9uIHBhcnNlQ2hyb21lKGUpe3ZhciByPWEuZXhlYyhlKTtpZighcil7cmV0dXJuIG51bGx9dmFyIHU9clsyXSYmclsyXS5pbmRleE9mKFwibmF0aXZlXCIpPT09MDt2YXIgdD1yWzJdJiZyWzJdLmluZGV4T2YoXCJldmFsXCIpPT09MDt2YXIgaT1sLmV4ZWMoclsyXSk7aWYodCYmaSE9bnVsbCl7clsyXT1pWzFdO3JbM109aVsyXTtyWzRdPWlbM119cmV0dXJue2ZpbGU6IXU/clsyXTpudWxsLG1ldGhvZE5hbWU6clsxXXx8bixhcmd1bWVudHM6dT9bclsyXV06W10sbGluZU51bWJlcjpyWzNdPytyWzNdOm51bGwsY29sdW1uOnJbNF0/K3JbNF06bnVsbH19dmFyIHU9L15cXHMqYXQgKD86KCg/OlxcW29iamVjdCBvYmplY3RcXF0pPy4rKSApP1xcKD8oKD86ZmlsZXxtcy1hcHB4fGh0dHBzP3x3ZWJwYWNrfGJsb2IpOi4qPyk6KFxcZCspKD86OihcXGQrKSk/XFwpP1xccyokL2k7ZnVuY3Rpb24gcGFyc2VXaW5qcyhlKXt2YXIgcj11LmV4ZWMoZSk7aWYoIXIpe3JldHVybiBudWxsfXJldHVybntmaWxlOnJbMl0sbWV0aG9kTmFtZTpyWzFdfHxuLGFyZ3VtZW50czpbXSxsaW5lTnVtYmVyOityWzNdLGNvbHVtbjpyWzRdPytyWzRdOm51bGx9fXZhciB0PS9eXFxzKiguKj8pKD86XFwoKC4qPylcXCkpPyg/Ol58QCkoKD86ZmlsZXxodHRwcz98YmxvYnxjaHJvbWV8d2VicGFja3xyZXNvdXJjZXxcXFtuYXRpdmUpLio/fFteQF0qYnVuZGxlKSg/OjooXFxkKykpPyg/OjooXFxkKykpP1xccyokL2k7dmFyIGk9LyhcXFMrKSBsaW5lIChcXGQrKSg/OiA+IGV2YWwgbGluZSBcXGQrKSogPiBldmFsL2k7ZnVuY3Rpb24gcGFyc2VHZWNrbyhlKXt2YXIgcj10LmV4ZWMoZSk7aWYoIXIpe3JldHVybiBudWxsfXZhciBhPXJbM10mJnJbM10uaW5kZXhPZihcIiA+IGV2YWxcIik+LTE7dmFyIGw9aS5leGVjKHJbM10pO2lmKGEmJmwhPW51bGwpe3JbM109bFsxXTtyWzRdPWxbMl07cls1XT1udWxsfXJldHVybntmaWxlOnJbM10sbWV0aG9kTmFtZTpyWzFdfHxuLGFyZ3VtZW50czpyWzJdP3JbMl0uc3BsaXQoXCIsXCIpOltdLGxpbmVOdW1iZXI6cls0XT8rcls0XTpudWxsLGNvbHVtbjpyWzVdPytyWzVdOm51bGx9fXZhciBzPS9eXFxzKig/OihbXkBdKikoPzpcXCgoLio/KVxcKSk/QCk/KFxcUy4qPyk6KFxcZCspKD86OihcXGQrKSk/XFxzKiQvaTtmdW5jdGlvbiBwYXJzZUpTQyhlKXt2YXIgcj1zLmV4ZWMoZSk7aWYoIXIpe3JldHVybiBudWxsfXJldHVybntmaWxlOnJbM10sbWV0aG9kTmFtZTpyWzFdfHxuLGFyZ3VtZW50czpbXSxsaW5lTnVtYmVyOityWzRdLGNvbHVtbjpyWzVdPytyWzVdOm51bGx9fXZhciBvPS9eXFxzKmF0ICg/OigoPzpcXFtvYmplY3Qgb2JqZWN0XFxdKT9bXlxcXFwvXSsoPzogXFxbYXMgXFxTK1xcXSk/KSApP1xcKD8oLio/KTooXFxkKykoPzo6KFxcZCspKT9cXCk/XFxzKiQvaTtmdW5jdGlvbiBwYXJzZU5vZGUoZSl7dmFyIHI9by5leGVjKGUpO2lmKCFyKXtyZXR1cm4gbnVsbH1yZXR1cm57ZmlsZTpyWzJdLG1ldGhvZE5hbWU6clsxXXx8bixhcmd1bWVudHM6W10sbGluZU51bWJlcjorclszXSxjb2x1bW46cls0XT8rcls0XTpudWxsfX1yLnBhcnNlPXBhcnNlfSkoKTttb2R1bGUuZXhwb3J0cz1lfSkoKTsiXSwibmFtZXMiOlsiX19uY2N3cGNrX3JlcXVpcmVfXyIsImFiIiwiX19kaXJuYW1lIiwiZSIsInIiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwibiIsInBhcnNlIiwic3BsaXQiLCJyZWR1Y2UiLCJwYXJzZUNocm9tZSIsInBhcnNlV2luanMiLCJwYXJzZUdlY2tvIiwicGFyc2VOb2RlIiwicGFyc2VKU0MiLCJwdXNoIiwiYSIsImwiLCJleGVjIiwidSIsImluZGV4T2YiLCJ0IiwiaSIsImZpbGUiLCJtZXRob2ROYW1lIiwiYXJndW1lbnRzIiwibGluZU51bWJlciIsImNvbHVtbiIsInMiLCJvIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/stacktrace-parser/stack-trace-parser.cjs.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/strip-ansi/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/strip-ansi/index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(()=>{\n    \"use strict\";\n    var e = {\n        511: (e)=>{\n            e.exports = function() {\n                let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n                const r = [\n                    \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n                    \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\"\n                ].join(\"|\");\n                return new RegExp(r, e ? undefined : \"g\");\n            };\n        },\n        532: (e, r, _)=>{\n            const t = _(511);\n            e.exports = (e)=>typeof e === \"string\" ? e.replace(t(), \"\") : e;\n        }\n    };\n    var r = {};\n    function __nccwpck_require__(_) {\n        var t = r[_];\n        if (t !== undefined) {\n            return t.exports;\n        }\n        var a = r[_] = {\n            exports: {}\n        };\n        var n = true;\n        try {\n            e[_](a, a.exports, __nccwpck_require__);\n            n = false;\n        } finally{\n            if (n) delete r[_];\n        }\n        return a.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var _ = __nccwpck_require__(532);\n    module.exports = _;\n})();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc3RyaXAtYW5zaS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOztBQUFDO0lBQUs7SUFBYSxJQUFJQSxJQUFFO1FBQUMsS0FBSUEsQ0FBQUE7WUFBSUEsRUFBRUMsT0FBTyxHQUFDO29CQUFDLEVBQUNDLFdBQVVGLElBQUUsS0FBSyxFQUFDLG9FQUFDLENBQUM7Z0JBQUssTUFBTUcsSUFBRTtvQkFBQztvQkFBK0g7aUJBQTJELENBQUNDLElBQUksQ0FBQztnQkFBSyxPQUFPLElBQUlDLE9BQU9GLEdBQUVILElBQUVNLFlBQVU7WUFBSTtRQUFDO1FBQUUsS0FBSSxDQUFDTixHQUFFRyxHQUFFSTtZQUFLLE1BQU1DLElBQUVELEVBQUU7WUFBS1AsRUFBRUMsT0FBTyxHQUFDRCxDQUFBQSxJQUFHLE9BQU9BLE1BQUksV0FBU0EsRUFBRVMsT0FBTyxDQUFDRCxLQUFJLE1BQUlSO1FBQUM7SUFBQztJQUFFLElBQUlHLElBQUUsQ0FBQztJQUFFLFNBQVNPLG9CQUFvQkgsQ0FBQztRQUFFLElBQUlDLElBQUVMLENBQUMsQ0FBQ0ksRUFBRTtRQUFDLElBQUdDLE1BQUlGLFdBQVU7WUFBQyxPQUFPRSxFQUFFUCxPQUFPO1FBQUE7UUFBQyxJQUFJVSxJQUFFUixDQUFDLENBQUNJLEVBQUUsR0FBQztZQUFDTixTQUFRLENBQUM7UUFBQztRQUFFLElBQUlXLElBQUU7UUFBSyxJQUFHO1lBQUNaLENBQUMsQ0FBQ08sRUFBRSxDQUFDSSxHQUFFQSxFQUFFVixPQUFPLEVBQUNTO1lBQXFCRSxJQUFFO1FBQUssU0FBUTtZQUFDLElBQUdBLEdBQUUsT0FBT1QsQ0FBQyxDQUFDSSxFQUFFO1FBQUE7UUFBQyxPQUFPSSxFQUFFVixPQUFPO0lBQUE7SUFBQyxJQUFHLE9BQU9TLHdCQUFzQixhQUFZQSxvQkFBb0JHLEVBQUUsR0FBQ0MsU0FBU0EsR0FBQztJQUFJLElBQUlQLElBQUVHLG9CQUFvQjtJQUFLSyxPQUFPZCxPQUFPLEdBQUNNO0FBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zdHJpcC1hbnNpL2luZGV4LmpzPzExZmEiXSwic291cmNlc0NvbnRlbnQiOlsiKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ezUxMTplPT57ZS5leHBvcnRzPSh7b25seUZpcnN0OmU9ZmFsc2V9PXt9KT0+e2NvbnN0IHI9W1wiW1xcXFx1MDAxQlxcXFx1MDA5Ql1bW1xcXFxdKCkjOz9dKig/Oig/Oig/Oig/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSspKnxbYS16QS1aXFxcXGRdKyg/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSopKik/XFxcXHUwMDA3KVwiLFwiKD86KD86XFxcXGR7MSw0fSg/OjtcXFxcZHswLDR9KSopP1tcXFxcZEEtUFItVFpjZi1udHFyeT0+PH5dKSlcIl0uam9pbihcInxcIik7cmV0dXJuIG5ldyBSZWdFeHAocixlP3VuZGVmaW5lZDpcImdcIil9fSw1MzI6KGUscixfKT0+e2NvbnN0IHQ9Xyg1MTEpO2UuZXhwb3J0cz1lPT50eXBlb2YgZT09PVwic3RyaW5nXCI/ZS5yZXBsYWNlKHQoKSxcIlwiKTplfX07dmFyIHI9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhfKXt2YXIgdD1yW19dO2lmKHQhPT11bmRlZmluZWQpe3JldHVybiB0LmV4cG9ydHN9dmFyIGE9cltfXT17ZXhwb3J0czp7fX07dmFyIG49dHJ1ZTt0cnl7ZVtfXShhLGEuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtuPWZhbHNlfWZpbmFsbHl7aWYobilkZWxldGUgcltfXX1yZXR1cm4gYS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgXz1fX25jY3dwY2tfcmVxdWlyZV9fKDUzMik7bW9kdWxlLmV4cG9ydHM9X30pKCk7Il0sIm5hbWVzIjpbImUiLCJleHBvcnRzIiwib25seUZpcnN0IiwiciIsImpvaW4iLCJSZWdFeHAiLCJ1bmRlZmluZWQiLCJfIiwidCIsInJlcGxhY2UiLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwiYSIsIm4iLCJhYiIsIl9fZGlybmFtZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/strip-ansi/index.js\n"));

/***/ })

}]);