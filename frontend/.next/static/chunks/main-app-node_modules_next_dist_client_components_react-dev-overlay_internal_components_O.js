"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["main-app-node_modules_next_dist_client_components_react-dev-overlay_internal_components_O"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/Overlay.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/Overlay.js ***!
  \***********************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// @ts-ignore\n\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Overlay\", ({\n    enumerable: true,\n    get: function() {\n        return Overlay;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _maintaintabfocus = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./maintain--tab-focus */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/maintain--tab-focus.js\"));\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _bodylocker = __webpack_require__(/*! ./body-locker */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/body-locker.js\");\nconst Overlay = function Overlay(param) {\n    _s();\n    let { className, children, fixed } = param;\n    _react.useEffect(()=>{\n        (0, _bodylocker.lock)();\n        return ()=>{\n            (0, _bodylocker.unlock)();\n        };\n    }, []);\n    const [overlay, setOverlay] = _react.useState(null);\n    const onOverlay = _react.useCallback((el)=>{\n        setOverlay(el);\n    }, []);\n    _react.useEffect(()=>{\n        if (overlay == null) {\n            return;\n        }\n        const handle2 = (0, _maintaintabfocus.default)({\n            context: overlay\n        });\n        return ()=>{\n            handle2.disengage();\n        };\n    }, [\n        overlay\n    ]);\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"div\", {\n        \"data-nextjs-dialog-overlay\": true,\n        className: className,\n        ref: onOverlay,\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(\"div\", {\n                \"data-nextjs-dialog-backdrop\": true,\n                \"data-nextjs-dialog-backdrop-fixed\": fixed ? true : undefined\n            }),\n            children\n        ]\n    });\n};\n_s(Overlay, \"7AKWSbA/gHapd2YTyFggUak94M8=\");\n_c = Overlay;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=Overlay.js.map\nvar _c;\n$RefreshReg$(_c, \"Overlay\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9PdmVybGF5L092ZXJsYXkuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYTs7O0FBQ2I7QUFDQUEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDJDQUEwQztJQUN0Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsZ0lBQXlDO0FBQ2xGLE1BQU1DLDRCQUE0QkQsbUJBQU9BLENBQUMsa0lBQTBDO0FBQ3BGLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLHFHQUFtQjtBQUMvQyxNQUFNRyxvQkFBb0IsV0FBVyxHQUFHSix5QkFBeUJLLENBQUMsQ0FBQ0osbUJBQU9BLENBQUMsa0tBQXVCO0FBQ2xHLE1BQU1LLFNBQVMsV0FBVyxHQUFHSiwwQkFBMEJHLENBQUMsQ0FBQ0osbUJBQU9BLENBQUMsbUZBQU87QUFDeEUsTUFBTU0sY0FBY04sbUJBQU9BLENBQUMsa0pBQWU7QUFDM0MsTUFBTUYsVUFBVSxTQUFTQSxRQUFRUyxLQUFLOztJQUNsQyxJQUFJLEVBQUVDLFNBQVMsRUFBRUMsUUFBUSxFQUFFQyxLQUFLLEVBQUUsR0FBR0g7SUFDckNGLE9BQU9NLFNBQVMsQ0FBQztRQUNaLElBQUdMLFlBQVlNLElBQUk7UUFDcEIsT0FBTztZQUNGLElBQUdOLFlBQVlPLE1BQU07UUFDMUI7SUFDSixHQUFHLEVBQUU7SUFDTCxNQUFNLENBQUNDLFNBQVNDLFdBQVcsR0FBR1YsT0FBT1csUUFBUSxDQUFDO0lBQzlDLE1BQU1DLFlBQVlaLE9BQU9hLFdBQVcsQ0FBQyxDQUFDQztRQUNsQ0osV0FBV0k7SUFDZixHQUFHLEVBQUU7SUFDTGQsT0FBT00sU0FBUyxDQUFDO1FBQ2IsSUFBSUcsV0FBVyxNQUFNO1lBQ2pCO1FBQ0o7UUFDQSxNQUFNTSxVQUFVLENBQUMsR0FBR2pCLGtCQUFrQmtCLE9BQU8sRUFBRTtZQUMzQ0MsU0FBU1I7UUFDYjtRQUNBLE9BQU87WUFDSE0sUUFBUUcsU0FBUztRQUNyQjtJQUNKLEdBQUc7UUFDQ1Q7S0FDSDtJQUNELE9BQXFCLFdBQUgsR0FBSSxJQUFHWixZQUFZc0IsSUFBSSxFQUFFLE9BQU87UUFDOUMsOEJBQThCO1FBQzlCaEIsV0FBV0E7UUFDWGlCLEtBQUtSO1FBQ0xSLFVBQVU7WUFDTixXQUFXLEdBQUksSUFBR1AsWUFBWXdCLEdBQUcsRUFBRSxPQUFPO2dCQUN0QywrQkFBK0I7Z0JBQy9CLHFDQUFxQ2hCLFFBQVEsT0FBT2lCO1lBQ3hEO1lBQ0FsQjtTQUNIO0lBQ0w7QUFDSjtHQXJDTVg7S0FBQUE7QUF1Q04sSUFBSSxDQUFDLE9BQU9KLFFBQVEyQixPQUFPLEtBQUssY0FBZSxPQUFPM0IsUUFBUTJCLE9BQU8sS0FBSyxZQUFZM0IsUUFBUTJCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTzNCLFFBQVEyQixPQUFPLENBQUNPLFVBQVUsS0FBSyxhQUFhO0lBQ3JLcEMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRMkIsT0FBTyxFQUFFLGNBQWM7UUFBRTFCLE9BQU87SUFBSztJQUNuRUgsT0FBT3FDLE1BQU0sQ0FBQ25DLFFBQVEyQixPQUFPLEVBQUUzQjtJQUMvQm9DLE9BQU9wQyxPQUFPLEdBQUdBLFFBQVEyQixPQUFPO0FBQ2xDLEVBRUEsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9PdmVybGF5L092ZXJsYXkuanM/YWMyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdHMtaWdub3JlXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk92ZXJsYXlcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE92ZXJsYXk7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX2pzeHJ1bnRpbWUgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5jb25zdCBfbWFpbnRhaW50YWJmb2N1cyA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4vbWFpbnRhaW4tLXRhYi1mb2N1c1wiKSk7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX2JvZHlsb2NrZXIgPSByZXF1aXJlKFwiLi9ib2R5LWxvY2tlclwiKTtcbmNvbnN0IE92ZXJsYXkgPSBmdW5jdGlvbiBPdmVybGF5KHBhcmFtKSB7XG4gICAgbGV0IHsgY2xhc3NOYW1lLCBjaGlsZHJlbiwgZml4ZWQgfSA9IHBhcmFtO1xuICAgIF9yZWFjdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgKDAsIF9ib2R5bG9ja2VyLmxvY2spKCk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgKDAsIF9ib2R5bG9ja2VyLnVubG9jaykoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgW292ZXJsYXksIHNldE92ZXJsYXldID0gX3JlYWN0LnVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IG9uT3ZlcmxheSA9IF9yZWFjdC51c2VDYWxsYmFjaygoZWwpPT57XG4gICAgICAgIHNldE92ZXJsYXkoZWwpO1xuICAgIH0sIFtdKTtcbiAgICBfcmVhY3QudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChvdmVybGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYW5kbGUyID0gKDAsIF9tYWludGFpbnRhYmZvY3VzLmRlZmF1bHQpKHtcbiAgICAgICAgICAgIGNvbnRleHQ6IG92ZXJsYXlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgaGFuZGxlMi5kaXNlbmdhZ2UoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIG92ZXJsYXlcbiAgICBdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4cykoXCJkaXZcIiwge1xuICAgICAgICBcImRhdGEtbmV4dGpzLWRpYWxvZy1vdmVybGF5XCI6IHRydWUsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICByZWY6IG9uT3ZlcmxheSxcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJkaXZcIiwge1xuICAgICAgICAgICAgICAgIFwiZGF0YS1uZXh0anMtZGlhbG9nLWJhY2tkcm9wXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3AtZml4ZWRcIjogZml4ZWQgPyB0cnVlIDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgIF1cbiAgICB9KTtcbn07XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU92ZXJsYXkuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIk92ZXJsYXkiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9qc3hydW50aW1lIiwiX21haW50YWludGFiZm9jdXMiLCJfIiwiX3JlYWN0IiwiX2JvZHlsb2NrZXIiLCJwYXJhbSIsImNsYXNzTmFtZSIsImNoaWxkcmVuIiwiZml4ZWQiLCJ1c2VFZmZlY3QiLCJsb2NrIiwidW5sb2NrIiwib3ZlcmxheSIsInNldE92ZXJsYXkiLCJ1c2VTdGF0ZSIsIm9uT3ZlcmxheSIsInVzZUNhbGxiYWNrIiwiZWwiLCJoYW5kbGUyIiwiZGVmYXVsdCIsImNvbnRleHQiLCJkaXNlbmdhZ2UiLCJqc3hzIiwicmVmIiwianN4IiwidW5kZWZpbmVkIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/Overlay.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/body-locker.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/body-locker.js ***!
  \***************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    lock: function() {\n        return lock;\n    },\n    unlock: function() {\n        return unlock;\n    }\n});\nlet previousBodyPaddingRight;\nlet previousBodyOverflowSetting;\nlet activeLocks = 0;\nfunction lock() {\n    setTimeout(()=>{\n        if (activeLocks++ > 0) {\n            return;\n        }\n        const scrollBarGap = window.innerWidth - document.documentElement.clientWidth;\n        if (scrollBarGap > 0) {\n            previousBodyPaddingRight = document.body.style.paddingRight;\n            document.body.style.paddingRight = \"\" + scrollBarGap + \"px\";\n        }\n        previousBodyOverflowSetting = document.body.style.overflow;\n        document.body.style.overflow = \"hidden\";\n    });\n}\nfunction unlock() {\n    setTimeout(()=>{\n        if (activeLocks === 0 || --activeLocks !== 0) {\n            return;\n        }\n        if (previousBodyPaddingRight !== undefined) {\n            document.body.style.paddingRight = previousBodyPaddingRight;\n            previousBodyPaddingRight = undefined;\n        }\n        if (previousBodyOverflowSetting !== undefined) {\n            document.body.style.overflow = previousBodyOverflowSetting;\n            previousBodyOverflowSetting = undefined;\n        }\n    });\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=body-locker.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9PdmVybGF5L2JvZHktbG9ja2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBR047QUFDQSxTQUFTRyxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJVCxPQUFPQyxjQUFjLENBQUNPLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFLO0lBQ2xCO0FBQ0o7QUFDQUgsUUFBUUwsU0FBUztJQUNiRyxNQUFNO1FBQ0YsT0FBT0E7SUFDWDtJQUNBQyxRQUFRO1FBQ0osT0FBT0E7SUFDWDtBQUNKO0FBQ0EsSUFBSU87QUFDSixJQUFJQztBQUNKLElBQUlDLGNBQWM7QUFDbEIsU0FBU1Y7SUFDTFcsV0FBVztRQUNQLElBQUlELGdCQUFnQixHQUFHO1lBQ25CO1FBQ0o7UUFDQSxNQUFNRSxlQUFlQyxPQUFPQyxVQUFVLEdBQUdDLFNBQVNDLGVBQWUsQ0FBQ0MsV0FBVztRQUM3RSxJQUFJTCxlQUFlLEdBQUc7WUFDbEJKLDJCQUEyQk8sU0FBU0csSUFBSSxDQUFDQyxLQUFLLENBQUNDLFlBQVk7WUFDM0RMLFNBQVNHLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxZQUFZLEdBQUcsS0FBS1IsZUFBZTtRQUMzRDtRQUNBSCw4QkFBOEJNLFNBQVNHLElBQUksQ0FBQ0MsS0FBSyxDQUFDRSxRQUFRO1FBQzFETixTQUFTRyxJQUFJLENBQUNDLEtBQUssQ0FBQ0UsUUFBUSxHQUFHO0lBQ25DO0FBQ0o7QUFDQSxTQUFTcEI7SUFDTFUsV0FBVztRQUNQLElBQUlELGdCQUFnQixLQUFLLEVBQUVBLGdCQUFnQixHQUFHO1lBQzFDO1FBQ0o7UUFDQSxJQUFJRiw2QkFBNkJjLFdBQVc7WUFDeENQLFNBQVNHLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxZQUFZLEdBQUdaO1lBQ25DQSwyQkFBMkJjO1FBQy9CO1FBQ0EsSUFBSWIsZ0NBQWdDYSxXQUFXO1lBQzNDUCxTQUFTRyxJQUFJLENBQUNDLEtBQUssQ0FBQ0UsUUFBUSxHQUFHWjtZQUMvQkEsOEJBQThCYTtRQUNsQztJQUNKO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT3pCLFFBQVEwQixPQUFPLEtBQUssY0FBZSxPQUFPMUIsUUFBUTBCLE9BQU8sS0FBSyxZQUFZMUIsUUFBUTBCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTzFCLFFBQVEwQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLN0IsT0FBT0MsY0FBYyxDQUFDQyxRQUFRMEIsT0FBTyxFQUFFLGNBQWM7UUFBRXpCLE9BQU87SUFBSztJQUNuRUgsT0FBTzhCLE1BQU0sQ0FBQzVCLFFBQVEwQixPQUFPLEVBQUUxQjtJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFRMEIsT0FBTztBQUNsQyxFQUVBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvT3ZlcmxheS9ib2R5LWxvY2tlci5qcz84ZDFkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbG9jazogbnVsbCxcbiAgICB1bmxvY2s6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgbG9jazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBsb2NrO1xuICAgIH0sXG4gICAgdW5sb2NrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVubG9jaztcbiAgICB9XG59KTtcbmxldCBwcmV2aW91c0JvZHlQYWRkaW5nUmlnaHQ7XG5sZXQgcHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nO1xubGV0IGFjdGl2ZUxvY2tzID0gMDtcbmZ1bmN0aW9uIGxvY2soKSB7XG4gICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICBpZiAoYWN0aXZlTG9ja3MrKyA+IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3JvbGxCYXJHYXAgPSB3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgaWYgKHNjcm9sbEJhckdhcCA+IDApIHtcbiAgICAgICAgICAgIHByZXZpb3VzQm9keVBhZGRpbmdSaWdodCA9IGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0O1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcIlwiICsgc2Nyb2xsQmFyR2FwICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzQm9keU92ZXJmbG93U2V0dGluZyA9IGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3c7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdW5sb2NrKCkge1xuICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgaWYgKGFjdGl2ZUxvY2tzID09PSAwIHx8IC0tYWN0aXZlTG9ja3MgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmlvdXNCb2R5UGFkZGluZ1JpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gcHJldmlvdXNCb2R5UGFkZGluZ1JpZ2h0O1xuICAgICAgICAgICAgcHJldmlvdXNCb2R5UGFkZGluZ1JpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2aW91c0JvZHlPdmVyZmxvd1NldHRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IHByZXZpb3VzQm9keU92ZXJmbG93U2V0dGluZztcbiAgICAgICAgICAgIHByZXZpb3VzQm9keU92ZXJmbG93U2V0dGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib2R5LWxvY2tlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJsb2NrIiwidW5sb2NrIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwicHJldmlvdXNCb2R5UGFkZGluZ1JpZ2h0IiwicHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nIiwiYWN0aXZlTG9ja3MiLCJzZXRUaW1lb3V0Iiwic2Nyb2xsQmFyR2FwIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50V2lkdGgiLCJib2R5Iiwic3R5bGUiLCJwYWRkaW5nUmlnaHQiLCJvdmVyZmxvdyIsInVuZGVmaW5lZCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/body-locker.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/index.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/index.js ***!
  \*********************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Overlay\", ({\n    enumerable: true,\n    get: function() {\n        return _Overlay.Overlay;\n    }\n}));\nconst _Overlay = __webpack_require__(/*! ./Overlay */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/Overlay.js\");\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9PdmVybGF5L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwyQ0FBMEM7SUFDdENJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DLFNBQVNDLE9BQU87SUFDM0I7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNRCxXQUFXRSxtQkFBT0EsQ0FBQywwSUFBVztBQUVwQyxJQUFJLENBQUMsT0FBT04sUUFBUU8sT0FBTyxLQUFLLGNBQWUsT0FBT1AsUUFBUU8sT0FBTyxLQUFLLFlBQVlQLFFBQVFPLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1AsUUFBUU8sT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS1YsT0FBT0MsY0FBYyxDQUFDQyxRQUFRTyxPQUFPLEVBQUUsY0FBYztRQUFFTixPQUFPO0lBQUs7SUFDbkVILE9BQU9XLE1BQU0sQ0FBQ1QsUUFBUU8sT0FBTyxFQUFFUDtJQUMvQlUsT0FBT1YsT0FBTyxHQUFHQSxRQUFRTyxPQUFPO0FBQ2xDLEVBRUEsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9PdmVybGF5L2luZGV4LmpzP2E4OGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPdmVybGF5XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfT3ZlcmxheS5PdmVybGF5O1xuICAgIH1cbn0pO1xuY29uc3QgX092ZXJsYXkgPSByZXF1aXJlKFwiLi9PdmVybGF5XCIpO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX092ZXJsYXkiLCJPdmVybGF5IiwicmVxdWlyZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/maintain--tab-focus.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/maintain--tab-focus.js ***!
  \***********************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* eslint-disable */ // @ts-nocheck\n// Copied from https://github.com/medialize/ally.js\n// License: MIT\n// Copyright (c) 2015 Rodney Rehm\n//\n// Entrypoint: ally.js/maintain/tab-focus\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _platform = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/compiled/platform */ \"(app-pages-browser)/./node_modules/next/dist/compiled/platform/platform.js\"));\nconst _cssescape = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/compiled/css.escape */ \"(app-pages-browser)/./node_modules/next/dist/compiled/css.escape/css.escape.js\"));\n// input may be undefined, selector-tring, Node, NodeList, HTMLCollection, array of Nodes\n// yes, to some extent this is a bad replica of jQuery's constructor function\nfunction nodeArray(input) {\n    if (!input) {\n        return [];\n    }\n    if (Array.isArray(input)) {\n        return input;\n    }\n    // instanceof Node - does not work with iframes\n    if (input.nodeType !== undefined) {\n        return [\n            input\n        ];\n    }\n    if (typeof input === \"string\") {\n        input = document.querySelectorAll(input);\n    }\n    if (input.length !== undefined) {\n        return [].slice.call(input, 0);\n    }\n    throw new TypeError(\"unexpected input \" + String(input));\n}\nfunction contextToElement(_ref) {\n    var context = _ref.context, _ref$label = _ref.label, label = _ref$label === undefined ? \"context-to-element\" : _ref$label, resolveDocument = _ref.resolveDocument, defaultToDocument = _ref.defaultToDocument;\n    var element = nodeArray(context)[0];\n    if (resolveDocument && element && element.nodeType === Node.DOCUMENT_NODE) {\n        element = element.documentElement;\n    }\n    if (!element && defaultToDocument) {\n        return document.documentElement;\n    }\n    if (!element) {\n        throw new TypeError(label + \" requires valid options.context\");\n    }\n    if (element.nodeType !== Node.ELEMENT_NODE && element.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n        throw new TypeError(label + \" requires options.context to be an Element\");\n    }\n    return element;\n}\nfunction getShadowHost() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context;\n    var element = contextToElement({\n        label: \"get/shadow-host\",\n        context: context\n    });\n    // walk up to the root\n    var container = null;\n    while(element){\n        container = element;\n        element = element.parentNode;\n    }\n    // https://developer.mozilla.org/docs/Web/API/Node.nodeType\n    // NOTE: Firefox 34 does not expose ShadowRoot.host (but 37 does)\n    if (container.nodeType === container.DOCUMENT_FRAGMENT_NODE && container.host) {\n        // the root is attached to a fragment node that has a host\n        return container.host;\n    }\n    return null;\n}\nfunction getDocument(node) {\n    if (!node) {\n        return document;\n    }\n    if (node.nodeType === Node.DOCUMENT_NODE) {\n        return node;\n    }\n    return node.ownerDocument || document;\n}\nfunction isActiveElement(context) {\n    var element = contextToElement({\n        label: \"is/active-element\",\n        resolveDocument: true,\n        context: context\n    });\n    var _document = getDocument(element);\n    if (_document.activeElement === element) {\n        return true;\n    }\n    var shadowHost = getShadowHost({\n        context: element\n    });\n    if (shadowHost && shadowHost.shadowRoot.activeElement === element) {\n        return true;\n    }\n    return false;\n}\n// [elem, elem.parent, elem.parent.parent, â€¦, html]\n// will not contain the shadowRoot (DOCUMENT_FRAGMENT_NODE) and shadowHost\nfunction getParents() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context;\n    var list = [];\n    var element = contextToElement({\n        label: \"get/parents\",\n        context: context\n    });\n    while(element){\n        list.push(element);\n        // IE does know support parentElement on SVGElement\n        element = element.parentNode;\n        if (element && element.nodeType !== Node.ELEMENT_NODE) {\n            element = null;\n        }\n    }\n    return list;\n}\n// Element.prototype.matches may be available at a different name\n// https://developer.mozilla.org/en/docs/Web/API/Element/matches\nvar names = [\n    \"matches\",\n    \"webkitMatchesSelector\",\n    \"mozMatchesSelector\",\n    \"msMatchesSelector\"\n];\nvar name = null;\nfunction findMethodName(element) {\n    names.some(function(_name) {\n        if (!element[_name]) {\n            return false;\n        }\n        name = _name;\n        return true;\n    });\n}\nfunction elementMatches(element, selector) {\n    if (!name) {\n        findMethodName(element);\n    }\n    return element[name](selector);\n}\n// deep clone of original platform\nvar platform = JSON.parse(JSON.stringify(_platform.default));\n// operating system\nvar os = platform.os.family || \"\";\nvar ANDROID = os === \"Android\";\nvar WINDOWS = os.slice(0, 7) === \"Windows\";\nvar OSX = os === \"OS X\";\nvar IOS = os === \"iOS\";\n// layout\nvar BLINK = platform.layout === \"Blink\";\nvar GECKO = platform.layout === \"Gecko\";\nvar TRIDENT = platform.layout === \"Trident\";\nvar EDGE = platform.layout === \"EdgeHTML\";\nvar WEBKIT = platform.layout === \"WebKit\";\n// browser version (not layout engine version!)\nvar version = parseFloat(platform.version);\nvar majorVersion = Math.floor(version);\nplatform.majorVersion = majorVersion;\nplatform.is = {\n    // operating system\n    ANDROID: ANDROID,\n    WINDOWS: WINDOWS,\n    OSX: OSX,\n    IOS: IOS,\n    // layout\n    BLINK: BLINK,\n    GECKO: GECKO,\n    TRIDENT: TRIDENT,\n    EDGE: EDGE,\n    WEBKIT: WEBKIT,\n    // INTERNET EXPLORERS\n    IE9: TRIDENT && majorVersion === 9,\n    IE10: TRIDENT && majorVersion === 10,\n    IE11: TRIDENT && majorVersion === 11\n};\nfunction before() {\n    var data = {\n        // remember what had focus to restore after test\n        activeElement: document.activeElement,\n        // remember scroll positions to restore after test\n        windowScrollTop: window.scrollTop,\n        windowScrollLeft: window.scrollLeft,\n        bodyScrollTop: document.body.scrollTop,\n        bodyScrollLeft: document.body.scrollLeft\n    };\n    // wrap tests in an element hidden from screen readers to prevent them\n    // from announcing focus, which can be quite irritating to the user\n    var iframe = document.createElement(\"iframe\");\n    iframe.setAttribute(\"style\", \"position:absolute; position:fixed; top:0; left:-2px; width:1px; height:1px; overflow:hidden;\");\n    iframe.setAttribute(\"aria-live\", \"off\");\n    iframe.setAttribute(\"aria-busy\", \"true\");\n    iframe.setAttribute(\"aria-hidden\", \"true\");\n    document.body.appendChild(iframe);\n    var _window = iframe.contentWindow;\n    var _document = _window.document;\n    _document.open();\n    _document.close();\n    var wrapper = _document.createElement(\"div\");\n    _document.body.appendChild(wrapper);\n    data.iframe = iframe;\n    data.wrapper = wrapper;\n    data.window = _window;\n    data.document = _document;\n    return data;\n}\n// options.element:\n//  {string} element name\n//  {function} callback(wrapper, document) to generate an element\n// options.mutate: (optional)\n//  {function} callback(element, wrapper, document) to manipulate element prior to focus-test.\n//             Can return DOMElement to define focus target (default: element)\n// options.validate: (optional)\n//  {function} callback(element, focusTarget, document) to manipulate test-result\nfunction test(data, options) {\n    // make sure we operate on a clean slate\n    data.wrapper.innerHTML = \"\";\n    // create dummy element to test focusability of\n    var element = typeof options.element === \"string\" ? data.document.createElement(options.element) : options.element(data.wrapper, data.document);\n    // allow callback to further specify dummy element\n    // and optionally define element to focus\n    var focus = options.mutate && options.mutate(element, data.wrapper, data.document);\n    if (!focus && focus !== false) {\n        focus = element;\n    }\n    // element needs to be part of the DOM to be focusable\n    !element.parentNode && data.wrapper.appendChild(element);\n    // test if the element with invalid tabindex can be focused\n    focus && focus.focus && focus.focus();\n    // validate test's result\n    return options.validate ? options.validate(element, focus, data.document) : data.document.activeElement === focus;\n}\nfunction after(data) {\n    // restore focus to what it was before test and cleanup\n    if (data.activeElement === document.body) {\n        document.activeElement && document.activeElement.blur && document.activeElement.blur();\n        if (platform.is.IE10) {\n            // IE10 does not redirect focus to <body> when the activeElement is removed\n            document.body.focus();\n        }\n    } else {\n        data.activeElement && data.activeElement.focus && data.activeElement.focus();\n    }\n    document.body.removeChild(data.iframe);\n    // restore scroll position\n    window.scrollTop = data.windowScrollTop;\n    window.scrollLeft = data.windowScrollLeft;\n    document.body.scrollTop = data.bodyScrollTop;\n    document.body.scrollLeft = data.bodyScrollLeft;\n}\nfunction detectFocus(tests) {\n    var data = before();\n    var results = {};\n    Object.keys(tests).map(function(key) {\n        results[key] = test(data, tests[key]);\n    });\n    after(data);\n    return results;\n}\n// this file is overwritten by `npm run build:pre`\nvar version$1 = \"1.4.1\";\n/*\n    Facility to cache test results in localStorage.\n\n    USAGE:\n      cache.get('key');\n      cache.set('key', 'value');\n */ function readLocalStorage(key) {\n    // allow reading from storage to retrieve previous support results\n    // even while the document does not have focus\n    var data = void 0;\n    try {\n        data = window.localStorage && window.localStorage.getItem(key);\n        data = data ? JSON.parse(data) : {};\n    } catch (e) {\n        data = {};\n    }\n    return data;\n}\nfunction writeLocalStorage(key, value) {\n    if (!document.hasFocus()) {\n        // if the document does not have focus when tests are executed, focus() may\n        // not be handled properly and events may not be dispatched immediately.\n        // This can happen when a document is reloaded while Developer Tools have focus.\n        try {\n            window.localStorage && window.localStorage.removeItem(key);\n        } catch (e) {\n        // ignore\n        }\n        return;\n    }\n    try {\n        window.localStorage && window.localStorage.setItem(key, JSON.stringify(value));\n    } catch (e) {\n    // ignore\n    }\n}\nvar userAgent =  true && window.navigator.userAgent || \"\";\nvar cacheKey = \"ally-supports-cache\";\nvar cache = readLocalStorage(cacheKey);\n// update the cache if ally or the user agent changed (newer version, etc)\nif (cache.userAgent !== userAgent || cache.version !== version$1) {\n    cache = {};\n}\ncache.userAgent = userAgent;\ncache.version = version$1;\nvar cache$1 = {\n    get: function get() {\n        return cache;\n    },\n    set: function set(values) {\n        Object.keys(values).forEach(function(key) {\n            cache[key] = values[key];\n        });\n        cache.time = new Date().toISOString();\n        writeLocalStorage(cacheKey, cache);\n    }\n};\nfunction cssShadowPiercingDeepCombinator() {\n    var combinator = void 0;\n    // see https://dev.w3.org/csswg/css-scoping-1/#deep-combinator\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1117572\n    // https://code.google.com/p/chromium/issues/detail?id=446051\n    try {\n        document.querySelector(\"html >>> :first-child\");\n        combinator = \">>>\";\n    } catch (noArrowArrowArrow) {\n        try {\n            // old syntax supported at least up to Chrome 41\n            // https://code.google.com/p/chromium/issues/detail?id=446051\n            document.querySelector(\"html /deep/ :first-child\");\n            combinator = \"/deep/\";\n        } catch (noDeep) {\n            combinator = \"\";\n        }\n    }\n    return combinator;\n}\nvar gif = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n// https://developer.mozilla.org/docs/Web/HTML/Element/img#attr-usemap\nvar focusAreaImgTabindex = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = '<map name=\"image-map-tabindex-test\">' + '<area shape=\"rect\" coords=\"63,19,144,45\"></map>' + '<img usemap=\"#image-map-tabindex-test\" tabindex=\"-1\" alt=\"\" src=\"' + gif + '\">';\n        return element.querySelector(\"area\");\n    }\n};\n// https://developer.mozilla.org/docs/Web/HTML/Element/img#attr-usemap\nvar focusAreaTabindex = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = '<map name=\"image-map-tabindex-test\">' + '<area href=\"#void\" tabindex=\"-1\" shape=\"rect\" coords=\"63,19,144,45\"></map>' + '<img usemap=\"#image-map-tabindex-test\" alt=\"\" src=\"' + gif + '\">';\n        return false;\n    },\n    validate: function validate(element, focusTarget, _document) {\n        if (platform.is.GECKO) {\n            // fixes https://github.com/medialize/ally.js/issues/35\n            // Firefox loads the DataURI asynchronously, causing a false-negative\n            return true;\n        }\n        var focus = element.querySelector(\"area\");\n        focus.focus();\n        return _document.activeElement === focus;\n    }\n};\n// https://developer.mozilla.org/docs/Web/HTML/Element/img#attr-usemap\nvar focusAreaWithoutHref = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = '<map name=\"image-map-area-href-test\">' + '<area shape=\"rect\" coords=\"63,19,144,45\"></map>' + '<img usemap=\"#image-map-area-href-test\" alt=\"\" src=\"' + gif + '\">';\n        return element.querySelector(\"area\");\n    },\n    validate: function validate(element, focusTarget, _document) {\n        if (platform.is.GECKO) {\n            // fixes https://github.com/medialize/ally.js/issues/35\n            // Firefox loads the DataURI asynchronously, causing a false-negative\n            return true;\n        }\n        return _document.activeElement === focusTarget;\n    }\n};\nvar focusAudioWithoutControls = {\n    name: \"can-focus-audio-without-controls\",\n    element: \"audio\",\n    mutate: function mutate(element) {\n        try {\n            // invalid media file can trigger warning in console, data-uri to prevent HTTP request\n            element.setAttribute(\"src\", gif);\n        } catch (e) {\n        // IE9 may throw \"Error: Not implemented\"\n        }\n    }\n};\nvar invalidGif = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\";\n// NOTE: https://github.com/medialize/ally.js/issues/35\n// https://developer.mozilla.org/docs/Web/HTML/Element/img#attr-usemap\nvar focusBrokenImageMap = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = '<map name=\"broken-image-map-test\"><area href=\"#void\" shape=\"rect\" coords=\"63,19,144,45\"></map>' + '<img usemap=\"#broken-image-map-test\" alt=\"\" src=\"' + invalidGif + '\">';\n        return element.querySelector(\"area\");\n    }\n};\n// Children of focusable elements with display:flex are focusable in IE10-11\nvar focusChildrenOfFocusableFlexbox = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"tabindex\", \"-1\");\n        element.setAttribute(\"style\", \"display: -webkit-flex; display: -ms-flexbox; display: flex;\");\n        element.innerHTML = '<span style=\"display: block;\">hello</span>';\n        return element.querySelector(\"span\");\n    }\n};\n// fieldset[tabindex=0][disabled] should not be focusable, but Blink and WebKit disagree\n// @specification https://www.w3.org/TR/html5/disabled-elements.html#concept-element-disabled\n// @browser-issue Chromium https://crbug.com/453847\n// @browser-issue WebKit https://bugs.webkit.org/show_bug.cgi?id=141086\nvar focusFieldsetDisabled = {\n    element: \"fieldset\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"tabindex\", 0);\n        element.setAttribute(\"disabled\", \"disabled\");\n    }\n};\nvar focusFieldset = {\n    element: \"fieldset\",\n    mutate: function mutate(element) {\n        element.innerHTML = \"<legend>legend</legend><p>content</p>\";\n    }\n};\n// elements with display:flex are focusable in IE10-11\nvar focusFlexboxContainer = {\n    element: \"span\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"style\", \"display: -webkit-flex; display: -ms-flexbox; display: flex;\");\n        element.innerHTML = '<span style=\"display: block;\">hello</span>';\n    }\n};\n// form[tabindex=0][disabled] should be focusable as the\n// specification doesn't know the disabled attribute on the form element\n// @specification https://www.w3.org/TR/html5/forms.html#the-form-element\nvar focusFormDisabled = {\n    element: \"form\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"tabindex\", 0);\n        element.setAttribute(\"disabled\", \"disabled\");\n    }\n};\n// NOTE: https://github.com/medialize/ally.js/issues/35\n// fixes https://github.com/medialize/ally.js/issues/20\n// https://developer.mozilla.org/docs/Web/HTML/Element/img#attr-ismap\nvar focusImgIsmap = {\n    element: \"a\",\n    mutate: function mutate(element) {\n        element.href = \"#void\";\n        element.innerHTML = '<img ismap src=\"' + gif + '\" alt=\"\">';\n        return element.querySelector(\"img\");\n    }\n};\n// NOTE: https://github.com/medialize/ally.js/issues/35\n// https://developer.mozilla.org/docs/Web/HTML/Element/img#attr-usemap\nvar focusImgUsemapTabindex = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = '<map name=\"image-map-tabindex-test\"><area href=\"#void\" shape=\"rect\" coords=\"63,19,144,45\"></map>' + '<img usemap=\"#image-map-tabindex-test\" tabindex=\"-1\" alt=\"\" ' + 'src=\"' + gif + '\">';\n        return element.querySelector(\"img\");\n    }\n};\nvar focusInHiddenIframe = {\n    element: function element(wrapper, _document) {\n        var iframe = _document.createElement(\"iframe\");\n        // iframe must be part of the DOM before accessing the contentWindow is possible\n        wrapper.appendChild(iframe);\n        // create the iframe's default document (<html><head></head><body></body></html>)\n        var iframeDocument = iframe.contentWindow.document;\n        iframeDocument.open();\n        iframeDocument.close();\n        return iframe;\n    },\n    mutate: function mutate(iframe) {\n        iframe.style.visibility = \"hidden\";\n        var iframeDocument = iframe.contentWindow.document;\n        var input = iframeDocument.createElement(\"input\");\n        iframeDocument.body.appendChild(input);\n        return input;\n    },\n    validate: function validate(iframe) {\n        var iframeDocument = iframe.contentWindow.document;\n        var focus = iframeDocument.querySelector(\"input\");\n        return iframeDocument.activeElement === focus;\n    }\n};\nvar result = !platform.is.WEBKIT;\nfunction focusInZeroDimensionObject() {\n    return result;\n}\n// Firefox allows *any* value and treats invalid values like tabindex=\"-1\"\n// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\nvar focusInvalidTabindex = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"tabindex\", \"invalid-value\");\n    }\n};\nvar focusLabelTabindex = {\n    element: \"label\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"tabindex\", \"-1\");\n    },\n    validate: function validate(element, focusTarget, _document) {\n        // force layout in Chrome 49, otherwise the element won't be focusable\n        /* eslint-disable no-unused-vars */ var variableToPreventDeadCodeElimination = element.offsetHeight;\n        /* eslint-enable no-unused-vars */ element.focus();\n        return _document.activeElement === element;\n    }\n};\nvar svg = \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtb\" + \"G5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBpZD0ic3ZnIj48dGV4dCB4PSIxMCIgeT0iMjAiIGlkPSJ\" + \"zdmctbGluay10ZXh0Ij50ZXh0PC90ZXh0Pjwvc3ZnPg==\";\n// Note: IE10 on BrowserStack does not like this test\nvar focusObjectSvgHidden = {\n    element: \"object\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"type\", \"image/svg+xml\");\n        element.setAttribute(\"data\", svg);\n        element.setAttribute(\"width\", \"200\");\n        element.setAttribute(\"height\", \"50\");\n        element.style.visibility = \"hidden\";\n    }\n};\n// Note: IE10 on BrowserStack does not like this test\nvar focusObjectSvg = {\n    name: \"can-focus-object-svg\",\n    element: \"object\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"type\", \"image/svg+xml\");\n        element.setAttribute(\"data\", svg);\n        element.setAttribute(\"width\", \"200\");\n        element.setAttribute(\"height\", \"50\");\n    },\n    validate: function validate(element, focusTarget, _document) {\n        if (platform.is.GECKO) {\n            // Firefox seems to be handling the object creation asynchronously and thereby produces a false negative test result.\n            // Because we know Firefox is able to focus object elements referencing SVGs, we simply cheat by sniffing the user agent string\n            return true;\n        }\n        return _document.activeElement === element;\n    }\n};\n// Every Environment except IE9 considers SWF objects focusable\nvar result$1 = !platform.is.IE9;\nfunction focusObjectSwf() {\n    return result$1;\n}\nvar focusRedirectImgUsemap = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = '<map name=\"focus-redirect-img-usemap\"><area href=\"#void\" shape=\"rect\" coords=\"63,19,144,45\"></map>' + '<img usemap=\"#focus-redirect-img-usemap\" alt=\"\" ' + 'src=\"' + gif + '\">';\n        // focus the <img>, not the <div>\n        return element.querySelector(\"img\");\n    },\n    validate: function validate(element, focusTarget, _document) {\n        var target = element.querySelector(\"area\");\n        return _document.activeElement === target;\n    }\n};\n// see https://jsbin.com/nenirisage/edit?html,js,console,output\nvar focusRedirectLegend = {\n    element: \"fieldset\",\n    mutate: function mutate(element) {\n        element.innerHTML = '<legend>legend</legend><input tabindex=\"-1\"><input tabindex=\"0\">';\n        // take care of focus in validate();\n        return false;\n    },\n    validate: function validate(element, focusTarget, _document) {\n        var focusable = element.querySelector('input[tabindex=\"-1\"]');\n        var tabbable = element.querySelector('input[tabindex=\"0\"]');\n        // Firefox requires this test to focus the <fieldset> first, while this is not necessary in\n        // https://jsbin.com/nenirisage/edit?html,js,console,output\n        element.focus();\n        element.querySelector(\"legend\").focus();\n        return _document.activeElement === focusable && \"focusable\" || _document.activeElement === tabbable && \"tabbable\" || \"\";\n    }\n};\n// https://github.com/medialize/ally.js/issues/21\nvar focusScrollBody = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"style\", \"width: 100px; height: 50px; overflow: auto;\");\n        element.innerHTML = '<div style=\"width: 500px; height: 40px;\">scrollable content</div>';\n        return element.querySelector(\"div\");\n    }\n};\n// https://github.com/medialize/ally.js/issues/21\nvar focusScrollContainerWithoutOverflow = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"style\", \"width: 100px; height: 50px;\");\n        element.innerHTML = '<div style=\"width: 500px; height: 40px;\">scrollable content</div>';\n    }\n};\n// https://github.com/medialize/ally.js/issues/21\nvar focusScrollContainer = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"style\", \"width: 100px; height: 50px; overflow: auto;\");\n        element.innerHTML = '<div style=\"width: 500px; height: 40px;\">scrollable content</div>';\n    }\n};\nvar focusSummary = {\n    element: \"details\",\n    mutate: function mutate(element) {\n        element.innerHTML = \"<summary>foo</summary><p>content</p>\";\n        return element.firstElementChild;\n    }\n};\nfunction makeFocusableForeignObject() {\n    // Constructs <foreignObject width=\"30\" height=\"30\"><input type=\"text\"/></foreignObject>\n    // without raising a Trusted Types violation\n    var foreignObject = document.createElementNS(\"http://www.w3.org/2000/svg\", \"foreignObject\");\n    foreignObject.width.baseVal.value = 30;\n    foreignObject.height.baseVal.value = 30;\n    foreignObject.appendChild(document.createElement(\"input\"));\n    foreignObject.lastChild.type = \"text\";\n    return foreignObject;\n}\nfunction focusSvgForeignObjectHack(element) {\n    // Edge13, Edge14: foreignObject focus hack\n    // https://jsbin.com/kunehinugi/edit?html,js,output\n    // https://jsbin.com/fajagi/3/edit?html,js,output\n    var isSvgElement = element.ownerSVGElement || element.nodeName.toLowerCase() === \"svg\";\n    if (!isSvgElement) {\n        return false;\n    }\n    // inject and focus an <input> element into the SVG element to receive focus\n    var foreignObject = makeFocusableForeignObject();\n    element.appendChild(foreignObject);\n    var input = foreignObject.querySelector(\"input\");\n    input.focus();\n    // upon disabling the activeElement, IE and Edge\n    // will not shift focus to <body> like all the other\n    // browsers, but instead find the first focusable\n    // ancestor and shift focus to that\n    input.disabled = true;\n    // clean up\n    element.removeChild(foreignObject);\n    return true;\n}\nfunction generate(element) {\n    return '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">' + element + \"</svg>\";\n}\nfunction focus(element) {\n    if (element.focus) {\n        return;\n    }\n    try {\n        HTMLElement.prototype.focus.call(element);\n    } catch (e) {\n        focusSvgForeignObjectHack(element);\n    }\n}\nfunction validate(element, focusTarget, _document) {\n    focus(focusTarget);\n    return _document.activeElement === focusTarget;\n}\nvar focusSvgFocusableAttribute = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = generate('<text focusable=\"true\">a</text>');\n        return element.querySelector(\"text\");\n    },\n    validate: validate\n};\nvar focusSvgTabindexAttribute = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = generate('<text tabindex=\"0\">a</text>');\n        return element.querySelector(\"text\");\n    },\n    validate: validate\n};\nvar focusSvgNegativeTabindexAttribute = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = generate('<text tabindex=\"-1\">a</text>');\n        return element.querySelector(\"text\");\n    },\n    validate: validate\n};\nvar focusSvgUseTabindex = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = generate([\n            '<g id=\"ally-test-target\"><a xlink:href=\"#void\"><text>link</text></a></g>',\n            '<use xlink:href=\"#ally-test-target\" x=\"0\" y=\"0\" tabindex=\"-1\" />'\n        ].join(\"\"));\n        return element.querySelector(\"use\");\n    },\n    validate: validate\n};\nvar focusSvgForeignobjectTabindex = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = generate('<foreignObject tabindex=\"-1\"><input type=\"text\" /></foreignObject>');\n        // Safari 8's quersSelector() can't identify foreignObject, but getElementyByTagName() can\n        return element.querySelector(\"foreignObject\") || element.getElementsByTagName(\"foreignObject\")[0];\n    },\n    validate: validate\n};\n// Firefox seems to be handling the SVG-document-in-iframe creation asynchronously\n// and thereby produces a false negative test result. Thus the test is pointless\n// and we resort to UA sniffing once again.\n// see http://jsbin.com/vunadohoko/1/edit?js,console,output\nvar result$2 = Boolean(platform.is.GECKO && typeof SVGElement !== \"undefined\" && SVGElement.prototype.focus);\nfunction focusSvgInIframe() {\n    return result$2;\n}\nvar focusSvg = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.innerHTML = generate(\"\");\n        return element.firstChild;\n    },\n    validate: validate\n};\n// Firefox allows *any* value and treats invalid values like tabindex=\"-1\"\n// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\nvar focusTabindexTrailingCharacters = {\n    element: \"div\",\n    mutate: function mutate(element) {\n        element.setAttribute(\"tabindex\", \"3x\");\n    }\n};\nvar focusTable = {\n    element: \"table\",\n    mutate: function mutate(element, wrapper, _document) {\n        // IE9 has a problem replacing TBODY contents with innerHTML.\n        // https://stackoverflow.com/a/8097055/515124\n        // element.innerHTML = '<tr><td>cell</td></tr>';\n        var fragment = _document.createDocumentFragment();\n        fragment.innerHTML = \"<tr><td>cell</td></tr>\";\n        element.appendChild(fragment);\n    }\n};\nvar focusVideoWithoutControls = {\n    element: \"video\",\n    mutate: function mutate(element) {\n        try {\n            // invalid media file can trigger warning in console, data-uri to prevent HTTP request\n            element.setAttribute(\"src\", gif);\n        } catch (e) {\n        // IE9 may throw \"Error: Not implemented\"\n        }\n    }\n};\n// https://jsbin.com/vafaba/3/edit?html,js,console,output\nvar result$3 = platform.is.GECKO || platform.is.TRIDENT || platform.is.EDGE;\nfunction tabsequenceAreaAtImgPosition() {\n    return result$3;\n}\nvar testCallbacks = {\n    cssShadowPiercingDeepCombinator: cssShadowPiercingDeepCombinator,\n    focusInZeroDimensionObject: focusInZeroDimensionObject,\n    focusObjectSwf: focusObjectSwf,\n    focusSvgInIframe: focusSvgInIframe,\n    tabsequenceAreaAtImgPosition: tabsequenceAreaAtImgPosition\n};\nvar testDescriptions = {\n    focusAreaImgTabindex: focusAreaImgTabindex,\n    focusAreaTabindex: focusAreaTabindex,\n    focusAreaWithoutHref: focusAreaWithoutHref,\n    focusAudioWithoutControls: focusAudioWithoutControls,\n    focusBrokenImageMap: focusBrokenImageMap,\n    focusChildrenOfFocusableFlexbox: focusChildrenOfFocusableFlexbox,\n    focusFieldsetDisabled: focusFieldsetDisabled,\n    focusFieldset: focusFieldset,\n    focusFlexboxContainer: focusFlexboxContainer,\n    focusFormDisabled: focusFormDisabled,\n    focusImgIsmap: focusImgIsmap,\n    focusImgUsemapTabindex: focusImgUsemapTabindex,\n    focusInHiddenIframe: focusInHiddenIframe,\n    focusInvalidTabindex: focusInvalidTabindex,\n    focusLabelTabindex: focusLabelTabindex,\n    focusObjectSvg: focusObjectSvg,\n    focusObjectSvgHidden: focusObjectSvgHidden,\n    focusRedirectImgUsemap: focusRedirectImgUsemap,\n    focusRedirectLegend: focusRedirectLegend,\n    focusScrollBody: focusScrollBody,\n    focusScrollContainerWithoutOverflow: focusScrollContainerWithoutOverflow,\n    focusScrollContainer: focusScrollContainer,\n    focusSummary: focusSummary,\n    focusSvgFocusableAttribute: focusSvgFocusableAttribute,\n    focusSvgTabindexAttribute: focusSvgTabindexAttribute,\n    focusSvgNegativeTabindexAttribute: focusSvgNegativeTabindexAttribute,\n    focusSvgUseTabindex: focusSvgUseTabindex,\n    focusSvgForeignobjectTabindex: focusSvgForeignobjectTabindex,\n    focusSvg: focusSvg,\n    focusTabindexTrailingCharacters: focusTabindexTrailingCharacters,\n    focusTable: focusTable,\n    focusVideoWithoutControls: focusVideoWithoutControls\n};\nfunction executeTests() {\n    var results = detectFocus(testDescriptions);\n    Object.keys(testCallbacks).forEach(function(key) {\n        results[key] = testCallbacks[key]();\n    });\n    return results;\n}\nvar supportsCache = null;\nfunction _supports() {\n    if (supportsCache) {\n        return supportsCache;\n    }\n    supportsCache = cache$1.get();\n    if (!supportsCache.time) {\n        cache$1.set(executeTests());\n        supportsCache = cache$1.get();\n    }\n    return supportsCache;\n}\nvar supports = void 0;\n// https://www.w3.org/TR/html5/infrastructure.html#rules-for-parsing-integers\n// NOTE: all browsers agree to allow trailing spaces as well\nvar validIntegerPatternNoTrailing = /^\\s*(-|\\+)?[0-9]+\\s*$/;\nvar validIntegerPatternWithTrailing = /^\\s*(-|\\+)?[0-9]+.*$/;\nfunction isValidTabindex(context) {\n    if (!supports) {\n        supports = _supports();\n    }\n    var validIntegerPattern = supports.focusTabindexTrailingCharacters ? validIntegerPatternWithTrailing : validIntegerPatternNoTrailing;\n    var element = contextToElement({\n        label: \"is/valid-tabindex\",\n        resolveDocument: true,\n        context: context\n    });\n    // Edge 14 has a capitalization problem on SVG elements,\n    // see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9282058/\n    var hasTabindex = element.hasAttribute(\"tabindex\");\n    var hasTabIndex = element.hasAttribute(\"tabIndex\");\n    if (!hasTabindex && !hasTabIndex) {\n        return false;\n    }\n    // older Firefox and Internet Explorer don't support tabindex on SVG elements\n    var isSvgElement = element.ownerSVGElement || element.nodeName.toLowerCase() === \"svg\";\n    if (isSvgElement && !supports.focusSvgTabindexAttribute) {\n        return false;\n    }\n    // @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    if (supports.focusInvalidTabindex) {\n        return true;\n    }\n    // an element matches the tabindex selector even if its value is invalid\n    var tabindex = element.getAttribute(hasTabindex ? \"tabindex\" : \"tabIndex\");\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    // @browser-issue Trident https://connect.microsoft.com/IE/feedback/details/1072965\n    if (tabindex === \"-32768\") {\n        return false;\n    }\n    return Boolean(tabindex && validIntegerPattern.test(tabindex));\n}\nfunction tabindexValue(element) {\n    if (!isValidTabindex(element)) {\n        return null;\n    }\n    // Edge 14 has a capitalization problem on SVG elements,\n    // see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9282058/\n    var hasTabindex = element.hasAttribute(\"tabindex\");\n    var attributeName = hasTabindex ? \"tabindex\" : \"tabIndex\";\n    // @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    var tabindex = parseInt(element.getAttribute(attributeName), 10);\n    return isNaN(tabindex) ? -1 : tabindex;\n}\n// this is a shared utility file for focus-relevant.js and tabbable.js\n// separate testing of this file's functions is not necessary,\n// as they're implicitly tested by way of the consumers\nfunction isUserModifyWritable(style) {\n    // https://www.w3.org/TR/1999/WD-css3-userint-19990916#user-modify\n    // https://github.com/medialize/ally.js/issues/17\n    var userModify = style.webkitUserModify || \"\";\n    return Boolean(userModify && userModify.indexOf(\"write\") !== -1);\n}\nfunction hasCssOverflowScroll(style) {\n    return [\n        style.getPropertyValue(\"overflow\"),\n        style.getPropertyValue(\"overflow-x\"),\n        style.getPropertyValue(\"overflow-y\")\n    ].some(function(overflow) {\n        return overflow === \"auto\" || overflow === \"scroll\";\n    });\n}\nfunction hasCssDisplayFlex(style) {\n    return style.display.indexOf(\"flex\") > -1;\n}\nfunction isScrollableContainer(element, nodeName, parentNodeName, parentStyle) {\n    if (nodeName !== \"div\" && nodeName !== \"span\") {\n        // Internet Explorer advances scrollable containers and bodies to focusable\n        // only if the scrollable container is <div> or <span> - this does *not*\n        // happen for <section>, <article>, â€¦\n        return false;\n    }\n    if (parentNodeName && parentNodeName !== \"div\" && parentNodeName !== \"span\" && !hasCssOverflowScroll(parentStyle)) {\n        return false;\n    }\n    return element.offsetHeight < element.scrollHeight || element.offsetWidth < element.scrollWidth;\n}\nvar supports$1 = void 0;\nfunction isFocusRelevantRules() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, _ref$except = _ref.except, except = _ref$except === undefined ? {\n        flexbox: false,\n        scrollable: false,\n        shadow: false\n    } : _ref$except;\n    if (!supports$1) {\n        supports$1 = _supports();\n    }\n    var element = contextToElement({\n        label: \"is/focus-relevant\",\n        resolveDocument: true,\n        context: context\n    });\n    if (!except.shadow && element.shadowRoot) {\n        // a ShadowDOM host receives focus when the focus moves to its content\n        return true;\n    }\n    var nodeName = element.nodeName.toLowerCase();\n    if (nodeName === \"input\" && element.type === \"hidden\") {\n        // input[type=\"hidden\"] supports.cannot be focused\n        return false;\n    }\n    if (nodeName === \"input\" || nodeName === \"select\" || nodeName === \"button\" || nodeName === \"textarea\") {\n        return true;\n    }\n    if (nodeName === \"legend\" && supports$1.focusRedirectLegend) {\n        // specifics filtered in is/focusable\n        return true;\n    }\n    if (nodeName === \"label\") {\n        // specifics filtered in is/focusable\n        return true;\n    }\n    if (nodeName === \"area\") {\n        // specifics filtered in is/focusable\n        return true;\n    }\n    if (nodeName === \"a\" && element.hasAttribute(\"href\")) {\n        return true;\n    }\n    if (nodeName === \"object\" && element.hasAttribute(\"usemap\")) {\n        // object[usemap] is not focusable in any browser\n        return false;\n    }\n    if (nodeName === \"object\") {\n        var svgType = element.getAttribute(\"type\");\n        if (!supports$1.focusObjectSvg && svgType === \"image/svg+xml\") {\n            // object[type=\"image/svg+xml\"] is not focusable in Internet Explorer\n            return false;\n        } else if (!supports$1.focusObjectSwf && svgType === \"application/x-shockwave-flash\") {\n            // object[type=\"application/x-shockwave-flash\"] is not focusable in Internet Explorer 9\n            return false;\n        }\n    }\n    if (nodeName === \"iframe\" || nodeName === \"object\") {\n        // browsing context containers\n        return true;\n    }\n    if (nodeName === \"embed\" || nodeName === \"keygen\") {\n        // embed is considered focus-relevant but not focusable\n        // see https://github.com/medialize/ally.js/issues/82\n        return true;\n    }\n    if (element.hasAttribute(\"contenteditable\")) {\n        // also see CSS property user-modify below\n        return true;\n    }\n    if (nodeName === \"audio\" && (supports$1.focusAudioWithoutControls || element.hasAttribute(\"controls\"))) {\n        return true;\n    }\n    if (nodeName === \"video\" && (supports$1.focusVideoWithoutControls || element.hasAttribute(\"controls\"))) {\n        return true;\n    }\n    if (supports$1.focusSummary && nodeName === \"summary\") {\n        return true;\n    }\n    var validTabindex = isValidTabindex(element);\n    if (nodeName === \"img\" && element.hasAttribute(\"usemap\")) {\n        // Gecko, Trident and Edge do not allow an image with an image map and tabindex to be focused,\n        // it appears the tabindex is overruled so focus is still forwarded to the <map>\n        return validTabindex && supports$1.focusImgUsemapTabindex || supports$1.focusRedirectImgUsemap;\n    }\n    if (supports$1.focusTable && (nodeName === \"table\" || nodeName === \"td\")) {\n        // IE10-11 supports.can focus <table> and <td>\n        return true;\n    }\n    if (supports$1.focusFieldset && nodeName === \"fieldset\") {\n        // IE10-11 supports.can focus <fieldset>\n        return true;\n    }\n    var isSvgElement = nodeName === \"svg\";\n    var isSvgContent = element.ownerSVGElement;\n    var focusableAttribute = element.getAttribute(\"focusable\");\n    var tabindex = tabindexValue(element);\n    if (nodeName === \"use\" && tabindex !== null && !supports$1.focusSvgUseTabindex) {\n        // <use> cannot be made focusable by adding a tabindex attribute anywhere but Blink and WebKit\n        return false;\n    }\n    if (nodeName === \"foreignobject\") {\n        // <use> can only be made focusable in Blink and WebKit\n        return tabindex !== null && supports$1.focusSvgForeignobjectTabindex;\n    }\n    if (elementMatches(element, \"svg a\") && element.hasAttribute(\"xlink:href\")) {\n        return true;\n    }\n    if ((isSvgElement || isSvgContent) && element.focus && !supports$1.focusSvgNegativeTabindexAttribute && tabindex < 0) {\n        // Firefox 51 and 52 treat any natively tabbable SVG element with\n        // tabindex=\"-1\" as tabbable and everything else as inert\n        // see https://bugzilla.mozilla.org/show_bug.cgi?id=1302340\n        return false;\n    }\n    if (isSvgElement) {\n        return validTabindex || supports$1.focusSvg || supports$1.focusSvgInIframe || // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2\n        Boolean(supports$1.focusSvgFocusableAttribute && focusableAttribute && focusableAttribute === \"true\");\n    }\n    if (isSvgContent) {\n        if (supports$1.focusSvgTabindexAttribute && validTabindex) {\n            return true;\n        }\n        if (supports$1.focusSvgFocusableAttribute) {\n            // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2\n            return focusableAttribute === \"true\";\n        }\n    }\n    // https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute\n    if (validTabindex) {\n        return true;\n    }\n    var style = window.getComputedStyle(element, null);\n    if (isUserModifyWritable(style)) {\n        return true;\n    }\n    if (supports$1.focusImgIsmap && nodeName === \"img\" && element.hasAttribute(\"ismap\")) {\n        // IE10-11 considers the <img> in <a href><img ismap> focusable\n        // https://github.com/medialize/ally.js/issues/20\n        var hasLinkParent = getParents({\n            context: element\n        }).some(function(parent) {\n            return parent.nodeName.toLowerCase() === \"a\" && parent.hasAttribute(\"href\");\n        });\n        if (hasLinkParent) {\n            return true;\n        }\n    }\n    // https://github.com/medialize/ally.js/issues/21\n    if (!except.scrollable && supports$1.focusScrollContainer) {\n        if (supports$1.focusScrollContainerWithoutOverflow) {\n            // Internet Explorer does will consider the scrollable area focusable\n            // if the element is a <div> or a <span> and it is in fact scrollable,\n            // regardless of the CSS overflow property\n            if (isScrollableContainer(element, nodeName)) {\n                return true;\n            }\n        } else if (hasCssOverflowScroll(style)) {\n            // Firefox requires proper overflow setting, IE does not necessarily\n            // https://developer.mozilla.org/docs/Web/CSS/overflow\n            return true;\n        }\n    }\n    if (!except.flexbox && supports$1.focusFlexboxContainer && hasCssDisplayFlex(style)) {\n        // elements with display:flex are focusable in IE10-11\n        return true;\n    }\n    var parent = element.parentElement;\n    if (!except.scrollable && parent) {\n        var parentNodeName = parent.nodeName.toLowerCase();\n        var parentStyle = window.getComputedStyle(parent, null);\n        if (supports$1.focusScrollBody && isScrollableContainer(parent, nodeName, parentNodeName, parentStyle)) {\n            // scrollable bodies are focusable Internet Explorer\n            // https://github.com/medialize/ally.js/issues/21\n            return true;\n        }\n        // Children of focusable elements with display:flex are focusable in IE10-11\n        if (supports$1.focusChildrenOfFocusableFlexbox) {\n            if (hasCssDisplayFlex(parentStyle)) {\n                return true;\n            }\n        }\n    }\n    // NOTE: elements marked as inert are not focusable,\n    // but that property is not exposed to the DOM\n    // https://www.w3.org/TR/html5/editing.html#inert\n    return false;\n}\n// bind exceptions to an iterator callback\nisFocusRelevantRules.except = function() {\n    var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var isFocusRelevant = function isFocusRelevant(context) {\n        return isFocusRelevantRules({\n            context: context,\n            except: except\n        });\n    };\n    isFocusRelevant.rules = isFocusRelevantRules;\n    return isFocusRelevant;\n};\n// provide isFocusRelevant(context) as default iterator callback\nvar isFocusRelevant = isFocusRelevantRules.except({});\nfunction findIndex(array, callback) {\n    // attempt to use native or polyfilled Array#findIndex first\n    if (array.findIndex) {\n        return array.findIndex(callback);\n    }\n    var length = array.length;\n    // shortcut if the array is empty\n    if (length === 0) {\n        return -1;\n    }\n    // otherwise loop over array\n    for(var i = 0; i < length; i++){\n        if (callback(array[i], i, array)) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction getContentDocument(node) {\n    try {\n        // works on <object> and <iframe>\n        return node.contentDocument || // works on <object> and <iframe>\n        node.contentWindow && node.contentWindow.document || // works on <object> and <iframe> that contain SVG\n        node.getSVGDocument && node.getSVGDocument() || null;\n    } catch (e) {\n        // SecurityError: Failed to read the 'contentDocument' property from 'HTMLObjectElement'\n        // also IE may throw member not found exception e.g. on <object type=\"image/png\">\n        return null;\n    }\n}\nfunction getWindow(node) {\n    var _document = getDocument(node);\n    return _document.defaultView || window;\n}\nvar shadowPrefix = void 0;\nfunction selectInShadows(selector) {\n    if (typeof shadowPrefix !== \"string\") {\n        var operator = cssShadowPiercingDeepCombinator();\n        if (operator) {\n            shadowPrefix = \", html \" + operator + \" \";\n        }\n    }\n    if (!shadowPrefix) {\n        return selector;\n    }\n    return selector + shadowPrefix + selector.replace(/\\s*,\\s*/g, \",\").split(\",\").join(shadowPrefix);\n}\nvar selector = void 0;\nfunction findDocumentHostElement(_window) {\n    if (!selector) {\n        selector = selectInShadows(\"object, iframe\");\n    }\n    if (_window._frameElement !== undefined) {\n        return _window._frameElement;\n    }\n    _window._frameElement = null;\n    var potentialHosts = _window.parent.document.querySelectorAll(selector);\n    [].some.call(potentialHosts, function(element) {\n        var _document = getContentDocument(element);\n        if (_document !== _window.document) {\n            return false;\n        }\n        _window._frameElement = element;\n        return true;\n    });\n    return _window._frameElement;\n}\nfunction getFrameElement(element) {\n    var _window = getWindow(element);\n    if (!_window.parent || _window.parent === _window) {\n        // if there is no parent browsing context,\n        // we're not going to get a frameElement either way\n        return null;\n    }\n    try {\n        // see https://developer.mozilla.org/docs/Web/API/Window/frameElement\n        // does not work within <embed> anywhere, and not within in <object> in IE\n        return _window.frameElement || findDocumentHostElement(_window);\n    } catch (e) {\n        return null;\n    }\n}\n// https://www.w3.org/TR/html5/rendering.html#being-rendered\n// <area> is not rendered, but we *consider* it visible to simplfiy this function's usage\nvar notRenderedElementsPattern = /^(area)$/;\nfunction computedStyle(element, property) {\n    return window.getComputedStyle(element, null).getPropertyValue(property);\n}\nfunction notDisplayed(_path) {\n    return _path.some(function(element) {\n        // display:none is not visible (optimized away at layout)\n        return computedStyle(element, \"display\") === \"none\";\n    });\n}\nfunction notVisible(_path) {\n    // https://github.com/jquery/jquery-ui/blob/master/ui/core.js#L109-L114\n    // NOTE: a nested element can reverse visibility:hidden|collapse by explicitly setting visibility:visible\n    // NOTE: visibility can be [\"\", \"visible\", \"hidden\", \"collapse\"]\n    var hidden = findIndex(_path, function(element) {\n        var visibility = computedStyle(element, \"visibility\");\n        return visibility === \"hidden\" || visibility === \"collapse\";\n    });\n    if (hidden === -1) {\n        // there is no hidden element\n        return false;\n    }\n    var visible = findIndex(_path, function(element) {\n        return computedStyle(element, \"visibility\") === \"visible\";\n    });\n    if (visible === -1) {\n        // there is no visible element (but a hidden element)\n        return true;\n    }\n    if (hidden < visible) {\n        // there is a hidden element and it's closer than the first visible element\n        return true;\n    }\n    // there may be a hidden element, but the closest element is visible\n    return false;\n}\nfunction collapsedParent(_path) {\n    var offset = 1;\n    if (_path[0].nodeName.toLowerCase() === \"summary\") {\n        offset = 2;\n    }\n    return _path.slice(offset).some(function(element) {\n        // \"content children\" of a closed details element are not visible\n        return element.nodeName.toLowerCase() === \"details\" && element.open === false;\n    });\n}\nfunction isVisibleRules() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, _ref$except = _ref.except, except = _ref$except === undefined ? {\n        notRendered: false,\n        cssDisplay: false,\n        cssVisibility: false,\n        detailsElement: false,\n        browsingContext: false\n    } : _ref$except;\n    var element = contextToElement({\n        label: \"is/visible\",\n        resolveDocument: true,\n        context: context\n    });\n    var nodeName = element.nodeName.toLowerCase();\n    if (!except.notRendered && notRenderedElementsPattern.test(nodeName)) {\n        return true;\n    }\n    var _path = getParents({\n        context: element\n    });\n    // in Internet Explorer <audio> has a default display: none, where others have display: inline\n    // but IE allows focusing <audio style=\"display:none\">, but not <div display:none><audio>\n    // this is irrelevant to other browsers, as the controls attribute is required to make <audio> focusable\n    var isAudioWithoutControls = nodeName === \"audio\" && !element.hasAttribute(\"controls\");\n    if (!except.cssDisplay && notDisplayed(isAudioWithoutControls ? _path.slice(1) : _path)) {\n        return false;\n    }\n    if (!except.cssVisibility && notVisible(_path)) {\n        return false;\n    }\n    if (!except.detailsElement && collapsedParent(_path)) {\n        return false;\n    }\n    if (!except.browsingContext) {\n        // elements within a browsing context are affected by the\n        // browsing context host element's visibility and tabindex\n        var frameElement = getFrameElement(element);\n        var _isVisible = isVisibleRules.except(except);\n        if (frameElement && !_isVisible(frameElement)) {\n            return false;\n        }\n    }\n    return true;\n}\n// bind exceptions to an iterator callback\nisVisibleRules.except = function() {\n    var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var isVisible = function isVisible(context) {\n        return isVisibleRules({\n            context: context,\n            except: except\n        });\n    };\n    isVisible.rules = isVisibleRules;\n    return isVisible;\n};\n// provide isVisible(context) as default iterator callback\nvar isVisible = isVisibleRules.except({});\nfunction getMapByName(name, _document) {\n    // apparently getElementsByName() also considers id attribute in IE & opera\n    // https://developer.mozilla.org/docs/Web/API/Document/getElementsByName\n    var map = _document.querySelector('map[name=\"' + (0, _cssescape.default)(name) + '\"]');\n    return map || null;\n}\nfunction getImageOfArea(element) {\n    var map = element.parentElement;\n    if (!map.name || map.nodeName.toLowerCase() !== \"map\") {\n        return null;\n    }\n    // NOTE: image maps can also be applied to <object> with image content,\n    // but no browser supports this at the moment\n    // HTML5 specifies HTMLMapElement.images to be an HTMLCollection of all\n    // <img> and <object> referencing the <map> element, but no browser implements this\n    //   https://www.w3.org/TR/html5/embedded-content-0.html#the-map-element\n    //   https://developer.mozilla.org/docs/Web/API/HTMLMapElement\n    // the image must be valid and loaded for the map to take effect\n    var _document = getDocument(element);\n    return _document.querySelector('img[usemap=\"#' + (0, _cssescape.default)(map.name) + '\"]') || null;\n}\nvar supports$2 = void 0;\n// https://developer.mozilla.org/docs/Web/HTML/Element/map\n// https://developer.mozilla.org/docs/Web/HTML/Element/img#attr-usemap\n// https://github.com/jquery/jquery-ui/blob/master/ui/core.js#L88-L107\nfunction isValidArea(context) {\n    if (!supports$2) {\n        supports$2 = _supports();\n    }\n    var element = contextToElement({\n        label: \"is/valid-area\",\n        context: context\n    });\n    var nodeName = element.nodeName.toLowerCase();\n    if (nodeName !== \"area\") {\n        return false;\n    }\n    var hasTabindex = element.hasAttribute(\"tabindex\");\n    if (!supports$2.focusAreaTabindex && hasTabindex) {\n        // Blink and WebKit do not consider <area tabindex=\"-1\" href=\"#void\"> focusable\n        return false;\n    }\n    var img = getImageOfArea(element);\n    if (!img || !isVisible(img)) {\n        return false;\n    }\n    // Firefox only allows fully loaded images to reference image maps\n    // https://stereochro.me/ideas/detecting-broken-images-js\n    if (!supports$2.focusBrokenImageMap && (!img.complete || !img.naturalHeight || img.offsetWidth <= 0 || img.offsetHeight <= 0)) {\n        return false;\n    }\n    // Firefox supports.can focus area elements even if they don't have an href attribute\n    if (!supports$2.focusAreaWithoutHref && !element.href) {\n        // Internet explorer supports.can focus area elements without href if either\n        // the area element or the image element has a tabindex attribute\n        return supports$2.focusAreaTabindex && hasTabindex || supports$2.focusAreaImgTabindex && img.hasAttribute(\"tabindex\");\n    }\n    // https://developer.mozilla.org/docs/Web/HTML/Element/img#attr-usemap\n    var childOfInteractive = getParents({\n        context: img\n    }).slice(1).some(function(_element) {\n        var name = _element.nodeName.toLowerCase();\n        return name === \"button\" || name === \"a\";\n    });\n    if (childOfInteractive) {\n        return false;\n    }\n    return true;\n}\nvar supports$3 = void 0;\n// https://www.w3.org/TR/html5/disabled-elements.html#concept-element-disabled\nvar disabledElementsPattern = void 0;\nvar disabledElements = {\n    input: true,\n    select: true,\n    textarea: true,\n    button: true,\n    fieldset: true,\n    form: true\n};\nfunction isNativeDisabledSupported(context) {\n    if (!supports$3) {\n        supports$3 = _supports();\n        if (supports$3.focusFieldsetDisabled) {\n            delete disabledElements.fieldset;\n        }\n        if (supports$3.focusFormDisabled) {\n            delete disabledElements.form;\n        }\n        disabledElementsPattern = new RegExp(\"^(\" + Object.keys(disabledElements).join(\"|\") + \")$\");\n    }\n    var element = contextToElement({\n        label: \"is/native-disabled-supported\",\n        context: context\n    });\n    var nodeName = element.nodeName.toLowerCase();\n    return Boolean(disabledElementsPattern.test(nodeName));\n}\nvar supports$4 = void 0;\nfunction isDisabledFieldset(element) {\n    var nodeName = element.nodeName.toLowerCase();\n    return nodeName === \"fieldset\" && element.disabled;\n}\nfunction isDisabledForm(element) {\n    var nodeName = element.nodeName.toLowerCase();\n    return nodeName === \"form\" && element.disabled;\n}\nfunction isDisabled(context) {\n    if (!supports$4) {\n        supports$4 = _supports();\n    }\n    var element = contextToElement({\n        label: \"is/disabled\",\n        context: context\n    });\n    if (element.hasAttribute(\"data-ally-disabled\")) {\n        // treat ally's element/disabled like the DOM native element.disabled\n        return true;\n    }\n    if (!isNativeDisabledSupported(element)) {\n        // non-form elements do not support the disabled attribute\n        return false;\n    }\n    if (element.disabled) {\n        // the element itself is disabled\n        return true;\n    }\n    var parents = getParents({\n        context: element\n    });\n    if (parents.some(isDisabledFieldset)) {\n        // a parental <fieldset> is disabld and inherits the state onto this element\n        return true;\n    }\n    if (!supports$4.focusFormDisabled && parents.some(isDisabledForm)) {\n        // a parental <form> is disabld and inherits the state onto this element\n        return true;\n    }\n    return false;\n}\nfunction isOnlyTabbableRules() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, _ref$except = _ref.except, except = _ref$except === undefined ? {\n        onlyFocusableBrowsingContext: false,\n        visible: false\n    } : _ref$except;\n    var element = contextToElement({\n        label: \"is/only-tabbable\",\n        resolveDocument: true,\n        context: context\n    });\n    if (!except.visible && !isVisible(element)) {\n        return false;\n    }\n    if (!except.onlyFocusableBrowsingContext && (platform.is.GECKO || platform.is.TRIDENT || platform.is.EDGE)) {\n        var frameElement = getFrameElement(element);\n        if (frameElement) {\n            if (tabindexValue(frameElement) < 0) {\n                // iframe[tabindex=\"-1\"] and object[tabindex=\"-1\"] inherit the\n                // tabbable demotion onto elements of their browsing contexts\n                return false;\n            }\n        }\n    }\n    var nodeName = element.nodeName.toLowerCase();\n    var tabindex = tabindexValue(element);\n    if (nodeName === \"label\" && platform.is.GECKO) {\n        // Firefox cannot focus, but tab to: label[tabindex=0]\n        return tabindex !== null && tabindex >= 0;\n    }\n    // SVG Elements were keyboard focusable but not script focusable before Firefox 51.\n    // Firefox 51 added the focus management DOM API (.focus and .blur) to SVGElement,\n    // see https://bugzilla.mozilla.org/show_bug.cgi?id=778654\n    if (platform.is.GECKO && element.ownerSVGElement && !element.focus) {\n        if (nodeName === \"a\" && element.hasAttribute(\"xlink:href\")) {\n            // any focusable child of <svg> cannot be focused, but tabbed to\n            if (platform.is.GECKO) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n// bind exceptions to an iterator callback\nisOnlyTabbableRules.except = function() {\n    var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var isOnlyTabbable = function isOnlyTabbable(context) {\n        return isOnlyTabbableRules({\n            context: context,\n            except: except\n        });\n    };\n    isOnlyTabbable.rules = isOnlyTabbableRules;\n    return isOnlyTabbable;\n};\n// provide isOnlyTabbable(context) as default iterator callback\nvar isOnlyTabbable = isOnlyTabbableRules.except({});\nvar supports$5 = void 0;\nfunction isOnlyFocusRelevant(element) {\n    var nodeName = element.nodeName.toLowerCase();\n    if (nodeName === \"embed\" || nodeName === \"keygen\") {\n        // embed is considered focus-relevant but not focusable\n        // see https://github.com/medialize/ally.js/issues/82\n        return true;\n    }\n    var _tabindex = tabindexValue(element);\n    if (element.shadowRoot && _tabindex === null) {\n        // ShadowDOM host elements *may* receive focus\n        // even though they are not considered focuable\n        return true;\n    }\n    if (nodeName === \"label\") {\n        // <label tabindex=\"0\"> is only tabbable in Firefox, not script-focusable\n        // there's no way to make an element focusable other than by adding a tabindex,\n        // and focus behavior of the label element seems hard-wired to ignore tabindex\n        // in some browsers (like Gecko, Blink and WebKit)\n        return !supports$5.focusLabelTabindex || _tabindex === null;\n    }\n    if (nodeName === \"legend\") {\n        return _tabindex === null;\n    }\n    if (supports$5.focusSvgFocusableAttribute && (element.ownerSVGElement || nodeName === \"svg\")) {\n        // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2\n        var focusableAttribute = element.getAttribute(\"focusable\");\n        return focusableAttribute && focusableAttribute === \"false\";\n    }\n    if (nodeName === \"img\" && element.hasAttribute(\"usemap\")) {\n        // Gecko, Trident and Edge do not allow an image with an image map and tabindex to be focused,\n        // it appears the tabindex is overruled so focus is still forwarded to the <map>\n        return _tabindex === null || !supports$5.focusImgUsemapTabindex;\n    }\n    if (nodeName === \"area\") {\n        // all <area>s are considered relevant,\n        // but only the valid <area>s are focusable\n        return !isValidArea(element);\n    }\n    return false;\n}\nfunction isFocusableRules() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, _ref$except = _ref.except, except = _ref$except === undefined ? {\n        disabled: false,\n        visible: false,\n        onlyTabbable: false\n    } : _ref$except;\n    if (!supports$5) {\n        supports$5 = _supports();\n    }\n    var _isOnlyTabbable = isOnlyTabbable.rules.except({\n        onlyFocusableBrowsingContext: true,\n        visible: except.visible\n    });\n    var element = contextToElement({\n        label: \"is/focusable\",\n        resolveDocument: true,\n        context: context\n    });\n    var focusRelevant = isFocusRelevant.rules({\n        context: element,\n        except: except\n    });\n    if (!focusRelevant || isOnlyFocusRelevant(element)) {\n        return false;\n    }\n    if (!except.disabled && isDisabled(element)) {\n        return false;\n    }\n    if (!except.onlyTabbable && _isOnlyTabbable(element)) {\n        // some elements may be keyboard focusable, but not script focusable\n        return false;\n    }\n    // elements that are not rendered, cannot be focused\n    if (!except.visible) {\n        var visibilityOptions = {\n            context: element,\n            except: {}\n        };\n        if (supports$5.focusInHiddenIframe) {\n            // WebKit and Blink can focus content in hidden <iframe> and <object>\n            visibilityOptions.except.browsingContext = true;\n        }\n        if (supports$5.focusObjectSvgHidden) {\n            // Blink allows focusing the object element, even if it has visibility: hidden;\n            // @browser-issue Blink https://code.google.com/p/chromium/issues/detail?id=586191\n            var _nodeName2 = element.nodeName.toLowerCase();\n            if (_nodeName2 === \"object\") {\n                visibilityOptions.except.cssVisibility = true;\n            }\n        }\n        if (!isVisible.rules(visibilityOptions)) {\n            return false;\n        }\n    }\n    var frameElement = getFrameElement(element);\n    if (frameElement) {\n        var _nodeName = frameElement.nodeName.toLowerCase();\n        if (_nodeName === \"object\" && !supports$5.focusInZeroDimensionObject) {\n            if (!frameElement.offsetWidth || !frameElement.offsetHeight) {\n                // WebKit can not focus content in <object> if it doesn't have dimensions\n                return false;\n            }\n        }\n    }\n    var nodeName = element.nodeName.toLowerCase();\n    if (nodeName === \"svg\" && supports$5.focusSvgInIframe && !frameElement && element.getAttribute(\"tabindex\") === null) {\n        return false;\n    }\n    return true;\n}\n// bind exceptions to an iterator callback\nisFocusableRules.except = function() {\n    var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var isFocusable = function isFocusable(context) {\n        return isFocusableRules({\n            context: context,\n            except: except\n        });\n    };\n    isFocusable.rules = isFocusableRules;\n    return isFocusable;\n};\n// provide isFocusRelevant(context) as default iterator callback\nvar isFocusable = isFocusableRules.except({});\nfunction createFilter(condition) {\n    // see https://developer.mozilla.org/docs/Web/API/NodeFilter\n    var filter = function filter(node) {\n        if (node.shadowRoot) {\n            // return ShadowRoot elements regardless of them being focusable,\n            // so they can be walked recursively later\n            return NodeFilter.FILTER_ACCEPT;\n        }\n        if (condition(node)) {\n            // finds elements that could have been found by document.querySelectorAll()\n            return NodeFilter.FILTER_ACCEPT;\n        }\n        return NodeFilter.FILTER_SKIP;\n    };\n    // IE requires a function, Browsers require {acceptNode: function}\n    // see http://www.bennadel.com/blog/2607-finding-html-comment-nodes-in-the-dom-using-treewalker.htm\n    filter.acceptNode = filter;\n    return filter;\n}\nvar PossiblyFocusableFilter = createFilter(isFocusRelevant);\nfunction queryFocusableStrict() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, includeContext = _ref.includeContext, includeOnlyTabbable = _ref.includeOnlyTabbable, strategy = _ref.strategy;\n    if (!context) {\n        context = document.documentElement;\n    }\n    var _isFocusable = isFocusable.rules.except({\n        onlyTabbable: includeOnlyTabbable\n    });\n    var _document = getDocument(context);\n    // see https://developer.mozilla.org/docs/Web/API/Document/createTreeWalker\n    var walker = _document.createTreeWalker(context, NodeFilter.SHOW_ELEMENT, strategy === \"all\" ? PossiblyFocusableFilter : createFilter(_isFocusable), false);\n    var list = [];\n    while(walker.nextNode()){\n        if (walker.currentNode.shadowRoot) {\n            if (_isFocusable(walker.currentNode)) {\n                list.push(walker.currentNode);\n            }\n            list = list.concat(queryFocusableStrict({\n                context: walker.currentNode.shadowRoot,\n                includeOnlyTabbable: includeOnlyTabbable,\n                strategy: strategy\n            }));\n        } else {\n            list.push(walker.currentNode);\n        }\n    }\n    // add context if requested and focusable\n    if (includeContext) {\n        if (strategy === \"all\") {\n            if (isFocusRelevant(context)) {\n                list.unshift(context);\n            }\n        } else if (_isFocusable(context)) {\n            list.unshift(context);\n        }\n    }\n    return list;\n}\n// NOTE: this selector MUST *never* be used directly,\nvar supports$6 = void 0;\nvar selector$1 = void 0;\nfunction selector$2() {\n    if (!supports$6) {\n        supports$6 = _supports();\n    }\n    if (typeof selector$1 === \"string\") {\n        return selector$1;\n    }\n    // https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute\n    selector$1 = \"\" + // IE11 supports.can focus <table> and <td>\n    (supports$6.focusTable ? \"table, td,\" : \"\") + // IE11 supports.can focus <fieldset>\n    (supports$6.focusFieldset ? \"fieldset,\" : \"\") + // Namespace problems of [xlink:href] explained in https://stackoverflow.com/a/23047888/515124\n    // svg a[*|href] does not match in IE9, but since we're filtering\n    // through is/focusable we can include all <a> from SVG\n    \"svg a,\" + // may behave as 'svg, svg *,' in chrome as *every* svg element with a focus event listener is focusable\n    // navigational elements\n    \"a[href],\" + // validity determined by is/valid-area.js\n    \"area[href],\" + // validity determined by is/disabled.js\n    \"input, select, textarea, button,\" + // browsing context containers\n    \"iframe, object, embed,\" + // interactive content\n    \"keygen,\" + (supports$6.focusAudioWithoutControls ? \"audio,\" : \"audio[controls],\") + (supports$6.focusVideoWithoutControls ? \"video,\" : \"video[controls],\") + (supports$6.focusSummary ? \"summary,\" : \"\") + // validity determined by is/valid-tabindex.js\n    \"[tabindex],\" + // editing hosts\n    \"[contenteditable]\";\n    // where ShadowDOM is supported, we also want the shadowed focusable elements (via \">>>\" or \"/deep/\")\n    selector$1 = selectInShadows(selector$1);\n    return selector$1;\n}\nfunction queryFocusableQuick() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, includeContext = _ref.includeContext, includeOnlyTabbable = _ref.includeOnlyTabbable;\n    var _selector = selector$2();\n    var elements = context.querySelectorAll(_selector);\n    // the selector potentially matches more than really is focusable\n    var _isFocusable = isFocusable.rules.except({\n        onlyTabbable: includeOnlyTabbable\n    });\n    var result = [].filter.call(elements, _isFocusable);\n    // add context if requested and focusable\n    if (includeContext && _isFocusable(context)) {\n        result.unshift(context);\n    }\n    return result;\n}\nfunction queryFocusable() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, includeContext = _ref.includeContext, includeOnlyTabbable = _ref.includeOnlyTabbable, _ref$strategy = _ref.strategy, strategy = _ref$strategy === undefined ? \"quick\" : _ref$strategy;\n    var element = contextToElement({\n        label: \"query/focusable\",\n        resolveDocument: true,\n        defaultToDocument: true,\n        context: context\n    });\n    var options = {\n        context: element,\n        includeContext: includeContext,\n        includeOnlyTabbable: includeOnlyTabbable,\n        strategy: strategy\n    };\n    if (strategy === \"quick\") {\n        return queryFocusableQuick(options);\n    } else if (strategy === \"strict\" || strategy === \"all\") {\n        return queryFocusableStrict(options);\n    }\n    throw new TypeError('query/focusable requires option.strategy to be one of [\"quick\", \"strict\", \"all\"]');\n}\nvar supports$7 = void 0;\n// Internet Explorer 11 considers fieldset, table, td focusable, but not tabbable\n// Internet Explorer 11 considers body to have [tabindex=0], but does not allow tabbing to it\nvar focusableElementsPattern = /^(fieldset|table|td|body)$/;\nfunction isTabbableRules() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, _ref$except = _ref.except, except = _ref$except === undefined ? {\n        flexbox: false,\n        scrollable: false,\n        shadow: false,\n        visible: false,\n        onlyTabbable: false\n    } : _ref$except;\n    if (!supports$7) {\n        supports$7 = _supports();\n    }\n    var element = contextToElement({\n        label: \"is/tabbable\",\n        resolveDocument: true,\n        context: context\n    });\n    if (platform.is.BLINK && platform.is.ANDROID && platform.majorVersion > 42) {\n        // External keyboard support worked fine in CHrome 42, but stopped working in Chrome 45.\n        // The on-screen keyboard does not provide a way to focus the next input element (like iOS does).\n        // That leaves us with no option to advance focus by keyboard, ergo nothing is tabbable (keyboard focusable).\n        return false;\n    }\n    var frameElement = getFrameElement(element);\n    if (frameElement) {\n        if (platform.is.WEBKIT && platform.is.IOS) {\n            // iOS only does not consider anything from another browsing context keyboard focusable\n            return false;\n        }\n        // iframe[tabindex=\"-1\"] and object[tabindex=\"-1\"] inherit the\n        // tabbable demotion onto elements of their browsing contexts\n        if (tabindexValue(frameElement) < 0) {\n            return false;\n        }\n        if (!except.visible && (platform.is.BLINK || platform.is.WEBKIT) && !isVisible(frameElement)) {\n            // Blink and WebKit consider elements in hidden browsing contexts focusable, but not tabbable\n            return false;\n        }\n        // Webkit and Blink don't consider anything in <object> tabbable\n        // Blink fixed that fixed in Chrome 54, Opera 41\n        var frameNodeName = frameElement.nodeName.toLowerCase();\n        if (frameNodeName === \"object\") {\n            var isFixedBlink = platform.name === \"Chrome\" && platform.majorVersion >= 54 || platform.name === \"Opera\" && platform.majorVersion >= 41;\n            if (platform.is.WEBKIT || platform.is.BLINK && !isFixedBlink) {\n                return false;\n            }\n        }\n    }\n    var nodeName = element.nodeName.toLowerCase();\n    var _tabindex = tabindexValue(element);\n    var tabindex = _tabindex === null ? null : _tabindex >= 0;\n    if (platform.is.EDGE && platform.majorVersion >= 14 && frameElement && element.ownerSVGElement && _tabindex < 0) {\n        // Edge 14+ considers <a xlink:href=\"â€¦\" tabindex=\"-1\"> keyboard focusable\n        // if the element is in a nested browsing context\n        return true;\n    }\n    var hasTabbableTabindexOrNone = tabindex !== false;\n    var hasTabbableTabindex = _tabindex !== null && _tabindex >= 0;\n    // NOTE: Firefox 31 considers [contenteditable] to have [tabindex=-1], but allows tabbing to it\n    // fixed in Firefox 40 the latest - https://bugzilla.mozilla.org/show_bug.cgi?id=1185657\n    if (element.hasAttribute(\"contenteditable\")) {\n        // tabbing can still be disabled by explicitly providing [tabindex=\"-1\"]\n        return hasTabbableTabindexOrNone;\n    }\n    if (focusableElementsPattern.test(nodeName) && tabindex !== true) {\n        return false;\n    }\n    if (platform.is.WEBKIT && platform.is.IOS) {\n        // iOS only considers a hand full of elements tabbable (keyboard focusable)\n        // this holds true even with external keyboards\n        var potentiallyTabbable = nodeName === \"input\" && element.type === \"text\" || element.type === \"password\" || nodeName === \"select\" || nodeName === \"textarea\" || element.hasAttribute(\"contenteditable\");\n        if (!potentiallyTabbable) {\n            var style = window.getComputedStyle(element, null);\n            potentiallyTabbable = isUserModifyWritable(style);\n        }\n        if (!potentiallyTabbable) {\n            return false;\n        }\n    }\n    if (nodeName === \"use\" && _tabindex !== null) {\n        if (platform.is.BLINK || platform.is.WEBKIT && platform.majorVersion === 9) {\n            // In Chrome and Safari 9 the <use> element is keyboard focusable even for tabindex=\"-1\"\n            return true;\n        }\n    }\n    if (elementMatches(element, \"svg a\") && element.hasAttribute(\"xlink:href\")) {\n        if (hasTabbableTabindexOrNone) {\n            // in Trident and Gecko SVGElement does not handle the tabIndex property properly\n            return true;\n        }\n        if (element.focus && !supports$7.focusSvgNegativeTabindexAttribute) {\n            // Firefox 51 and 52 treat any natively tabbable SVG element with\n            // tabindex=\"-1\" as tabbable and everything else as inert\n            // see https://bugzilla.mozilla.org/show_bug.cgi?id=1302340\n            return true;\n        }\n    }\n    if (nodeName === \"svg\" && supports$7.focusSvgInIframe && hasTabbableTabindexOrNone) {\n        return true;\n    }\n    if (platform.is.TRIDENT || platform.is.EDGE) {\n        if (nodeName === \"svg\") {\n            if (supports$7.focusSvg) {\n                // older Internet Explorers consider <svg> keyboard focusable\n                // unless they have focsable=\"false\", but then they wouldn't\n                // be focusable and thus not even reach this filter\n                return true;\n            }\n            // elements that have [focusable] are automatically keyboard focusable regardless of the attribute's value\n            return element.hasAttribute(\"focusable\") || hasTabbableTabindex;\n        }\n        if (element.ownerSVGElement) {\n            if (supports$7.focusSvgTabindexAttribute && hasTabbableTabindex) {\n                return true;\n            }\n            // elements that have [focusable] are automatically keyboard focusable regardless of the attribute's value\n            return element.hasAttribute(\"focusable\");\n        }\n    }\n    if (element.tabIndex === undefined) {\n        return Boolean(except.onlyTabbable);\n    }\n    if (nodeName === \"audio\") {\n        if (!element.hasAttribute(\"controls\")) {\n            // In Internet Explorer the <audio> element is focusable, but not tabbable, and tabIndex property is wrong\n            return false;\n        } else if (platform.is.BLINK) {\n            // In Chrome <audio controls tabindex=\"-1\"> remains keyboard focusable\n            return true;\n        }\n    }\n    if (nodeName === \"video\") {\n        if (!element.hasAttribute(\"controls\")) {\n            if (platform.is.TRIDENT || platform.is.EDGE) {\n                // In Internet Explorer and Edge the <video> element is focusable, but not tabbable, and tabIndex property is wrong\n                return false;\n            }\n        } else if (platform.is.BLINK || platform.is.GECKO) {\n            // In Chrome and Firefox <video controls tabindex=\"-1\"> remains keyboard focusable\n            return true;\n        }\n    }\n    if (nodeName === \"object\") {\n        if (platform.is.BLINK || platform.is.WEBKIT) {\n            // In all Blink and WebKit based browsers <embed> and <object> are never keyboard focusable, even with tabindex=\"0\" set\n            return false;\n        }\n    }\n    if (nodeName === \"iframe\") {\n        // In Internet Explorer all iframes are only focusable\n        // In WebKit, Blink and Gecko iframes may be tabbable depending on content.\n        // Since we can't reliably investigate iframe documents because of the\n        // SameOriginPolicy, we're declaring everything only focusable.\n        return false;\n    }\n    if (!except.scrollable && platform.is.GECKO) {\n        // Firefox considers scrollable containers keyboard focusable,\n        // even though their tabIndex property is -1\n        var _style = window.getComputedStyle(element, null);\n        if (hasCssOverflowScroll(_style)) {\n            return hasTabbableTabindexOrNone;\n        }\n    }\n    if (platform.is.TRIDENT || platform.is.EDGE) {\n        // IE and Edge degrade <area> to script focusable, if the image\n        // using the <map> has been given tabindex=\"-1\"\n        if (nodeName === \"area\") {\n            var img = getImageOfArea(element);\n            if (img && tabindexValue(img) < 0) {\n                return false;\n            }\n        }\n        var _style2 = window.getComputedStyle(element, null);\n        if (isUserModifyWritable(_style2)) {\n            // prevent being swallowed by the overzealous isScrollableContainer() below\n            return element.tabIndex >= 0;\n        }\n        if (!except.flexbox && hasCssDisplayFlex(_style2)) {\n            if (_tabindex !== null) {\n                return hasTabbableTabindex;\n            }\n            return isFocusRelevantWithoutFlexbox(element) && isTabbableWithoutFlexbox(element);\n        }\n        // IE considers scrollable containers script focusable only,\n        // even though their tabIndex property is 0\n        if (isScrollableContainer(element, nodeName)) {\n            return false;\n        }\n        var parent = element.parentElement;\n        if (parent) {\n            var parentNodeName = parent.nodeName.toLowerCase();\n            var parentStyle = window.getComputedStyle(parent, null);\n            // IE considers scrollable bodies script focusable only,\n            if (isScrollableContainer(parent, nodeName, parentNodeName, parentStyle)) {\n                return false;\n            }\n            // Children of focusable elements with display:flex are focusable in IE10-11,\n            // even though their tabIndex property suggests otherwise\n            if (hasCssDisplayFlex(parentStyle)) {\n                // value of tabindex takes precedence\n                return hasTabbableTabindex;\n            }\n        }\n    }\n    // https://www.w3.org/WAI/PF/aria-practices/#focus_tabindex\n    return element.tabIndex >= 0;\n}\n// bind exceptions to an iterator callback\nisTabbableRules.except = function() {\n    var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var isTabbable = function isTabbable(context) {\n        return isTabbableRules({\n            context: context,\n            except: except\n        });\n    };\n    isTabbable.rules = isTabbableRules;\n    return isTabbable;\n};\nvar isFocusRelevantWithoutFlexbox = isFocusRelevant.rules.except({\n    flexbox: true\n});\nvar isTabbableWithoutFlexbox = isTabbableRules.except({\n    flexbox: true\n});\n// provide isTabbable(context) as default iterator callback\nvar isTabbable = isTabbableRules.except({});\nfunction queryTabbable() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, includeContext = _ref.includeContext, includeOnlyTabbable = _ref.includeOnlyTabbable, strategy = _ref.strategy;\n    var _isTabbable = isTabbable.rules.except({\n        onlyTabbable: includeOnlyTabbable\n    });\n    return queryFocusable({\n        context: context,\n        includeContext: includeContext,\n        includeOnlyTabbable: includeOnlyTabbable,\n        strategy: strategy\n    }).filter(_isTabbable);\n}\n// sorts a list of elements according to their order in the DOM\nfunction compareDomPosition(a, b) {\n    return a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;\n}\nfunction sortDomOrder(elements) {\n    return elements.sort(compareDomPosition);\n}\nfunction getFirstSuccessorOffset(list, target) {\n    // find the first element that comes AFTER the target element\n    return findIndex(list, function(element) {\n        return target.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_FOLLOWING;\n    });\n}\nfunction findInsertionOffsets(list, elements, resolveElement) {\n    // instead of mutating the elements list directly, remember position and map\n    // to inject later, when we can do this more efficiently\n    var insertions = [];\n    elements.forEach(function(element) {\n        var replace = true;\n        var offset = list.indexOf(element);\n        if (offset === -1) {\n            // element is not in target list\n            offset = getFirstSuccessorOffset(list, element);\n            replace = false;\n        }\n        if (offset === -1) {\n            // there is no successor in the tabsequence,\n            // meaning the image must be the last element\n            offset = list.length;\n        }\n        // allow the consumer to replace the injected element\n        var injections = nodeArray(resolveElement ? resolveElement(element) : element);\n        if (!injections.length) {\n            // we can't inject zero elements\n            return;\n        }\n        insertions.push({\n            offset: offset,\n            replace: replace,\n            elements: injections\n        });\n    });\n    return insertions;\n}\nfunction insertElementsAtOffsets(list, insertions) {\n    // remember the number of elements we have already injected\n    // so we account for the caused index offset\n    var inserted = 0;\n    // make sure that we insert the elements in sequence,\n    // otherwise the offset compensation won't work\n    insertions.sort(function(a, b) {\n        return a.offset - b.offset;\n    });\n    insertions.forEach(function(insertion) {\n        // array.splice has an annoying function signature :(\n        var remove = insertion.replace ? 1 : 0;\n        var args = [\n            insertion.offset + inserted,\n            remove\n        ].concat(insertion.elements);\n        list.splice.apply(list, args);\n        inserted += insertion.elements.length - remove;\n    });\n}\nfunction mergeInDomOrder() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, list = _ref.list, elements = _ref.elements, resolveElement = _ref.resolveElement;\n    // operate on a copy so we don't mutate the original array\n    var _list = list.slice(0);\n    // make sure the elements we're injecting are provided in DOM order\n    var _elements = nodeArray(elements).slice(0);\n    sortDomOrder(_elements);\n    // find the offsets within the target array (list) at which to inject\n    // each individual element (from elements)\n    var insertions = findInsertionOffsets(_list, _elements, resolveElement);\n    // actually inject the elements into the target array at the identified positions\n    insertElementsAtOffsets(_list, insertions);\n    return _list;\n}\nvar _createClass = function() {\n    function defineProperties(target, props) {\n        for(var i = 0; i < props.length; i++){\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n        }\n    }\n    return function(Constructor, protoProps, staticProps) {\n        if (protoProps) defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) defineProperties(Constructor, staticProps);\n        return Constructor;\n    };\n}();\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nvar Maps = function() {\n    function Maps(context) {\n        _classCallCheck(this, Maps);\n        this._document = getDocument(context);\n        this.maps = {};\n    }\n    _createClass(Maps, [\n        {\n            key: \"getAreasFor\",\n            value: function getAreasFor(name) {\n                if (!this.maps[name]) {\n                    // the map is not defined within the context, so we\n                    // have to go find it elsewhere in the document\n                    this.addMapByName(name);\n                }\n                return this.maps[name];\n            }\n        },\n        {\n            key: \"addMapByName\",\n            value: function addMapByName(name) {\n                var map = getMapByName(name, this._document);\n                if (!map) {\n                    // if there is no map, the img[usemap] wasn't doing anything anyway\n                    return;\n                }\n                this.maps[map.name] = queryTabbable({\n                    context: map\n                });\n            }\n        },\n        {\n            key: \"extractAreasFromList\",\n            value: function extractAreasFromList(elements) {\n                // remove all <area> elements from the elements list,\n                // but put them the map for later retrieval\n                return elements.filter(function(element) {\n                    var nodeName = element.nodeName.toLowerCase();\n                    if (nodeName !== \"area\") {\n                        return true;\n                    }\n                    var map = element.parentNode;\n                    if (!this.maps[map.name]) {\n                        this.maps[map.name] = [];\n                    }\n                    this.maps[map.name].push(element);\n                    return false;\n                }, this);\n            }\n        }\n    ]);\n    return Maps;\n}();\nfunction sortArea(elements, context) {\n    // images - unless they are focusable themselves, likely not\n    // part of the elements list, so we'll have to find them and\n    // sort them into the elements list manually\n    var usemaps = context.querySelectorAll(\"img[usemap]\");\n    var maps = new Maps(context);\n    // remove all <area> elements from the elements list,\n    // but put them the map for later retrieval\n    var _elements = maps.extractAreasFromList(elements);\n    if (!usemaps.length) {\n        // the context does not contain any <area>s so no need\n        // to replace anything, just remove any maps\n        return _elements;\n    }\n    return mergeInDomOrder({\n        list: _elements,\n        elements: usemaps,\n        resolveElement: function resolveElement(image) {\n            var name = image.getAttribute(\"usemap\").slice(1);\n            return maps.getAreasFor(name);\n        }\n    });\n}\nvar _createClass$1 = function() {\n    function defineProperties(target, props) {\n        for(var i = 0; i < props.length; i++){\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n        }\n    }\n    return function(Constructor, protoProps, staticProps) {\n        if (protoProps) defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) defineProperties(Constructor, staticProps);\n        return Constructor;\n    };\n}();\nfunction _classCallCheck$1(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nvar Shadows = function() {\n    function Shadows(context, sortElements) {\n        _classCallCheck$1(this, Shadows);\n        // document context we're working with\n        this.context = context;\n        // callback that sorts an array of elements\n        this.sortElements = sortElements;\n        // reference to create unique IDs for each ShadowHost\n        this.hostCounter = 1;\n        // reference map for child-ShadowHosts of a ShadowHost\n        this.inHost = {};\n        // reference map for child-ShadowHost of the document\n        this.inDocument = [];\n        // reference map for ShadowHosts\n        this.hosts = {};\n        // reference map for tabbable elements of a ShadowHost\n        this.elements = {};\n    }\n    // remember which hosts we have to sort within later\n    _createClass$1(Shadows, [\n        {\n            key: \"_registerHost\",\n            value: function _registerHost(host) {\n                if (host._sortingId) {\n                    return;\n                }\n                // make the ShadowHost identifiable (see cleanup() for undo)\n                host._sortingId = \"shadow-\" + this.hostCounter++;\n                this.hosts[host._sortingId] = host;\n                // hosts may contain other hosts\n                var parentHost = getShadowHost({\n                    context: host\n                });\n                if (parentHost) {\n                    this._registerHost(parentHost);\n                    this._registerHostParent(host, parentHost);\n                } else {\n                    this.inDocument.push(host);\n                }\n            }\n        },\n        {\n            key: \"_registerHostParent\",\n            value: function _registerHostParent(host, parent) {\n                if (!this.inHost[parent._sortingId]) {\n                    this.inHost[parent._sortingId] = [];\n                }\n                this.inHost[parent._sortingId].push(host);\n            }\n        },\n        {\n            key: \"_registerElement\",\n            value: function _registerElement(element, host) {\n                if (!this.elements[host._sortingId]) {\n                    this.elements[host._sortingId] = [];\n                }\n                this.elements[host._sortingId].push(element);\n            }\n        },\n        {\n            key: \"extractElements\",\n            value: function extractElements(elements) {\n                return elements.filter(function(element) {\n                    var host = getShadowHost({\n                        context: element\n                    });\n                    if (!host) {\n                        return true;\n                    }\n                    this._registerHost(host);\n                    this._registerElement(element, host);\n                    return false;\n                }, this);\n            }\n        },\n        {\n            key: \"sort\",\n            value: function sort(elements) {\n                var _elements = this._injectHosts(elements);\n                _elements = this._replaceHosts(_elements);\n                this._cleanup();\n                return _elements;\n            }\n        },\n        {\n            key: \"_injectHosts\",\n            value: function _injectHosts(elements) {\n                Object.keys(this.hosts).forEach(function(_sortingId) {\n                    var _list = this.elements[_sortingId];\n                    var _elements = this.inHost[_sortingId];\n                    var _context = this.hosts[_sortingId].shadowRoot;\n                    this.elements[_sortingId] = this._merge(_list, _elements, _context);\n                }, this);\n                return this._merge(elements, this.inDocument, this.context);\n            }\n        },\n        {\n            key: \"_merge\",\n            value: function _merge(list, elements, context) {\n                var merged = mergeInDomOrder({\n                    list: list,\n                    elements: elements\n                });\n                return this.sortElements(merged, context);\n            }\n        },\n        {\n            key: \"_replaceHosts\",\n            value: function _replaceHosts(elements) {\n                return mergeInDomOrder({\n                    list: elements,\n                    elements: this.inDocument,\n                    resolveElement: this._resolveHostElement.bind(this)\n                });\n            }\n        },\n        {\n            key: \"_resolveHostElement\",\n            value: function _resolveHostElement(host) {\n                var merged = mergeInDomOrder({\n                    list: this.elements[host._sortingId],\n                    elements: this.inHost[host._sortingId],\n                    resolveElement: this._resolveHostElement.bind(this)\n                });\n                var _tabindex = tabindexValue(host);\n                if (_tabindex !== null && _tabindex > -1) {\n                    return [\n                        host\n                    ].concat(merged);\n                }\n                return merged;\n            }\n        },\n        {\n            key: \"_cleanup\",\n            value: function _cleanup() {\n                // remove those identifers we put on the ShadowHost to avoid using Map()\n                Object.keys(this.hosts).forEach(function(key) {\n                    delete this.hosts[key]._sortingId;\n                }, this);\n            }\n        }\n    ]);\n    return Shadows;\n}();\nfunction sortShadowed(elements, context, sortElements) {\n    var shadows = new Shadows(context, sortElements);\n    var _elements = shadows.extractElements(elements);\n    if (_elements.length === elements.length) {\n        // no shadowed content found, no need to continue\n        return sortElements(elements);\n    }\n    return shadows.sort(_elements);\n}\nfunction sortTabindex(elements) {\n    // https://developer.mozilla.org/docs/Web/API/HTMLElement.tabIndex\n    // elements with tabIndex \"0\" (including tabbableElements without tabIndex) should be navigated in the order they appear.\n    // elements with a positive tabIndex:\n    //   Elements that have identical tabIndexes should be navigated in the order they appear.\n    //   Navigation proceeds from the lowest tabIndex to the highest tabIndex.\n    // NOTE: sort implementation may be unstable and thus mess up DOM order,\n    // that's why we build a map that's being sorted instead. If we were able to rely\n    // on a stable sorting algorithm, sortTabindex() could be as simple as\n    // elements.sort(function(a, b) { return a.tabIndex - b.tabIndex; });\n    // at this time Chrome does not use a stable sorting algorithm\n    // see http://blog.rodneyrehm.de/archives/14-Sorting-Were-Doing-It-Wrong.html#stability\n    // NOTE: compareDocumentPosition seemed like more overhead than just sorting this with buckets\n    // https://developer.mozilla.org/docs/Web/API/Node.compareDocumentPosition\n    var map = {};\n    var indexes = [];\n    var normal = elements.filter(function(element) {\n        // in Trident and Gecko SVGElement does not know about the tabIndex property\n        var tabIndex = element.tabIndex;\n        if (tabIndex === undefined) {\n            tabIndex = tabindexValue(element);\n        }\n        // extract elements that don't need sorting\n        if (tabIndex <= 0 || tabIndex === null || tabIndex === undefined) {\n            return true;\n        }\n        if (!map[tabIndex]) {\n            // create sortable bucket for dom-order-preservation of elements with the same tabIndex\n            map[tabIndex] = [];\n            // maintain a list of unique tabIndexes\n            indexes.push(tabIndex);\n        }\n        // sort element into the proper bucket\n        map[tabIndex].push(element);\n        // element moved to sorting map, so not \"normal\" anymore\n        return false;\n    });\n    // sort the tabindex ascending,\n    // then resolve them to their appropriate buckets,\n    // then flatten the array of arrays to an array\n    var _elements = indexes.sort().map(function(tabIndex) {\n        return map[tabIndex];\n    }).reduceRight(function(previous, current) {\n        return current.concat(previous);\n    }, normal);\n    return _elements;\n}\nvar supports$8 = void 0;\nfunction moveContextToBeginning(elements, context) {\n    var pos = elements.indexOf(context);\n    if (pos > 0) {\n        var tmp = elements.splice(pos, 1);\n        return tmp.concat(elements);\n    }\n    return elements;\n}\nfunction sortElements(elements, _context) {\n    if (supports$8.tabsequenceAreaAtImgPosition) {\n        // Some browsers sort <area> in DOM order, some place the <area>s\n        // where the <img> referecing them would've been in DOM order.\n        // https://github.com/medialize/ally.js/issues/5\n        elements = sortArea(elements, _context);\n    }\n    elements = sortTabindex(elements);\n    return elements;\n}\nfunction queryTabsequence() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, includeContext = _ref.includeContext, includeOnlyTabbable = _ref.includeOnlyTabbable, strategy = _ref.strategy;\n    if (!supports$8) {\n        supports$8 = _supports();\n    }\n    var _context = nodeArray(context)[0] || document.documentElement;\n    var elements = queryTabbable({\n        context: _context,\n        includeContext: includeContext,\n        includeOnlyTabbable: includeOnlyTabbable,\n        strategy: strategy\n    });\n    if (document.body.createShadowRoot && platform.is.BLINK) {\n        // sort tabindex localized to shadow dom\n        // see https://github.com/medialize/ally.js/issues/6\n        elements = sortShadowed(elements, _context, sortElements);\n    } else {\n        elements = sortElements(elements, _context);\n    }\n    if (includeContext) {\n        // if we include the context itself, it has to be the first\n        // element of the sequence\n        elements = moveContextToBeginning(elements, _context);\n    }\n    return elements;\n}\n// codes mostly cloned from https://github.com/keithamus/jwerty/blob/master/jwerty.js\n// deliberately not exposing characters like <,.-#* because they vary *wildly*\n// across keyboard layouts and may cause various problems\n// (e.g. \"*\" is \"Shift +\" on a German Mac keyboard)\n// (e.g. \"@\" is \"Alt L\" on a German Mac keyboard)\nvar keycode = {\n    // Element Focus\n    tab: 9,\n    // Navigation\n    left: 37,\n    up: 38,\n    right: 39,\n    down: 40,\n    pageUp: 33,\n    \"page-up\": 33,\n    pageDown: 34,\n    \"page-down\": 34,\n    end: 35,\n    home: 36,\n    // Action\n    enter: 13,\n    escape: 27,\n    space: 32,\n    // Modifier\n    shift: 16,\n    capsLock: 20,\n    \"caps-lock\": 20,\n    ctrl: 17,\n    alt: 18,\n    meta: 91,\n    // in firefox: 224\n    // on mac (chrome): meta-left=91, meta-right=93\n    // on win (IE11): meta-left=91, meta-right=92\n    pause: 19,\n    // Content Manipulation\n    insert: 45,\n    delete: 46,\n    backspace: 8,\n    // the same logical key may be identified through different keyCodes\n    _alias: {\n        91: [\n            92,\n            93,\n            224\n        ]\n    }\n};\n// Function keys (112 - 137)\n// NOTE: not every keyboard knows F13+\nfor(var n = 1; n < 26; n++){\n    keycode[\"f\" + n] = n + 111;\n}\n// Number keys (48-57, numpad 96-105)\n// NOTE: not every keyboard knows num-0+\nfor(var _n = 0; _n < 10; _n++){\n    var code = _n + 48;\n    var numCode = _n + 96;\n    keycode[_n] = code;\n    keycode[\"num-\" + _n] = numCode;\n    keycode._alias[code] = [\n        numCode\n    ];\n}\n// Latin characters (65 - 90)\nfor(var _n2 = 0; _n2 < 26; _n2++){\n    var _code = _n2 + 65;\n    var name$1 = String.fromCharCode(_code).toLowerCase();\n    keycode[name$1] = _code;\n}\nvar modifier = {\n    alt: \"altKey\",\n    ctrl: \"ctrlKey\",\n    meta: \"metaKey\",\n    shift: \"shiftKey\"\n};\nvar modifierSequence = Object.keys(modifier).map(function(name) {\n    return modifier[name];\n});\nfunction createExpectedModifiers(ignoreModifiers) {\n    var value = ignoreModifiers ? null : false;\n    return {\n        altKey: value,\n        ctrlKey: value,\n        metaKey: value,\n        shiftKey: value\n    };\n}\nfunction resolveModifiers(modifiers) {\n    var ignoreModifiers = modifiers.indexOf(\"*\") !== -1;\n    var expected = createExpectedModifiers(ignoreModifiers);\n    modifiers.forEach(function(token) {\n        if (token === \"*\") {\n            // we've already covered the all-in operator\n            return;\n        }\n        // we want the modifier pressed\n        var value = true;\n        var operator = token.slice(0, 1);\n        if (operator === \"?\") {\n            // we don't care if the modifier is pressed\n            value = null;\n        } else if (operator === \"!\") {\n            // we do not want the modifier pressed\n            value = false;\n        }\n        if (value !== true) {\n            // compensate for the modifier's operator\n            token = token.slice(1);\n        }\n        var propertyName = modifier[token];\n        if (!propertyName) {\n            throw new TypeError('Unknown modifier \"' + token + '\"');\n        }\n        expected[propertyName] = value;\n    });\n    return expected;\n}\nfunction resolveKey(key) {\n    var code = keycode[key] || parseInt(key, 10);\n    if (!code || typeof code !== \"number\" || isNaN(code)) {\n        throw new TypeError('Unknown key \"' + key + '\"');\n    }\n    return [\n        code\n    ].concat(keycode._alias[code] || []);\n}\nfunction matchModifiers(expected, event) {\n    // returns true on match\n    return !modifierSequence.some(function(prop) {\n        // returns true on mismatch\n        return typeof expected[prop] === \"boolean\" && Boolean(event[prop]) !== expected[prop];\n    });\n}\nfunction keyBinding(text) {\n    return text.split(/\\s+/).map(function(_text) {\n        var tokens = _text.split(\"+\");\n        var _modifiers = resolveModifiers(tokens.slice(0, -1));\n        var _keyCodes = resolveKey(tokens.slice(-1));\n        return {\n            keyCodes: _keyCodes,\n            modifiers: _modifiers,\n            matchModifiers: matchModifiers.bind(null, _modifiers)\n        };\n    });\n}\n// Node.compareDocumentPosition is available since IE9\n// see https://developer.mozilla.org/docs/Web/API/Node.compareDocumentPosition\n// callback returns true when element is contained by parent or is the parent suited for use with Array.some()\n/*\n  USAGE:\n    var isChildOf = getParentComparator({parent: someNode});\n    listOfElements.some(isChildOf)\n*/ function getParentComparator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, parent = _ref.parent, element = _ref.element, includeSelf = _ref.includeSelf;\n    if (parent) {\n        return function isChildOf(node) {\n            return Boolean(includeSelf && node === parent || parent.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY);\n        };\n    } else if (element) {\n        return function isParentOf(node) {\n            return Boolean(includeSelf && element === node || node.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_CONTAINED_BY);\n        };\n    }\n    throw new TypeError(\"util/compare-position#getParentComparator required either options.parent or options.element\");\n}\n// Bug 286933 - Key events in the autocomplete popup should be hidden from page scripts\n// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=286933\nfunction whenKey() {\n    var map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var bindings = {};\n    var context = nodeArray(map.context)[0] || document.documentElement;\n    delete map.context;\n    var filter = nodeArray(map.filter);\n    delete map.filter;\n    var mapKeys = Object.keys(map);\n    if (!mapKeys.length) {\n        throw new TypeError(\"when/key requires at least one option key\");\n    }\n    var registerBinding = function registerBinding(event) {\n        event.keyCodes.forEach(function(code) {\n            if (!bindings[code]) {\n                bindings[code] = [];\n            }\n            bindings[code].push(event);\n        });\n    };\n    mapKeys.forEach(function(text) {\n        if (typeof map[text] !== \"function\") {\n            throw new TypeError('when/key requires option[\"' + text + '\"] to be a function');\n        }\n        var addCallback = function addCallback(event) {\n            event.callback = map[text];\n            return event;\n        };\n        keyBinding(text).map(addCallback).forEach(registerBinding);\n    });\n    var handleKeyDown = function handleKeyDown(event) {\n        if (event.defaultPrevented) {\n            return;\n        }\n        if (filter.length) {\n            // ignore elements within the exempted sub-trees\n            var isParentOfElement = getParentComparator({\n                element: event.target,\n                includeSelf: true\n            });\n            if (filter.some(isParentOfElement)) {\n                return;\n            }\n        }\n        var key = event.keyCode || event.which;\n        if (!bindings[key]) {\n            return;\n        }\n        bindings[key].forEach(function(_event) {\n            if (!_event.matchModifiers(event)) {\n                return;\n            }\n            _event.callback.call(context, event, disengage);\n        });\n    };\n    context.addEventListener(\"keydown\", handleKeyDown, false);\n    var disengage = function disengage() {\n        context.removeEventListener(\"keydown\", handleKeyDown, false);\n    };\n    return {\n        disengage: disengage\n    };\n}\nfunction _default(param) {\n    let { context } = param === void 0 ? {} : param;\n    if (!context) {\n        context = document.documentElement;\n    }\n    // Make sure the supports tests are run before intercepting the Tab key,\n    // or IE10 and IE11 will fail to process the first Tab key event. Not\n    // limiting this warm-up to IE because it may be a problem elsewhere, too.\n    queryTabsequence();\n    return whenKey({\n        // Safari on OSX may require ALT+TAB to reach links,\n        // see https://github.com/medialize/ally.js/issues/146\n        \"?alt+?shift+tab\": function altShiftTab(event) {\n            // we're completely taking over the Tab key handling\n            event.preventDefault();\n            var sequence = queryTabsequence({\n                context: context\n            });\n            var backward = event.shiftKey;\n            var first = sequence[0];\n            var last = sequence[sequence.length - 1];\n            // wrap around first to last, last to first\n            var source = backward ? first : last;\n            var target = backward ? last : first;\n            if (isActiveElement(source)) {\n                target.focus();\n                return;\n            }\n            // find current position in tabsequence\n            var currentIndex = void 0;\n            var found = sequence.some(function(element, index) {\n                if (!isActiveElement(element)) {\n                    return false;\n                }\n                currentIndex = index;\n                return true;\n            });\n            if (!found) {\n                // redirect to first as we're not in our tabsequence\n                first.focus();\n                return;\n            }\n            // shift focus to previous/next element in the sequence\n            var offset = backward ? -1 : 1;\n            sequence[currentIndex + offset].focus();\n        }\n    });\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=maintain--tab-focus.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9PdmVybGF5L21haW50YWluLS10YWItZm9jdXMuanMiLCJtYXBwaW5ncyI6IkFBQUEsa0JBQWtCLEdBQUcsY0FBYztBQUNuQyxtREFBbUQ7QUFDbkQsZUFBZTtBQUNmLGlDQUFpQztBQUNqQyxFQUFFO0FBQ0YseUNBQXlDO0FBQzVCO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwyQ0FBMEM7SUFDdENJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQywyQkFBMkJDLG1CQUFPQSxDQUFDLGdJQUF5QztBQUNsRixNQUFNQyxZQUFZLFdBQVcsR0FBR0YseUJBQXlCRyxDQUFDLENBQUNGLG1CQUFPQSxDQUFDLCtHQUE2QjtBQUNoRyxNQUFNRyxhQUFhLFdBQVcsR0FBR0oseUJBQXlCRyxDQUFDLENBQUNGLG1CQUFPQSxDQUFDLHFIQUErQjtBQUNuRyx5RkFBeUY7QUFDekYsNkVBQTZFO0FBQzdFLFNBQVNJLFVBQVVDLEtBQUs7SUFDcEIsSUFBSSxDQUFDQSxPQUFPO1FBQ1IsT0FBTyxFQUFFO0lBQ2I7SUFDQSxJQUFJQyxNQUFNQyxPQUFPLENBQUNGLFFBQVE7UUFDdEIsT0FBT0E7SUFDWDtJQUNBLCtDQUErQztJQUMvQyxJQUFJQSxNQUFNRyxRQUFRLEtBQUtDLFdBQVc7UUFDOUIsT0FBTztZQUNISjtTQUNIO0lBQ0w7SUFDQSxJQUFJLE9BQU9BLFVBQVUsVUFBVTtRQUMzQkEsUUFBUUssU0FBU0MsZ0JBQWdCLENBQUNOO0lBQ3RDO0lBQ0EsSUFBSUEsTUFBTU8sTUFBTSxLQUFLSCxXQUFXO1FBQzVCLE9BQU8sRUFBRSxDQUFDSSxLQUFLLENBQUNDLElBQUksQ0FBQ1QsT0FBTztJQUNoQztJQUNB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K0QsT0FBTztBQUNsQyxFQUVBLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvT3ZlcmxheS9tYWludGFpbi0tdGFiLWZvY3VzLmpzPzgyNTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi8gLy8gQHRzLW5vY2hlY2tcbi8vIENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qc1xuLy8gTGljZW5zZTogTUlUXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTUgUm9kbmV5IFJlaG1cbi8vXG4vLyBFbnRyeXBvaW50OiBhbGx5LmpzL21haW50YWluL3RhYi1mb2N1c1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfcGxhdGZvcm0gPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcGxhdGZvcm1cIikpO1xuY29uc3QgX2Nzc2VzY2FwZSA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9jc3MuZXNjYXBlXCIpKTtcbi8vIGlucHV0IG1heSBiZSB1bmRlZmluZWQsIHNlbGVjdG9yLXRyaW5nLCBOb2RlLCBOb2RlTGlzdCwgSFRNTENvbGxlY3Rpb24sIGFycmF5IG9mIE5vZGVzXG4vLyB5ZXMsIHRvIHNvbWUgZXh0ZW50IHRoaXMgaXMgYSBiYWQgcmVwbGljYSBvZiBqUXVlcnkncyBjb25zdHJ1Y3RvciBmdW5jdGlvblxuZnVuY3Rpb24gbm9kZUFycmF5KGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIC8vIGluc3RhbmNlb2YgTm9kZSAtIGRvZXMgbm90IHdvcmsgd2l0aCBpZnJhbWVzXG4gICAgaWYgKGlucHV0Lm5vZGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGlucHV0XG4gICAgICAgIF07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGlucHV0KTtcbiAgICB9XG4gICAgaWYgKGlucHV0Lmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXS5zbGljZS5jYWxsKGlucHV0LCAwKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInVuZXhwZWN0ZWQgaW5wdXQgXCIgKyBTdHJpbmcoaW5wdXQpKTtcbn1cbmZ1bmN0aW9uIGNvbnRleHRUb0VsZW1lbnQoX3JlZikge1xuICAgIHZhciBjb250ZXh0ID0gX3JlZi5jb250ZXh0LCBfcmVmJGxhYmVsID0gX3JlZi5sYWJlbCwgbGFiZWwgPSBfcmVmJGxhYmVsID09PSB1bmRlZmluZWQgPyBcImNvbnRleHQtdG8tZWxlbWVudFwiIDogX3JlZiRsYWJlbCwgcmVzb2x2ZURvY3VtZW50ID0gX3JlZi5yZXNvbHZlRG9jdW1lbnQsIGRlZmF1bHRUb0RvY3VtZW50ID0gX3JlZi5kZWZhdWx0VG9Eb2N1bWVudDtcbiAgICB2YXIgZWxlbWVudCA9IG5vZGVBcnJheShjb250ZXh0KVswXTtcbiAgICBpZiAocmVzb2x2ZURvY3VtZW50ICYmIGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50ICYmIGRlZmF1bHRUb0RvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGxhYmVsICsgXCIgcmVxdWlyZXMgdmFsaWQgb3B0aW9ucy5jb250ZXh0XCIpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUgJiYgZWxlbWVudC5ub2RlVHlwZSAhPT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobGFiZWwgKyBcIiByZXF1aXJlcyBvcHRpb25zLmNvbnRleHQgdG8gYmUgYW4gRWxlbWVudFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRTaGFkb3dIb3N0KCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSwgY29udGV4dCA9IF9yZWYuY29udGV4dDtcbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHRUb0VsZW1lbnQoe1xuICAgICAgICBsYWJlbDogXCJnZXQvc2hhZG93LWhvc3RcIixcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH0pO1xuICAgIC8vIHdhbGsgdXAgdG8gdGhlIHJvb3RcbiAgICB2YXIgY29udGFpbmVyID0gbnVsbDtcbiAgICB3aGlsZShlbGVtZW50KXtcbiAgICAgICAgY29udGFpbmVyID0gZWxlbWVudDtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL05vZGUubm9kZVR5cGVcbiAgICAvLyBOT1RFOiBGaXJlZm94IDM0IGRvZXMgbm90IGV4cG9zZSBTaGFkb3dSb290Lmhvc3QgKGJ1dCAzNyBkb2VzKVxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IGNvbnRhaW5lci5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmIGNvbnRhaW5lci5ob3N0KSB7XG4gICAgICAgIC8vIHRoZSByb290IGlzIGF0dGFjaGVkIHRvIGEgZnJhZ21lbnQgbm9kZSB0aGF0IGhhcyBhIGhvc3RcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5ob3N0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50KG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xufVxuZnVuY3Rpb24gaXNBY3RpdmVFbGVtZW50KGNvbnRleHQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHRUb0VsZW1lbnQoe1xuICAgICAgICBsYWJlbDogXCJpcy9hY3RpdmUtZWxlbWVudFwiLFxuICAgICAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9KTtcbiAgICB2YXIgX2RvY3VtZW50ID0gZ2V0RG9jdW1lbnQoZWxlbWVudCk7XG4gICAgaWYgKF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgc2hhZG93SG9zdCA9IGdldFNoYWRvd0hvc3Qoe1xuICAgICAgICBjb250ZXh0OiBlbGVtZW50XG4gICAgfSk7XG4gICAgaWYgKHNoYWRvd0hvc3QgJiYgc2hhZG93SG9zdC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQgPT09IGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIFtlbGVtLCBlbGVtLnBhcmVudCwgZWxlbS5wYXJlbnQucGFyZW50LCDigKYsIGh0bWxdXG4vLyB3aWxsIG5vdCBjb250YWluIHRoZSBzaGFkb3dSb290IChET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSBhbmQgc2hhZG93SG9zdFxuZnVuY3Rpb24gZ2V0UGFyZW50cygpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIGNvbnRleHQgPSBfcmVmLmNvbnRleHQ7XG4gICAgdmFyIGxpc3QgPSBbXTtcbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHRUb0VsZW1lbnQoe1xuICAgICAgICBsYWJlbDogXCJnZXQvcGFyZW50c1wiLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfSk7XG4gICAgd2hpbGUoZWxlbWVudCl7XG4gICAgICAgIGxpc3QucHVzaChlbGVtZW50KTtcbiAgICAgICAgLy8gSUUgZG9lcyBrbm93IHN1cHBvcnQgcGFyZW50RWxlbWVudCBvbiBTVkdFbGVtZW50XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn1cbi8vIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgbWF5IGJlIGF2YWlsYWJsZSBhdCBhIGRpZmZlcmVudCBuYW1lXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRWxlbWVudC9tYXRjaGVzXG52YXIgbmFtZXMgPSBbXG4gICAgXCJtYXRjaGVzXCIsXG4gICAgXCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3JcIixcbiAgICBcIm1vek1hdGNoZXNTZWxlY3RvclwiLFxuICAgIFwibXNNYXRjaGVzU2VsZWN0b3JcIlxuXTtcbnZhciBuYW1lID0gbnVsbDtcbmZ1bmN0aW9uIGZpbmRNZXRob2ROYW1lKGVsZW1lbnQpIHtcbiAgICBuYW1lcy5zb21lKGZ1bmN0aW9uKF9uYW1lKSB7XG4gICAgICAgIGlmICghZWxlbWVudFtfbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gX25hbWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgZmluZE1ldGhvZE5hbWUoZWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50W25hbWVdKHNlbGVjdG9yKTtcbn1cbi8vIGRlZXAgY2xvbmUgb2Ygb3JpZ2luYWwgcGxhdGZvcm1cbnZhciBwbGF0Zm9ybSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoX3BsYXRmb3JtLmRlZmF1bHQpKTtcbi8vIG9wZXJhdGluZyBzeXN0ZW1cbnZhciBvcyA9IHBsYXRmb3JtLm9zLmZhbWlseSB8fCBcIlwiO1xudmFyIEFORFJPSUQgPSBvcyA9PT0gXCJBbmRyb2lkXCI7XG52YXIgV0lORE9XUyA9IG9zLnNsaWNlKDAsIDcpID09PSBcIldpbmRvd3NcIjtcbnZhciBPU1ggPSBvcyA9PT0gXCJPUyBYXCI7XG52YXIgSU9TID0gb3MgPT09IFwiaU9TXCI7XG4vLyBsYXlvdXRcbnZhciBCTElOSyA9IHBsYXRmb3JtLmxheW91dCA9PT0gXCJCbGlua1wiO1xudmFyIEdFQ0tPID0gcGxhdGZvcm0ubGF5b3V0ID09PSBcIkdlY2tvXCI7XG52YXIgVFJJREVOVCA9IHBsYXRmb3JtLmxheW91dCA9PT0gXCJUcmlkZW50XCI7XG52YXIgRURHRSA9IHBsYXRmb3JtLmxheW91dCA9PT0gXCJFZGdlSFRNTFwiO1xudmFyIFdFQktJVCA9IHBsYXRmb3JtLmxheW91dCA9PT0gXCJXZWJLaXRcIjtcbi8vIGJyb3dzZXIgdmVyc2lvbiAobm90IGxheW91dCBlbmdpbmUgdmVyc2lvbiEpXG52YXIgdmVyc2lvbiA9IHBhcnNlRmxvYXQocGxhdGZvcm0udmVyc2lvbik7XG52YXIgbWFqb3JWZXJzaW9uID0gTWF0aC5mbG9vcih2ZXJzaW9uKTtcbnBsYXRmb3JtLm1ham9yVmVyc2lvbiA9IG1ham9yVmVyc2lvbjtcbnBsYXRmb3JtLmlzID0ge1xuICAgIC8vIG9wZXJhdGluZyBzeXN0ZW1cbiAgICBBTkRST0lEOiBBTkRST0lELFxuICAgIFdJTkRPV1M6IFdJTkRPV1MsXG4gICAgT1NYOiBPU1gsXG4gICAgSU9TOiBJT1MsXG4gICAgLy8gbGF5b3V0XG4gICAgQkxJTks6IEJMSU5LLFxuICAgIEdFQ0tPOiBHRUNLTyxcbiAgICBUUklERU5UOiBUUklERU5ULFxuICAgIEVER0U6IEVER0UsXG4gICAgV0VCS0lUOiBXRUJLSVQsXG4gICAgLy8gSU5URVJORVQgRVhQTE9SRVJTXG4gICAgSUU5OiBUUklERU5UICYmIG1ham9yVmVyc2lvbiA9PT0gOSxcbiAgICBJRTEwOiBUUklERU5UICYmIG1ham9yVmVyc2lvbiA9PT0gMTAsXG4gICAgSUUxMTogVFJJREVOVCAmJiBtYWpvclZlcnNpb24gPT09IDExXG59O1xuZnVuY3Rpb24gYmVmb3JlKCkge1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgICAvLyByZW1lbWJlciB3aGF0IGhhZCBmb2N1cyB0byByZXN0b3JlIGFmdGVyIHRlc3RcbiAgICAgICAgYWN0aXZlRWxlbWVudDogZG9jdW1lbnQuYWN0aXZlRWxlbWVudCxcbiAgICAgICAgLy8gcmVtZW1iZXIgc2Nyb2xsIHBvc2l0aW9ucyB0byByZXN0b3JlIGFmdGVyIHRlc3RcbiAgICAgICAgd2luZG93U2Nyb2xsVG9wOiB3aW5kb3cuc2Nyb2xsVG9wLFxuICAgICAgICB3aW5kb3dTY3JvbGxMZWZ0OiB3aW5kb3cuc2Nyb2xsTGVmdCxcbiAgICAgICAgYm9keVNjcm9sbFRvcDogZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICAgIGJvZHlTY3JvbGxMZWZ0OiBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnRcbiAgICB9O1xuICAgIC8vIHdyYXAgdGVzdHMgaW4gYW4gZWxlbWVudCBoaWRkZW4gZnJvbSBzY3JlZW4gcmVhZGVycyB0byBwcmV2ZW50IHRoZW1cbiAgICAvLyBmcm9tIGFubm91bmNpbmcgZm9jdXMsIHdoaWNoIGNhbiBiZSBxdWl0ZSBpcnJpdGF0aW5nIHRvIHRoZSB1c2VyXG4gICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwicG9zaXRpb246YWJzb2x1dGU7IHBvc2l0aW9uOmZpeGVkOyB0b3A6MDsgbGVmdDotMnB4OyB3aWR0aDoxcHg7IGhlaWdodDoxcHg7IG92ZXJmbG93OmhpZGRlbjtcIik7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcIm9mZlwiKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKFwiYXJpYS1idXN5XCIsIFwidHJ1ZVwiKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICB2YXIgX3dpbmRvdyA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuICAgIHZhciBfZG9jdW1lbnQgPSBfd2luZG93LmRvY3VtZW50O1xuICAgIF9kb2N1bWVudC5vcGVuKCk7XG4gICAgX2RvY3VtZW50LmNsb3NlKCk7XG4gICAgdmFyIHdyYXBwZXIgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBfZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcbiAgICBkYXRhLmlmcmFtZSA9IGlmcmFtZTtcbiAgICBkYXRhLndyYXBwZXIgPSB3cmFwcGVyO1xuICAgIGRhdGEud2luZG93ID0gX3dpbmRvdztcbiAgICBkYXRhLmRvY3VtZW50ID0gX2RvY3VtZW50O1xuICAgIHJldHVybiBkYXRhO1xufVxuLy8gb3B0aW9ucy5lbGVtZW50OlxuLy8gIHtzdHJpbmd9IGVsZW1lbnQgbmFtZVxuLy8gIHtmdW5jdGlvbn0gY2FsbGJhY2sod3JhcHBlciwgZG9jdW1lbnQpIHRvIGdlbmVyYXRlIGFuIGVsZW1lbnRcbi8vIG9wdGlvbnMubXV0YXRlOiAob3B0aW9uYWwpXG4vLyAge2Z1bmN0aW9ufSBjYWxsYmFjayhlbGVtZW50LCB3cmFwcGVyLCBkb2N1bWVudCkgdG8gbWFuaXB1bGF0ZSBlbGVtZW50IHByaW9yIHRvIGZvY3VzLXRlc3QuXG4vLyAgICAgICAgICAgICBDYW4gcmV0dXJuIERPTUVsZW1lbnQgdG8gZGVmaW5lIGZvY3VzIHRhcmdldCAoZGVmYXVsdDogZWxlbWVudClcbi8vIG9wdGlvbnMudmFsaWRhdGU6IChvcHRpb25hbClcbi8vICB7ZnVuY3Rpb259IGNhbGxiYWNrKGVsZW1lbnQsIGZvY3VzVGFyZ2V0LCBkb2N1bWVudCkgdG8gbWFuaXB1bGF0ZSB0ZXN0LXJlc3VsdFxuZnVuY3Rpb24gdGVzdChkYXRhLCBvcHRpb25zKSB7XG4gICAgLy8gbWFrZSBzdXJlIHdlIG9wZXJhdGUgb24gYSBjbGVhbiBzbGF0ZVxuICAgIGRhdGEud3JhcHBlci5pbm5lckhUTUwgPSBcIlwiO1xuICAgIC8vIGNyZWF0ZSBkdW1teSBlbGVtZW50IHRvIHRlc3QgZm9jdXNhYmlsaXR5IG9mXG4gICAgdmFyIGVsZW1lbnQgPSB0eXBlb2Ygb3B0aW9ucy5lbGVtZW50ID09PSBcInN0cmluZ1wiID8gZGF0YS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KG9wdGlvbnMuZWxlbWVudCkgOiBvcHRpb25zLmVsZW1lbnQoZGF0YS53cmFwcGVyLCBkYXRhLmRvY3VtZW50KTtcbiAgICAvLyBhbGxvdyBjYWxsYmFjayB0byBmdXJ0aGVyIHNwZWNpZnkgZHVtbXkgZWxlbWVudFxuICAgIC8vIGFuZCBvcHRpb25hbGx5IGRlZmluZSBlbGVtZW50IHRvIGZvY3VzXG4gICAgdmFyIGZvY3VzID0gb3B0aW9ucy5tdXRhdGUgJiYgb3B0aW9ucy5tdXRhdGUoZWxlbWVudCwgZGF0YS53cmFwcGVyLCBkYXRhLmRvY3VtZW50KTtcbiAgICBpZiAoIWZvY3VzICYmIGZvY3VzICE9PSBmYWxzZSkge1xuICAgICAgICBmb2N1cyA9IGVsZW1lbnQ7XG4gICAgfVxuICAgIC8vIGVsZW1lbnQgbmVlZHMgdG8gYmUgcGFydCBvZiB0aGUgRE9NIHRvIGJlIGZvY3VzYWJsZVxuICAgICFlbGVtZW50LnBhcmVudE5vZGUgJiYgZGF0YS53cmFwcGVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIC8vIHRlc3QgaWYgdGhlIGVsZW1lbnQgd2l0aCBpbnZhbGlkIHRhYmluZGV4IGNhbiBiZSBmb2N1c2VkXG4gICAgZm9jdXMgJiYgZm9jdXMuZm9jdXMgJiYgZm9jdXMuZm9jdXMoKTtcbiAgICAvLyB2YWxpZGF0ZSB0ZXN0J3MgcmVzdWx0XG4gICAgcmV0dXJuIG9wdGlvbnMudmFsaWRhdGUgPyBvcHRpb25zLnZhbGlkYXRlKGVsZW1lbnQsIGZvY3VzLCBkYXRhLmRvY3VtZW50KSA6IGRhdGEuZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZm9jdXM7XG59XG5mdW5jdGlvbiBhZnRlcihkYXRhKSB7XG4gICAgLy8gcmVzdG9yZSBmb2N1cyB0byB3aGF0IGl0IHdhcyBiZWZvcmUgdGVzdCBhbmQgY2xlYW51cFxuICAgIGlmIChkYXRhLmFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgIGlmIChwbGF0Zm9ybS5pcy5JRTEwKSB7XG4gICAgICAgICAgICAvLyBJRTEwIGRvZXMgbm90IHJlZGlyZWN0IGZvY3VzIHRvIDxib2R5PiB3aGVuIHRoZSBhY3RpdmVFbGVtZW50IGlzIHJlbW92ZWRcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEuYWN0aXZlRWxlbWVudCAmJiBkYXRhLmFjdGl2ZUVsZW1lbnQuZm9jdXMgJiYgZGF0YS5hY3RpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGF0YS5pZnJhbWUpO1xuICAgIC8vIHJlc3RvcmUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgd2luZG93LnNjcm9sbFRvcCA9IGRhdGEud2luZG93U2Nyb2xsVG9wO1xuICAgIHdpbmRvdy5zY3JvbGxMZWZ0ID0gZGF0YS53aW5kb3dTY3JvbGxMZWZ0O1xuICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wID0gZGF0YS5ib2R5U2Nyb2xsVG9wO1xuICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCA9IGRhdGEuYm9keVNjcm9sbExlZnQ7XG59XG5mdW5jdGlvbiBkZXRlY3RGb2N1cyh0ZXN0cykge1xuICAgIHZhciBkYXRhID0gYmVmb3JlKCk7XG4gICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyh0ZXN0cykubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXN1bHRzW2tleV0gPSB0ZXN0KGRhdGEsIHRlc3RzW2tleV0pO1xuICAgIH0pO1xuICAgIGFmdGVyKGRhdGEpO1xuICAgIHJldHVybiByZXN1bHRzO1xufVxuLy8gdGhpcyBmaWxlIGlzIG92ZXJ3cml0dGVuIGJ5IGBucG0gcnVuIGJ1aWxkOnByZWBcbnZhciB2ZXJzaW9uJDEgPSBcIjEuNC4xXCI7XG4vKlxuICAgIEZhY2lsaXR5IHRvIGNhY2hlIHRlc3QgcmVzdWx0cyBpbiBsb2NhbFN0b3JhZ2UuXG5cbiAgICBVU0FHRTpcbiAgICAgIGNhY2hlLmdldCgna2V5Jyk7XG4gICAgICBjYWNoZS5zZXQoJ2tleScsICd2YWx1ZScpO1xuICovIGZ1bmN0aW9uIHJlYWRMb2NhbFN0b3JhZ2Uoa2V5KSB7XG4gICAgLy8gYWxsb3cgcmVhZGluZyBmcm9tIHN0b3JhZ2UgdG8gcmV0cmlldmUgcHJldmlvdXMgc3VwcG9ydCByZXN1bHRzXG4gICAgLy8gZXZlbiB3aGlsZSB0aGUgZG9jdW1lbnQgZG9lcyBub3QgaGF2ZSBmb2N1c1xuICAgIHZhciBkYXRhID0gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSB3aW5kb3cubG9jYWxTdG9yYWdlICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICBkYXRhID0gZGF0YSA/IEpTT04ucGFyc2UoZGF0YSkgOiB7fTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRhdGEgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiB3cml0ZUxvY2FsU3RvcmFnZShrZXksIHZhbHVlKSB7XG4gICAgaWYgKCFkb2N1bWVudC5oYXNGb2N1cygpKSB7XG4gICAgICAgIC8vIGlmIHRoZSBkb2N1bWVudCBkb2VzIG5vdCBoYXZlIGZvY3VzIHdoZW4gdGVzdHMgYXJlIGV4ZWN1dGVkLCBmb2N1cygpIG1heVxuICAgICAgICAvLyBub3QgYmUgaGFuZGxlZCBwcm9wZXJseSBhbmQgZXZlbnRzIG1heSBub3QgYmUgZGlzcGF0Y2hlZCBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBkb2N1bWVudCBpcyByZWxvYWRlZCB3aGlsZSBEZXZlbG9wZXIgVG9vbHMgaGF2ZSBmb2N1cy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UgJiYgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGlnbm9yZVxuICAgIH1cbn1cbnZhciB1c2VyQWdlbnQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IHx8IFwiXCI7XG52YXIgY2FjaGVLZXkgPSBcImFsbHktc3VwcG9ydHMtY2FjaGVcIjtcbnZhciBjYWNoZSA9IHJlYWRMb2NhbFN0b3JhZ2UoY2FjaGVLZXkpO1xuLy8gdXBkYXRlIHRoZSBjYWNoZSBpZiBhbGx5IG9yIHRoZSB1c2VyIGFnZW50IGNoYW5nZWQgKG5ld2VyIHZlcnNpb24sIGV0YylcbmlmIChjYWNoZS51c2VyQWdlbnQgIT09IHVzZXJBZ2VudCB8fCBjYWNoZS52ZXJzaW9uICE9PSB2ZXJzaW9uJDEpIHtcbiAgICBjYWNoZSA9IHt9O1xufVxuY2FjaGUudXNlckFnZW50ID0gdXNlckFnZW50O1xuY2FjaGUudmVyc2lvbiA9IHZlcnNpb24kMTtcbnZhciBjYWNoZSQxID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZXMpIHtcbiAgICAgICAgT2JqZWN0LmtleXModmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgY2FjaGVba2V5XSA9IHZhbHVlc1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgY2FjaGUudGltZSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgd3JpdGVMb2NhbFN0b3JhZ2UoY2FjaGVLZXksIGNhY2hlKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gY3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvcigpIHtcbiAgICB2YXIgY29tYmluYXRvciA9IHZvaWQgMDtcbiAgICAvLyBzZWUgaHR0cHM6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1zY29waW5nLTEvI2RlZXAtY29tYmluYXRvclxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMTc1NzJcbiAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ2MDUxXG4gICAgdHJ5IHtcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImh0bWwgPj4+IDpmaXJzdC1jaGlsZFwiKTtcbiAgICAgICAgY29tYmluYXRvciA9IFwiPj4+XCI7XG4gICAgfSBjYXRjaCAobm9BcnJvd0Fycm93QXJyb3cpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIG9sZCBzeW50YXggc3VwcG9ydGVkIGF0IGxlYXN0IHVwIHRvIENocm9tZSA0MVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NjA1MVxuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImh0bWwgL2RlZXAvIDpmaXJzdC1jaGlsZFwiKTtcbiAgICAgICAgICAgIGNvbWJpbmF0b3IgPSBcIi9kZWVwL1wiO1xuICAgICAgICB9IGNhdGNoIChub0RlZXApIHtcbiAgICAgICAgICAgIGNvbWJpbmF0b3IgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb21iaW5hdG9yO1xufVxudmFyIGdpZiA9IFwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3XCI7XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItdXNlbWFwXG52YXIgZm9jdXNBcmVhSW1nVGFiaW5kZXggPSB7XG4gICAgZWxlbWVudDogXCJkaXZcIixcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxtYXAgbmFtZT1cImltYWdlLW1hcC10YWJpbmRleC10ZXN0XCI+JyArICc8YXJlYSBzaGFwZT1cInJlY3RcIiBjb29yZHM9XCI2MywxOSwxNDQsNDVcIj48L21hcD4nICsgJzxpbWcgdXNlbWFwPVwiI2ltYWdlLW1hcC10YWJpbmRleC10ZXN0XCIgdGFiaW5kZXg9XCItMVwiIGFsdD1cIlwiIHNyYz1cIicgKyBnaWYgKyAnXCI+JztcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcihcImFyZWFcIik7XG4gICAgfVxufTtcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbWcjYXR0ci11c2VtYXBcbnZhciBmb2N1c0FyZWFUYWJpbmRleCA9IHtcbiAgICBlbGVtZW50OiBcImRpdlwiLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPG1hcCBuYW1lPVwiaW1hZ2UtbWFwLXRhYmluZGV4LXRlc3RcIj4nICsgJzxhcmVhIGhyZWY9XCIjdm9pZFwiIHRhYmluZGV4PVwiLTFcIiBzaGFwZT1cInJlY3RcIiBjb29yZHM9XCI2MywxOSwxNDQsNDVcIj48L21hcD4nICsgJzxpbWcgdXNlbWFwPVwiI2ltYWdlLW1hcC10YWJpbmRleC10ZXN0XCIgYWx0PVwiXCIgc3JjPVwiJyArIGdpZiArICdcIj4nO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xuICAgICAgICBpZiAocGxhdGZvcm0uaXMuR0VDS08pIHtcbiAgICAgICAgICAgIC8vIGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMzVcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggbG9hZHMgdGhlIERhdGFVUkkgYXN5bmNocm9ub3VzbHksIGNhdXNpbmcgYSBmYWxzZS1uZWdhdGl2ZVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvY3VzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiYXJlYVwiKTtcbiAgICAgICAgZm9jdXMuZm9jdXMoKTtcbiAgICAgICAgcmV0dXJuIF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmb2N1cztcbiAgICB9XG59O1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLXVzZW1hcFxudmFyIGZvY3VzQXJlYVdpdGhvdXRIcmVmID0ge1xuICAgIGVsZW1lbnQ6IFwiZGl2XCIsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8bWFwIG5hbWU9XCJpbWFnZS1tYXAtYXJlYS1ocmVmLXRlc3RcIj4nICsgJzxhcmVhIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjaW1hZ2UtbWFwLWFyZWEtaHJlZi10ZXN0XCIgYWx0PVwiXCIgc3JjPVwiJyArIGdpZiArICdcIj4nO1xuICAgICAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiYXJlYVwiKTtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShlbGVtZW50LCBmb2N1c1RhcmdldCwgX2RvY3VtZW50KSB7XG4gICAgICAgIGlmIChwbGF0Zm9ybS5pcy5HRUNLTykge1xuICAgICAgICAgICAgLy8gZml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8zNVxuICAgICAgICAgICAgLy8gRmlyZWZveCBsb2FkcyB0aGUgRGF0YVVSSSBhc3luY2hyb25vdXNseSwgY2F1c2luZyBhIGZhbHNlLW5lZ2F0aXZlXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZvY3VzVGFyZ2V0O1xuICAgIH1cbn07XG52YXIgZm9jdXNBdWRpb1dpdGhvdXRDb250cm9scyA9IHtcbiAgICBuYW1lOiBcImNhbi1mb2N1cy1hdWRpby13aXRob3V0LWNvbnRyb2xzXCIsXG4gICAgZWxlbWVudDogXCJhdWRpb1wiLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGludmFsaWQgbWVkaWEgZmlsZSBjYW4gdHJpZ2dlciB3YXJuaW5nIGluIGNvbnNvbGUsIGRhdGEtdXJpIHRvIHByZXZlbnQgSFRUUCByZXF1ZXN0XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInNyY1wiLCBnaWYpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElFOSBtYXkgdGhyb3cgXCJFcnJvcjogTm90IGltcGxlbWVudGVkXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG52YXIgaW52YWxpZEdpZiA9IFwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy9aWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaXCI7XG4vLyBOT1RFOiBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzM1XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItdXNlbWFwXG52YXIgZm9jdXNCcm9rZW5JbWFnZU1hcCA9IHtcbiAgICBlbGVtZW50OiBcImRpdlwiLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPG1hcCBuYW1lPVwiYnJva2VuLWltYWdlLW1hcC10ZXN0XCI+PGFyZWEgaHJlZj1cIiN2b2lkXCIgc2hhcGU9XCJyZWN0XCIgY29vcmRzPVwiNjMsMTksMTQ0LDQ1XCI+PC9tYXA+JyArICc8aW1nIHVzZW1hcD1cIiNicm9rZW4taW1hZ2UtbWFwLXRlc3RcIiBhbHQ9XCJcIiBzcmM9XCInICsgaW52YWxpZEdpZiArICdcIj4nO1xuICAgICAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiYXJlYVwiKTtcbiAgICB9XG59O1xuLy8gQ2hpbGRyZW4gb2YgZm9jdXNhYmxlIGVsZW1lbnRzIHdpdGggZGlzcGxheTpmbGV4IGFyZSBmb2N1c2FibGUgaW4gSUUxMC0xMVxudmFyIGZvY3VzQ2hpbGRyZW5PZkZvY3VzYWJsZUZsZXhib3ggPSB7XG4gICAgZWxlbWVudDogXCJkaXZcIixcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCItMVwiKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6IC13ZWJraXQtZmxleDsgZGlzcGxheTogLW1zLWZsZXhib3g7IGRpc3BsYXk6IGZsZXg7XCIpO1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8c3BhbiBzdHlsZT1cImRpc3BsYXk6IGJsb2NrO1wiPmhlbGxvPC9zcGFuPic7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJzcGFuXCIpO1xuICAgIH1cbn07XG4vLyBmaWVsZHNldFt0YWJpbmRleD0wXVtkaXNhYmxlZF0gc2hvdWxkIG5vdCBiZSBmb2N1c2FibGUsIGJ1dCBCbGluayBhbmQgV2ViS2l0IGRpc2FncmVlXG4vLyBAc3BlY2lmaWNhdGlvbiBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZGlzYWJsZWQtZWxlbWVudHMuaHRtbCNjb25jZXB0LWVsZW1lbnQtZGlzYWJsZWRcbi8vIEBicm93c2VyLWlzc3VlIENocm9taXVtIGh0dHBzOi8vY3JidWcuY29tLzQ1Mzg0N1xuLy8gQGJyb3dzZXItaXNzdWUgV2ViS2l0IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDEwODZcbnZhciBmb2N1c0ZpZWxkc2V0RGlzYWJsZWQgPSB7XG4gICAgZWxlbWVudDogXCJmaWVsZHNldFwiLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCAwKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xuICAgIH1cbn07XG52YXIgZm9jdXNGaWVsZHNldCA9IHtcbiAgICBlbGVtZW50OiBcImZpZWxkc2V0XCIsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IFwiPGxlZ2VuZD5sZWdlbmQ8L2xlZ2VuZD48cD5jb250ZW50PC9wPlwiO1xuICAgIH1cbn07XG4vLyBlbGVtZW50cyB3aXRoIGRpc3BsYXk6ZmxleCBhcmUgZm9jdXNhYmxlIGluIElFMTAtMTFcbnZhciBmb2N1c0ZsZXhib3hDb250YWluZXIgPSB7XG4gICAgZWxlbWVudDogXCJzcGFuXCIsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiZGlzcGxheTogLXdlYmtpdC1mbGV4OyBkaXNwbGF5OiAtbXMtZmxleGJveDsgZGlzcGxheTogZmxleDtcIik7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxzcGFuIHN0eWxlPVwiZGlzcGxheTogYmxvY2s7XCI+aGVsbG88L3NwYW4+JztcbiAgICB9XG59O1xuLy8gZm9ybVt0YWJpbmRleD0wXVtkaXNhYmxlZF0gc2hvdWxkIGJlIGZvY3VzYWJsZSBhcyB0aGVcbi8vIHNwZWNpZmljYXRpb24gZG9lc24ndCBrbm93IHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGUgb24gdGhlIGZvcm0gZWxlbWVudFxuLy8gQHNwZWNpZmljYXRpb24gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjdGhlLWZvcm0tZWxlbWVudFxudmFyIGZvY3VzRm9ybURpc2FibGVkID0ge1xuICAgIGVsZW1lbnQ6IFwiZm9ybVwiLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCAwKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xuICAgIH1cbn07XG4vLyBOT1RFOiBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzM1XG4vLyBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIwXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItaXNtYXBcbnZhciBmb2N1c0ltZ0lzbWFwID0ge1xuICAgIGVsZW1lbnQ6IFwiYVwiLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5ocmVmID0gXCIjdm9pZFwiO1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8aW1nIGlzbWFwIHNyYz1cIicgKyBnaWYgKyAnXCIgYWx0PVwiXCI+JztcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcihcImltZ1wiKTtcbiAgICB9XG59O1xuLy8gTk9URTogaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8zNVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLXVzZW1hcFxudmFyIGZvY3VzSW1nVXNlbWFwVGFiaW5kZXggPSB7XG4gICAgZWxlbWVudDogXCJkaXZcIixcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxtYXAgbmFtZT1cImltYWdlLW1hcC10YWJpbmRleC10ZXN0XCI+PGFyZWEgaHJlZj1cIiN2b2lkXCIgc2hhcGU9XCJyZWN0XCIgY29vcmRzPVwiNjMsMTksMTQ0LDQ1XCI+PC9tYXA+JyArICc8aW1nIHVzZW1hcD1cIiNpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiIHRhYmluZGV4PVwiLTFcIiBhbHQ9XCJcIiAnICsgJ3NyYz1cIicgKyBnaWYgKyAnXCI+JztcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcihcImltZ1wiKTtcbiAgICB9XG59O1xudmFyIGZvY3VzSW5IaWRkZW5JZnJhbWUgPSB7XG4gICAgZWxlbWVudDogZnVuY3Rpb24gZWxlbWVudCh3cmFwcGVyLCBfZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIGlmcmFtZSA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICAvLyBpZnJhbWUgbXVzdCBiZSBwYXJ0IG9mIHRoZSBET00gYmVmb3JlIGFjY2Vzc2luZyB0aGUgY29udGVudFdpbmRvdyBpcyBwb3NzaWJsZVxuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgaWZyYW1lJ3MgZGVmYXVsdCBkb2N1bWVudCAoPGh0bWw+PGhlYWQ+PC9oZWFkPjxib2R5PjwvYm9keT48L2h0bWw+KVxuICAgICAgICB2YXIgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICAgICAgICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICAgICAgICByZXR1cm4gaWZyYW1lO1xuICAgIH0sXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoaWZyYW1lKSB7XG4gICAgICAgIGlmcmFtZS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgdmFyIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgIHZhciBpbnB1dCA9IGlmcmFtZURvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgaWZyYW1lRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShpZnJhbWUpIHtcbiAgICAgICAgdmFyIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgIHZhciBmb2N1cyA9IGlmcmFtZURvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKTtcbiAgICAgICAgcmV0dXJuIGlmcmFtZURvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZvY3VzO1xuICAgIH1cbn07XG52YXIgcmVzdWx0ID0gIXBsYXRmb3JtLmlzLldFQktJVDtcbmZ1bmN0aW9uIGZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0KCkge1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBGaXJlZm94IGFsbG93cyAqYW55KiB2YWx1ZSBhbmQgdHJlYXRzIGludmFsaWQgdmFsdWVzIGxpa2UgdGFiaW5kZXg9XCItMVwiXG4vLyBAYnJvd3Nlci1pc3N1ZSBHZWNrbyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTI4MDU0XG52YXIgZm9jdXNJbnZhbGlkVGFiaW5kZXggPSB7XG4gICAgZWxlbWVudDogXCJkaXZcIixcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCJpbnZhbGlkLXZhbHVlXCIpO1xuICAgIH1cbn07XG52YXIgZm9jdXNMYWJlbFRhYmluZGV4ID0ge1xuICAgIGVsZW1lbnQ6IFwibGFiZWxcIixcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCItMVwiKTtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShlbGVtZW50LCBmb2N1c1RhcmdldCwgX2RvY3VtZW50KSB7XG4gICAgICAgIC8vIGZvcmNlIGxheW91dCBpbiBDaHJvbWUgNDksIG90aGVyd2lzZSB0aGUgZWxlbWVudCB3b24ndCBiZSBmb2N1c2FibGVcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi8gdmFyIHZhcmlhYmxlVG9QcmV2ZW50RGVhZENvZGVFbGltaW5hdGlvbiA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovIGVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgcmV0dXJuIF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbGVtZW50O1xuICAgIH1cbn07XG52YXIgc3ZnID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGh0YlwiICsgXCJHNXpPbmhzYVc1clBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1TDNoc2FXNXJJaUJwWkQwaWMzWm5JajQ4ZEdWNGRDQjRQU0l4TUNJZ2VUMGlNakFpSUdsa1BTSlwiICsgXCJ6ZG1jdGJHbHVheTEwWlhoMElqNTBaWGgwUEM5MFpYaDBQand2YzNablBnPT1cIjtcbi8vIE5vdGU6IElFMTAgb24gQnJvd3NlclN0YWNrIGRvZXMgbm90IGxpa2UgdGhpcyB0ZXN0XG52YXIgZm9jdXNPYmplY3RTdmdIaWRkZW4gPSB7XG4gICAgZWxlbWVudDogXCJvYmplY3RcIixcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImltYWdlL3N2Zyt4bWxcIik7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YVwiLCBzdmcpO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMjAwXCIpO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjUwXCIpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgIH1cbn07XG4vLyBOb3RlOiBJRTEwIG9uIEJyb3dzZXJTdGFjayBkb2VzIG5vdCBsaWtlIHRoaXMgdGVzdFxudmFyIGZvY3VzT2JqZWN0U3ZnID0ge1xuICAgIG5hbWU6IFwiY2FuLWZvY3VzLW9iamVjdC1zdmdcIixcbiAgICBlbGVtZW50OiBcIm9iamVjdFwiLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiaW1hZ2Uvc3ZnK3htbFwiKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhXCIsIHN2Zyk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIyMDBcIik7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiNTBcIik7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xuICAgICAgICBpZiAocGxhdGZvcm0uaXMuR0VDS08pIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggc2VlbXMgdG8gYmUgaGFuZGxpbmcgdGhlIG9iamVjdCBjcmVhdGlvbiBhc3luY2hyb25vdXNseSBhbmQgdGhlcmVieSBwcm9kdWNlcyBhIGZhbHNlIG5lZ2F0aXZlIHRlc3QgcmVzdWx0LlxuICAgICAgICAgICAgLy8gQmVjYXVzZSB3ZSBrbm93IEZpcmVmb3ggaXMgYWJsZSB0byBmb2N1cyBvYmplY3QgZWxlbWVudHMgcmVmZXJlbmNpbmcgU1ZHcywgd2Ugc2ltcGx5IGNoZWF0IGJ5IHNuaWZmaW5nIHRoZSB1c2VyIGFnZW50IHN0cmluZ1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbGVtZW50O1xuICAgIH1cbn07XG4vLyBFdmVyeSBFbnZpcm9ubWVudCBleGNlcHQgSUU5IGNvbnNpZGVycyBTV0Ygb2JqZWN0cyBmb2N1c2FibGVcbnZhciByZXN1bHQkMSA9ICFwbGF0Zm9ybS5pcy5JRTk7XG5mdW5jdGlvbiBmb2N1c09iamVjdFN3ZigpIHtcbiAgICByZXR1cm4gcmVzdWx0JDE7XG59XG52YXIgZm9jdXNSZWRpcmVjdEltZ1VzZW1hcCA9IHtcbiAgICBlbGVtZW50OiBcImRpdlwiLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPG1hcCBuYW1lPVwiZm9jdXMtcmVkaXJlY3QtaW1nLXVzZW1hcFwiPjxhcmVhIGhyZWY9XCIjdm9pZFwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjZm9jdXMtcmVkaXJlY3QtaW1nLXVzZW1hcFwiIGFsdD1cIlwiICcgKyAnc3JjPVwiJyArIGdpZiArICdcIj4nO1xuICAgICAgICAvLyBmb2N1cyB0aGUgPGltZz4sIG5vdCB0aGUgPGRpdj5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcihcImltZ1wiKTtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShlbGVtZW50LCBmb2N1c1RhcmdldCwgX2RvY3VtZW50KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJhcmVhXCIpO1xuICAgICAgICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRhcmdldDtcbiAgICB9XG59O1xuLy8gc2VlIGh0dHBzOi8vanNiaW4uY29tL25lbmlyaXNhZ2UvZWRpdD9odG1sLGpzLGNvbnNvbGUsb3V0cHV0XG52YXIgZm9jdXNSZWRpcmVjdExlZ2VuZCA9IHtcbiAgICBlbGVtZW50OiBcImZpZWxkc2V0XCIsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8bGVnZW5kPmxlZ2VuZDwvbGVnZW5kPjxpbnB1dCB0YWJpbmRleD1cIi0xXCI+PGlucHV0IHRhYmluZGV4PVwiMFwiPic7XG4gICAgICAgIC8vIHRha2UgY2FyZSBvZiBmb2N1cyBpbiB2YWxpZGF0ZSgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xuICAgICAgICB2YXIgZm9jdXNhYmxlID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0YWJpbmRleD1cIi0xXCJdJyk7XG4gICAgICAgIHZhciB0YWJiYWJsZSA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbdGFiaW5kZXg9XCIwXCJdJyk7XG4gICAgICAgIC8vIEZpcmVmb3ggcmVxdWlyZXMgdGhpcyB0ZXN0IHRvIGZvY3VzIHRoZSA8ZmllbGRzZXQ+IGZpcnN0LCB3aGlsZSB0aGlzIGlzIG5vdCBuZWNlc3NhcnkgaW5cbiAgICAgICAgLy8gaHR0cHM6Ly9qc2Jpbi5jb20vbmVuaXJpc2FnZS9lZGl0P2h0bWwsanMsY29uc29sZSxvdXRwdXRcbiAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgICAgICBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJsZWdlbmRcIikuZm9jdXMoKTtcbiAgICAgICAgcmV0dXJuIF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmb2N1c2FibGUgJiYgXCJmb2N1c2FibGVcIiB8fCBfZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGFiYmFibGUgJiYgXCJ0YWJiYWJsZVwiIHx8IFwiXCI7XG4gICAgfVxufTtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMjFcbnZhciBmb2N1c1Njcm9sbEJvZHkgPSB7XG4gICAgZWxlbWVudDogXCJkaXZcIixcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJ3aWR0aDogMTAwcHg7IGhlaWdodDogNTBweDsgb3ZlcmZsb3c6IGF1dG87XCIpO1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8ZGl2IHN0eWxlPVwid2lkdGg6IDUwMHB4OyBoZWlnaHQ6IDQwcHg7XCI+c2Nyb2xsYWJsZSBjb250ZW50PC9kaXY+JztcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcihcImRpdlwiKTtcbiAgICB9XG59O1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8yMVxudmFyIGZvY3VzU2Nyb2xsQ29udGFpbmVyV2l0aG91dE92ZXJmbG93ID0ge1xuICAgIGVsZW1lbnQ6IFwiZGl2XCIsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwid2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDUwcHg7XCIpO1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8ZGl2IHN0eWxlPVwid2lkdGg6IDUwMHB4OyBoZWlnaHQ6IDQwcHg7XCI+c2Nyb2xsYWJsZSBjb250ZW50PC9kaXY+JztcbiAgICB9XG59O1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8yMVxudmFyIGZvY3VzU2Nyb2xsQ29udGFpbmVyID0ge1xuICAgIGVsZW1lbnQ6IFwiZGl2XCIsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwid2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDUwcHg7IG92ZXJmbG93OiBhdXRvO1wiKTtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPGRpdiBzdHlsZT1cIndpZHRoOiA1MDBweDsgaGVpZ2h0OiA0MHB4O1wiPnNjcm9sbGFibGUgY29udGVudDwvZGl2Pic7XG4gICAgfVxufTtcbnZhciBmb2N1c1N1bW1hcnkgPSB7XG4gICAgZWxlbWVudDogXCJkZXRhaWxzXCIsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IFwiPHN1bW1hcnk+Zm9vPC9zdW1tYXJ5PjxwPmNvbnRlbnQ8L3A+XCI7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkO1xuICAgIH1cbn07XG5mdW5jdGlvbiBtYWtlRm9jdXNhYmxlRm9yZWlnbk9iamVjdCgpIHtcbiAgICAvLyBDb25zdHJ1Y3RzIDxmb3JlaWduT2JqZWN0IHdpZHRoPVwiMzBcIiBoZWlnaHQ9XCIzMFwiPjxpbnB1dCB0eXBlPVwidGV4dFwiLz48L2ZvcmVpZ25PYmplY3Q+XG4gICAgLy8gd2l0aG91dCByYWlzaW5nIGEgVHJ1c3RlZCBUeXBlcyB2aW9sYXRpb25cbiAgICB2YXIgZm9yZWlnbk9iamVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZm9yZWlnbk9iamVjdFwiKTtcbiAgICBmb3JlaWduT2JqZWN0LndpZHRoLmJhc2VWYWwudmFsdWUgPSAzMDtcbiAgICBmb3JlaWduT2JqZWN0LmhlaWdodC5iYXNlVmFsLnZhbHVlID0gMzA7XG4gICAgZm9yZWlnbk9iamVjdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIikpO1xuICAgIGZvcmVpZ25PYmplY3QubGFzdENoaWxkLnR5cGUgPSBcInRleHRcIjtcbiAgICByZXR1cm4gZm9yZWlnbk9iamVjdDtcbn1cbmZ1bmN0aW9uIGZvY3VzU3ZnRm9yZWlnbk9iamVjdEhhY2soZWxlbWVudCkge1xuICAgIC8vIEVkZ2UxMywgRWRnZTE0OiBmb3JlaWduT2JqZWN0IGZvY3VzIGhhY2tcbiAgICAvLyBodHRwczovL2pzYmluLmNvbS9rdW5laGludWdpL2VkaXQ/aHRtbCxqcyxvdXRwdXRcbiAgICAvLyBodHRwczovL2pzYmluLmNvbS9mYWphZ2kvMy9lZGl0P2h0bWwsanMsb3V0cHV0XG4gICAgdmFyIGlzU3ZnRWxlbWVudCA9IGVsZW1lbnQub3duZXJTVkdFbGVtZW50IHx8IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzdmdcIjtcbiAgICBpZiAoIWlzU3ZnRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGluamVjdCBhbmQgZm9jdXMgYW4gPGlucHV0PiBlbGVtZW50IGludG8gdGhlIFNWRyBlbGVtZW50IHRvIHJlY2VpdmUgZm9jdXNcbiAgICB2YXIgZm9yZWlnbk9iamVjdCA9IG1ha2VGb2N1c2FibGVGb3JlaWduT2JqZWN0KCk7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChmb3JlaWduT2JqZWN0KTtcbiAgICB2YXIgaW5wdXQgPSBmb3JlaWduT2JqZWN0LnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC5mb2N1cygpO1xuICAgIC8vIHVwb24gZGlzYWJsaW5nIHRoZSBhY3RpdmVFbGVtZW50LCBJRSBhbmQgRWRnZVxuICAgIC8vIHdpbGwgbm90IHNoaWZ0IGZvY3VzIHRvIDxib2R5PiBsaWtlIGFsbCB0aGUgb3RoZXJcbiAgICAvLyBicm93c2VycywgYnV0IGluc3RlYWQgZmluZCB0aGUgZmlyc3QgZm9jdXNhYmxlXG4gICAgLy8gYW5jZXN0b3IgYW5kIHNoaWZ0IGZvY3VzIHRvIHRoYXRcbiAgICBpbnB1dC5kaXNhYmxlZCA9IHRydWU7XG4gICAgLy8gY2xlYW4gdXBcbiAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGZvcmVpZ25PYmplY3QpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGUoZWxlbWVudCkge1xuICAgIHJldHVybiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI+JyArIGVsZW1lbnQgKyBcIjwvc3ZnPlwiO1xufVxuZnVuY3Rpb24gZm9jdXMoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50LmZvY3VzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgSFRNTEVsZW1lbnQucHJvdG90eXBlLmZvY3VzLmNhbGwoZWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBmb2N1c1N2Z0ZvcmVpZ25PYmplY3RIYWNrKGVsZW1lbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKGVsZW1lbnQsIGZvY3VzVGFyZ2V0LCBfZG9jdW1lbnQpIHtcbiAgICBmb2N1cyhmb2N1c1RhcmdldCk7XG4gICAgcmV0dXJuIF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmb2N1c1RhcmdldDtcbn1cbnZhciBmb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZSA9IHtcbiAgICBlbGVtZW50OiBcImRpdlwiLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBnZW5lcmF0ZSgnPHRleHQgZm9jdXNhYmxlPVwidHJ1ZVwiPmE8L3RleHQ+Jyk7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0ZXh0XCIpO1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlXG59O1xudmFyIGZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUgPSB7XG4gICAgZWxlbWVudDogXCJkaXZcIixcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gZ2VuZXJhdGUoJzx0ZXh0IHRhYmluZGV4PVwiMFwiPmE8L3RleHQ+Jyk7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0ZXh0XCIpO1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlXG59O1xudmFyIGZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZSA9IHtcbiAgICBlbGVtZW50OiBcImRpdlwiLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBnZW5lcmF0ZSgnPHRleHQgdGFiaW5kZXg9XCItMVwiPmE8L3RleHQ+Jyk7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0ZXh0XCIpO1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlXG59O1xudmFyIGZvY3VzU3ZnVXNlVGFiaW5kZXggPSB7XG4gICAgZWxlbWVudDogXCJkaXZcIixcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gZ2VuZXJhdGUoW1xuICAgICAgICAgICAgJzxnIGlkPVwiYWxseS10ZXN0LXRhcmdldFwiPjxhIHhsaW5rOmhyZWY9XCIjdm9pZFwiPjx0ZXh0Pmxpbms8L3RleHQ+PC9hPjwvZz4nLFxuICAgICAgICAgICAgJzx1c2UgeGxpbms6aHJlZj1cIiNhbGx5LXRlc3QtdGFyZ2V0XCIgeD1cIjBcIiB5PVwiMFwiIHRhYmluZGV4PVwiLTFcIiAvPidcbiAgICAgICAgXS5qb2luKFwiXCIpKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcihcInVzZVwiKTtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZVxufTtcbnZhciBmb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleCA9IHtcbiAgICBlbGVtZW50OiBcImRpdlwiLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBnZW5lcmF0ZSgnPGZvcmVpZ25PYmplY3QgdGFiaW5kZXg9XCItMVwiPjxpbnB1dCB0eXBlPVwidGV4dFwiIC8+PC9mb3JlaWduT2JqZWN0PicpO1xuICAgICAgICAvLyBTYWZhcmkgOCdzIHF1ZXJzU2VsZWN0b3IoKSBjYW4ndCBpZGVudGlmeSBmb3JlaWduT2JqZWN0LCBidXQgZ2V0RWxlbWVudHlCeVRhZ05hbWUoKSBjYW5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcihcImZvcmVpZ25PYmplY3RcIikgfHwgZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImZvcmVpZ25PYmplY3RcIilbMF07XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGVcbn07XG4vLyBGaXJlZm94IHNlZW1zIHRvIGJlIGhhbmRsaW5nIHRoZSBTVkctZG9jdW1lbnQtaW4taWZyYW1lIGNyZWF0aW9uIGFzeW5jaHJvbm91c2x5XG4vLyBhbmQgdGhlcmVieSBwcm9kdWNlcyBhIGZhbHNlIG5lZ2F0aXZlIHRlc3QgcmVzdWx0LiBUaHVzIHRoZSB0ZXN0IGlzIHBvaW50bGVzc1xuLy8gYW5kIHdlIHJlc29ydCB0byBVQSBzbmlmZmluZyBvbmNlIGFnYWluLlxuLy8gc2VlIGh0dHA6Ly9qc2Jpbi5jb20vdnVuYWRvaG9rby8xL2VkaXQ/anMsY29uc29sZSxvdXRwdXRcbnZhciByZXN1bHQkMiA9IEJvb2xlYW4ocGxhdGZvcm0uaXMuR0VDS08gJiYgdHlwZW9mIFNWR0VsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgU1ZHRWxlbWVudC5wcm90b3R5cGUuZm9jdXMpO1xuZnVuY3Rpb24gZm9jdXNTdmdJbklmcmFtZSgpIHtcbiAgICByZXR1cm4gcmVzdWx0JDI7XG59XG52YXIgZm9jdXNTdmcgPSB7XG4gICAgZWxlbWVudDogXCJkaXZcIixcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gZ2VuZXJhdGUoXCJcIik7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGVcbn07XG4vLyBGaXJlZm94IGFsbG93cyAqYW55KiB2YWx1ZSBhbmQgdHJlYXRzIGludmFsaWQgdmFsdWVzIGxpa2UgdGFiaW5kZXg9XCItMVwiXG4vLyBAYnJvd3Nlci1pc3N1ZSBHZWNrbyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTI4MDU0XG52YXIgZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVycyA9IHtcbiAgICBlbGVtZW50OiBcImRpdlwiLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjN4XCIpO1xuICAgIH1cbn07XG52YXIgZm9jdXNUYWJsZSA9IHtcbiAgICBlbGVtZW50OiBcInRhYmxlXCIsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCwgd3JhcHBlciwgX2RvY3VtZW50KSB7XG4gICAgICAgIC8vIElFOSBoYXMgYSBwcm9ibGVtIHJlcGxhY2luZyBUQk9EWSBjb250ZW50cyB3aXRoIGlubmVySFRNTC5cbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzgwOTcwNTUvNTE1MTI0XG4gICAgICAgIC8vIGVsZW1lbnQuaW5uZXJIVE1MID0gJzx0cj48dGQ+Y2VsbDwvdGQ+PC90cj4nO1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSBfZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBmcmFnbWVudC5pbm5lckhUTUwgPSBcIjx0cj48dGQ+Y2VsbDwvdGQ+PC90cj5cIjtcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgfVxufTtcbnZhciBmb2N1c1ZpZGVvV2l0aG91dENvbnRyb2xzID0ge1xuICAgIGVsZW1lbnQ6IFwidmlkZW9cIixcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBpbnZhbGlkIG1lZGlhIGZpbGUgY2FuIHRyaWdnZXIgd2FybmluZyBpbiBjb25zb2xlLCBkYXRhLXVyaSB0byBwcmV2ZW50IEhUVFAgcmVxdWVzdFxuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgZ2lmKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJRTkgbWF5IHRocm93IFwiRXJyb3I6IE5vdCBpbXBsZW1lbnRlZFwiXG4gICAgICAgIH1cbiAgICB9XG59O1xuLy8gaHR0cHM6Ly9qc2Jpbi5jb20vdmFmYWJhLzMvZWRpdD9odG1sLGpzLGNvbnNvbGUsb3V0cHV0XG52YXIgcmVzdWx0JDMgPSBwbGF0Zm9ybS5pcy5HRUNLTyB8fCBwbGF0Zm9ybS5pcy5UUklERU5UIHx8IHBsYXRmb3JtLmlzLkVER0U7XG5mdW5jdGlvbiB0YWJzZXF1ZW5jZUFyZWFBdEltZ1Bvc2l0aW9uKCkge1xuICAgIHJldHVybiByZXN1bHQkMztcbn1cbnZhciB0ZXN0Q2FsbGJhY2tzID0ge1xuICAgIGNzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3I6IGNzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3IsXG4gICAgZm9jdXNJblplcm9EaW1lbnNpb25PYmplY3Q6IGZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0LFxuICAgIGZvY3VzT2JqZWN0U3dmOiBmb2N1c09iamVjdFN3ZixcbiAgICBmb2N1c1N2Z0luSWZyYW1lOiBmb2N1c1N2Z0luSWZyYW1lLFxuICAgIHRhYnNlcXVlbmNlQXJlYUF0SW1nUG9zaXRpb246IHRhYnNlcXVlbmNlQXJlYUF0SW1nUG9zaXRpb25cbn07XG52YXIgdGVzdERlc2NyaXB0aW9ucyA9IHtcbiAgICBmb2N1c0FyZWFJbWdUYWJpbmRleDogZm9jdXNBcmVhSW1nVGFiaW5kZXgsXG4gICAgZm9jdXNBcmVhVGFiaW5kZXg6IGZvY3VzQXJlYVRhYmluZGV4LFxuICAgIGZvY3VzQXJlYVdpdGhvdXRIcmVmOiBmb2N1c0FyZWFXaXRob3V0SHJlZixcbiAgICBmb2N1c0F1ZGlvV2l0aG91dENvbnRyb2xzOiBmb2N1c0F1ZGlvV2l0aG91dENvbnRyb2xzLFxuICAgIGZvY3VzQnJva2VuSW1hZ2VNYXA6IGZvY3VzQnJva2VuSW1hZ2VNYXAsXG4gICAgZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveDogZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveCxcbiAgICBmb2N1c0ZpZWxkc2V0RGlzYWJsZWQ6IGZvY3VzRmllbGRzZXREaXNhYmxlZCxcbiAgICBmb2N1c0ZpZWxkc2V0OiBmb2N1c0ZpZWxkc2V0LFxuICAgIGZvY3VzRmxleGJveENvbnRhaW5lcjogZm9jdXNGbGV4Ym94Q29udGFpbmVyLFxuICAgIGZvY3VzRm9ybURpc2FibGVkOiBmb2N1c0Zvcm1EaXNhYmxlZCxcbiAgICBmb2N1c0ltZ0lzbWFwOiBmb2N1c0ltZ0lzbWFwLFxuICAgIGZvY3VzSW1nVXNlbWFwVGFiaW5kZXg6IGZvY3VzSW1nVXNlbWFwVGFiaW5kZXgsXG4gICAgZm9jdXNJbkhpZGRlbklmcmFtZTogZm9jdXNJbkhpZGRlbklmcmFtZSxcbiAgICBmb2N1c0ludmFsaWRUYWJpbmRleDogZm9jdXNJbnZhbGlkVGFiaW5kZXgsXG4gICAgZm9jdXNMYWJlbFRhYmluZGV4OiBmb2N1c0xhYmVsVGFiaW5kZXgsXG4gICAgZm9jdXNPYmplY3RTdmc6IGZvY3VzT2JqZWN0U3ZnLFxuICAgIGZvY3VzT2JqZWN0U3ZnSGlkZGVuOiBmb2N1c09iamVjdFN2Z0hpZGRlbixcbiAgICBmb2N1c1JlZGlyZWN0SW1nVXNlbWFwOiBmb2N1c1JlZGlyZWN0SW1nVXNlbWFwLFxuICAgIGZvY3VzUmVkaXJlY3RMZWdlbmQ6IGZvY3VzUmVkaXJlY3RMZWdlbmQsXG4gICAgZm9jdXNTY3JvbGxCb2R5OiBmb2N1c1Njcm9sbEJvZHksXG4gICAgZm9jdXNTY3JvbGxDb250YWluZXJXaXRob3V0T3ZlcmZsb3c6IGZvY3VzU2Nyb2xsQ29udGFpbmVyV2l0aG91dE92ZXJmbG93LFxuICAgIGZvY3VzU2Nyb2xsQ29udGFpbmVyOiBmb2N1c1Njcm9sbENvbnRhaW5lcixcbiAgICBmb2N1c1N1bW1hcnk6IGZvY3VzU3VtbWFyeSxcbiAgICBmb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZTogZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUsXG4gICAgZm9jdXNTdmdUYWJpbmRleEF0dHJpYnV0ZTogZm9jdXNTdmdUYWJpbmRleEF0dHJpYnV0ZSxcbiAgICBmb2N1c1N2Z05lZ2F0aXZlVGFiaW5kZXhBdHRyaWJ1dGU6IGZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZSxcbiAgICBmb2N1c1N2Z1VzZVRhYmluZGV4OiBmb2N1c1N2Z1VzZVRhYmluZGV4LFxuICAgIGZvY3VzU3ZnRm9yZWlnbm9iamVjdFRhYmluZGV4OiBmb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleCxcbiAgICBmb2N1c1N2ZzogZm9jdXNTdmcsXG4gICAgZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVyczogZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVycyxcbiAgICBmb2N1c1RhYmxlOiBmb2N1c1RhYmxlLFxuICAgIGZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHM6IGZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHNcbn07XG5mdW5jdGlvbiBleGVjdXRlVGVzdHMoKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBkZXRlY3RGb2N1cyh0ZXN0RGVzY3JpcHRpb25zKTtcbiAgICBPYmplY3Qua2V5cyh0ZXN0Q2FsbGJhY2tzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXN1bHRzW2tleV0gPSB0ZXN0Q2FsbGJhY2tzW2tleV0oKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn1cbnZhciBzdXBwb3J0c0NhY2hlID0gbnVsbDtcbmZ1bmN0aW9uIF9zdXBwb3J0cygpIHtcbiAgICBpZiAoc3VwcG9ydHNDYWNoZSkge1xuICAgICAgICByZXR1cm4gc3VwcG9ydHNDYWNoZTtcbiAgICB9XG4gICAgc3VwcG9ydHNDYWNoZSA9IGNhY2hlJDEuZ2V0KCk7XG4gICAgaWYgKCFzdXBwb3J0c0NhY2hlLnRpbWUpIHtcbiAgICAgICAgY2FjaGUkMS5zZXQoZXhlY3V0ZVRlc3RzKCkpO1xuICAgICAgICBzdXBwb3J0c0NhY2hlID0gY2FjaGUkMS5nZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRzQ2FjaGU7XG59XG52YXIgc3VwcG9ydHMgPSB2b2lkIDA7XG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNydWxlcy1mb3ItcGFyc2luZy1pbnRlZ2Vyc1xuLy8gTk9URTogYWxsIGJyb3dzZXJzIGFncmVlIHRvIGFsbG93IHRyYWlsaW5nIHNwYWNlcyBhcyB3ZWxsXG52YXIgdmFsaWRJbnRlZ2VyUGF0dGVybk5vVHJhaWxpbmcgPSAvXlxccyooLXxcXCspP1swLTldK1xccyokLztcbnZhciB2YWxpZEludGVnZXJQYXR0ZXJuV2l0aFRyYWlsaW5nID0gL15cXHMqKC18XFwrKT9bMC05XSsuKiQvO1xuZnVuY3Rpb24gaXNWYWxpZFRhYmluZGV4KGNvbnRleHQpIHtcbiAgICBpZiAoIXN1cHBvcnRzKSB7XG4gICAgICAgIHN1cHBvcnRzID0gX3N1cHBvcnRzKCk7XG4gICAgfVxuICAgIHZhciB2YWxpZEludGVnZXJQYXR0ZXJuID0gc3VwcG9ydHMuZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVycyA/IHZhbGlkSW50ZWdlclBhdHRlcm5XaXRoVHJhaWxpbmcgOiB2YWxpZEludGVnZXJQYXR0ZXJuTm9UcmFpbGluZztcbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHRUb0VsZW1lbnQoe1xuICAgICAgICBsYWJlbDogXCJpcy92YWxpZC10YWJpbmRleFwiLFxuICAgICAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9KTtcbiAgICAvLyBFZGdlIDE0IGhhcyBhIGNhcGl0YWxpemF0aW9uIHByb2JsZW0gb24gU1ZHIGVsZW1lbnRzLFxuICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy85MjgyMDU4L1xuICAgIHZhciBoYXNUYWJpbmRleCA9IGVsZW1lbnQuaGFzQXR0cmlidXRlKFwidGFiaW5kZXhcIik7XG4gICAgdmFyIGhhc1RhYkluZGV4ID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiKTtcbiAgICBpZiAoIWhhc1RhYmluZGV4ICYmICFoYXNUYWJJbmRleCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIG9sZGVyIEZpcmVmb3ggYW5kIEludGVybmV0IEV4cGxvcmVyIGRvbid0IHN1cHBvcnQgdGFiaW5kZXggb24gU1ZHIGVsZW1lbnRzXG4gICAgdmFyIGlzU3ZnRWxlbWVudCA9IGVsZW1lbnQub3duZXJTVkdFbGVtZW50IHx8IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzdmdcIjtcbiAgICBpZiAoaXNTdmdFbGVtZW50ICYmICFzdXBwb3J0cy5mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQGJyb3dzZXItaXNzdWUgR2Vja28gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEyODA1NFxuICAgIGlmIChzdXBwb3J0cy5mb2N1c0ludmFsaWRUYWJpbmRleCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gYW4gZWxlbWVudCBtYXRjaGVzIHRoZSB0YWJpbmRleCBzZWxlY3RvciBldmVuIGlmIGl0cyB2YWx1ZSBpcyBpbnZhbGlkXG4gICAgdmFyIHRhYmluZGV4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoaGFzVGFiaW5kZXggPyBcInRhYmluZGV4XCIgOiBcInRhYkluZGV4XCIpO1xuICAgIC8vIElFMTEgcGFyc2VzIHRhYmluZGV4PVwiXCIgYXMgdGhlIHZhbHVlIFwiLTMyNzY4XCJcbiAgICAvLyBAYnJvd3Nlci1pc3N1ZSBUcmlkZW50IGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTA3Mjk2NVxuICAgIGlmICh0YWJpbmRleCA9PT0gXCItMzI3NjhcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBCb29sZWFuKHRhYmluZGV4ICYmIHZhbGlkSW50ZWdlclBhdHRlcm4udGVzdCh0YWJpbmRleCkpO1xufVxuZnVuY3Rpb24gdGFiaW5kZXhWYWx1ZShlbGVtZW50KSB7XG4gICAgaWYgKCFpc1ZhbGlkVGFiaW5kZXgoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEVkZ2UgMTQgaGFzIGEgY2FwaXRhbGl6YXRpb24gcHJvYmxlbSBvbiBTVkcgZWxlbWVudHMsXG4gICAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzkyODIwNTgvXG4gICAgdmFyIGhhc1RhYmluZGV4ID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKTtcbiAgICB2YXIgYXR0cmlidXRlTmFtZSA9IGhhc1RhYmluZGV4ID8gXCJ0YWJpbmRleFwiIDogXCJ0YWJJbmRleFwiO1xuICAgIC8vIEBicm93c2VyLWlzc3VlIEdlY2tvIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMjgwNTRcbiAgICB2YXIgdGFiaW5kZXggPSBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSwgMTApO1xuICAgIHJldHVybiBpc05hTih0YWJpbmRleCkgPyAtMSA6IHRhYmluZGV4O1xufVxuLy8gdGhpcyBpcyBhIHNoYXJlZCB1dGlsaXR5IGZpbGUgZm9yIGZvY3VzLXJlbGV2YW50LmpzIGFuZCB0YWJiYWJsZS5qc1xuLy8gc2VwYXJhdGUgdGVzdGluZyBvZiB0aGlzIGZpbGUncyBmdW5jdGlvbnMgaXMgbm90IG5lY2Vzc2FyeSxcbi8vIGFzIHRoZXkncmUgaW1wbGljaXRseSB0ZXN0ZWQgYnkgd2F5IG9mIHRoZSBjb25zdW1lcnNcbmZ1bmN0aW9uIGlzVXNlck1vZGlmeVdyaXRhYmxlKHN0eWxlKSB7XG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzE5OTkvV0QtY3NzMy11c2VyaW50LTE5OTkwOTE2I3VzZXItbW9kaWZ5XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8xN1xuICAgIHZhciB1c2VyTW9kaWZ5ID0gc3R5bGUud2Via2l0VXNlck1vZGlmeSB8fCBcIlwiO1xuICAgIHJldHVybiBCb29sZWFuKHVzZXJNb2RpZnkgJiYgdXNlck1vZGlmeS5pbmRleE9mKFwid3JpdGVcIikgIT09IC0xKTtcbn1cbmZ1bmN0aW9uIGhhc0Nzc092ZXJmbG93U2Nyb2xsKHN0eWxlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIm92ZXJmbG93XCIpLFxuICAgICAgICBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwib3ZlcmZsb3cteFwiKSxcbiAgICAgICAgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIm92ZXJmbG93LXlcIilcbiAgICBdLnNvbWUoZnVuY3Rpb24ob3ZlcmZsb3cpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJmbG93ID09PSBcImF1dG9cIiB8fCBvdmVyZmxvdyA9PT0gXCJzY3JvbGxcIjtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGhhc0Nzc0Rpc3BsYXlGbGV4KHN0eWxlKSB7XG4gICAgcmV0dXJuIHN0eWxlLmRpc3BsYXkuaW5kZXhPZihcImZsZXhcIikgPiAtMTtcbn1cbmZ1bmN0aW9uIGlzU2Nyb2xsYWJsZUNvbnRhaW5lcihlbGVtZW50LCBub2RlTmFtZSwgcGFyZW50Tm9kZU5hbWUsIHBhcmVudFN0eWxlKSB7XG4gICAgaWYgKG5vZGVOYW1lICE9PSBcImRpdlwiICYmIG5vZGVOYW1lICE9PSBcInNwYW5cIikge1xuICAgICAgICAvLyBJbnRlcm5ldCBFeHBsb3JlciBhZHZhbmNlcyBzY3JvbGxhYmxlIGNvbnRhaW5lcnMgYW5kIGJvZGllcyB0byBmb2N1c2FibGVcbiAgICAgICAgLy8gb25seSBpZiB0aGUgc2Nyb2xsYWJsZSBjb250YWluZXIgaXMgPGRpdj4gb3IgPHNwYW4+IC0gdGhpcyBkb2VzICpub3QqXG4gICAgICAgIC8vIGhhcHBlbiBmb3IgPHNlY3Rpb24+LCA8YXJ0aWNsZT4sIOKAplxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwYXJlbnROb2RlTmFtZSAmJiBwYXJlbnROb2RlTmFtZSAhPT0gXCJkaXZcIiAmJiBwYXJlbnROb2RlTmFtZSAhPT0gXCJzcGFuXCIgJiYgIWhhc0Nzc092ZXJmbG93U2Nyb2xsKHBhcmVudFN0eWxlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50Lm9mZnNldEhlaWdodCA8IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0IHx8IGVsZW1lbnQub2Zmc2V0V2lkdGggPCBlbGVtZW50LnNjcm9sbFdpZHRoO1xufVxudmFyIHN1cHBvcnRzJDEgPSB2b2lkIDA7XG5mdW5jdGlvbiBpc0ZvY3VzUmVsZXZhbnRSdWxlcygpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsIF9yZWYkZXhjZXB0ID0gX3JlZi5leGNlcHQsIGV4Y2VwdCA9IF9yZWYkZXhjZXB0ID09PSB1bmRlZmluZWQgPyB7XG4gICAgICAgIGZsZXhib3g6IGZhbHNlLFxuICAgICAgICBzY3JvbGxhYmxlOiBmYWxzZSxcbiAgICAgICAgc2hhZG93OiBmYWxzZVxuICAgIH0gOiBfcmVmJGV4Y2VwdDtcbiAgICBpZiAoIXN1cHBvcnRzJDEpIHtcbiAgICAgICAgc3VwcG9ydHMkMSA9IF9zdXBwb3J0cygpO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHRUb0VsZW1lbnQoe1xuICAgICAgICBsYWJlbDogXCJpcy9mb2N1cy1yZWxldmFudFwiLFxuICAgICAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9KTtcbiAgICBpZiAoIWV4Y2VwdC5zaGFkb3cgJiYgZWxlbWVudC5zaGFkb3dSb290KSB7XG4gICAgICAgIC8vIGEgU2hhZG93RE9NIGhvc3QgcmVjZWl2ZXMgZm9jdXMgd2hlbiB0aGUgZm9jdXMgbW92ZXMgdG8gaXRzIGNvbnRlbnRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtZW50LnR5cGUgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgICAgLy8gaW5wdXRbdHlwZT1cImhpZGRlblwiXSBzdXBwb3J0cy5jYW5ub3QgYmUgZm9jdXNlZFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInNlbGVjdFwiIHx8IG5vZGVOYW1lID09PSBcImJ1dHRvblwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gXCJsZWdlbmRcIiAmJiBzdXBwb3J0cyQxLmZvY3VzUmVkaXJlY3RMZWdlbmQpIHtcbiAgICAgICAgLy8gc3BlY2lmaWNzIGZpbHRlcmVkIGluIGlzL2ZvY3VzYWJsZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSBcImxhYmVsXCIpIHtcbiAgICAgICAgLy8gc3BlY2lmaWNzIGZpbHRlcmVkIGluIGlzL2ZvY3VzYWJsZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSBcImFyZWFcIikge1xuICAgICAgICAvLyBzcGVjaWZpY3MgZmlsdGVyZWQgaW4gaXMvZm9jdXNhYmxlXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobm9kZU5hbWUgPT09IFwiYVwiICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKFwiaHJlZlwiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSBcIm9iamVjdFwiICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKFwidXNlbWFwXCIpKSB7XG4gICAgICAgIC8vIG9iamVjdFt1c2VtYXBdIGlzIG5vdCBmb2N1c2FibGUgaW4gYW55IGJyb3dzZXJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZU5hbWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIHN2Z1R5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInR5cGVcIik7XG4gICAgICAgIGlmICghc3VwcG9ydHMkMS5mb2N1c09iamVjdFN2ZyAmJiBzdmdUeXBlID09PSBcImltYWdlL3N2Zyt4bWxcIikge1xuICAgICAgICAgICAgLy8gb2JqZWN0W3R5cGU9XCJpbWFnZS9zdmcreG1sXCJdIGlzIG5vdCBmb2N1c2FibGUgaW4gSW50ZXJuZXQgRXhwbG9yZXJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghc3VwcG9ydHMkMS5mb2N1c09iamVjdFN3ZiAmJiBzdmdUeXBlID09PSBcImFwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoXCIpIHtcbiAgICAgICAgICAgIC8vIG9iamVjdFt0eXBlPVwiYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2hcIl0gaXMgbm90IGZvY3VzYWJsZSBpbiBJbnRlcm5ldCBFeHBsb3JlciA5XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSBcImlmcmFtZVwiIHx8IG5vZGVOYW1lID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIGJyb3dzaW5nIGNvbnRleHQgY29udGFpbmVyc1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSBcImVtYmVkXCIgfHwgbm9kZU5hbWUgPT09IFwia2V5Z2VuXCIpIHtcbiAgICAgICAgLy8gZW1iZWQgaXMgY29uc2lkZXJlZCBmb2N1cy1yZWxldmFudCBidXQgbm90IGZvY3VzYWJsZVxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy84MlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpKSB7XG4gICAgICAgIC8vIGFsc28gc2VlIENTUyBwcm9wZXJ0eSB1c2VyLW1vZGlmeSBiZWxvd1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSBcImF1ZGlvXCIgJiYgKHN1cHBvcnRzJDEuZm9jdXNBdWRpb1dpdGhvdXRDb250cm9scyB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZShcImNvbnRyb2xzXCIpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSBcInZpZGVvXCIgJiYgKHN1cHBvcnRzJDEuZm9jdXNWaWRlb1dpdGhvdXRDb250cm9scyB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZShcImNvbnRyb2xzXCIpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnRzJDEuZm9jdXNTdW1tYXJ5ICYmIG5vZGVOYW1lID09PSBcInN1bW1hcnlcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHZhbGlkVGFiaW5kZXggPSBpc1ZhbGlkVGFiaW5kZXgoZWxlbWVudCk7XG4gICAgaWYgKG5vZGVOYW1lID09PSBcImltZ1wiICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKFwidXNlbWFwXCIpKSB7XG4gICAgICAgIC8vIEdlY2tvLCBUcmlkZW50IGFuZCBFZGdlIGRvIG5vdCBhbGxvdyBhbiBpbWFnZSB3aXRoIGFuIGltYWdlIG1hcCBhbmQgdGFiaW5kZXggdG8gYmUgZm9jdXNlZCxcbiAgICAgICAgLy8gaXQgYXBwZWFycyB0aGUgdGFiaW5kZXggaXMgb3ZlcnJ1bGVkIHNvIGZvY3VzIGlzIHN0aWxsIGZvcndhcmRlZCB0byB0aGUgPG1hcD5cbiAgICAgICAgcmV0dXJuIHZhbGlkVGFiaW5kZXggJiYgc3VwcG9ydHMkMS5mb2N1c0ltZ1VzZW1hcFRhYmluZGV4IHx8IHN1cHBvcnRzJDEuZm9jdXNSZWRpcmVjdEltZ1VzZW1hcDtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnRzJDEuZm9jdXNUYWJsZSAmJiAobm9kZU5hbWUgPT09IFwidGFibGVcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZFwiKSkge1xuICAgICAgICAvLyBJRTEwLTExIHN1cHBvcnRzLmNhbiBmb2N1cyA8dGFibGU+IGFuZCA8dGQ+XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHMkMS5mb2N1c0ZpZWxkc2V0ICYmIG5vZGVOYW1lID09PSBcImZpZWxkc2V0XCIpIHtcbiAgICAgICAgLy8gSUUxMC0xMSBzdXBwb3J0cy5jYW4gZm9jdXMgPGZpZWxkc2V0PlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGlzU3ZnRWxlbWVudCA9IG5vZGVOYW1lID09PSBcInN2Z1wiO1xuICAgIHZhciBpc1N2Z0NvbnRlbnQgPSBlbGVtZW50Lm93bmVyU1ZHRWxlbWVudDtcbiAgICB2YXIgZm9jdXNhYmxlQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJmb2N1c2FibGVcIik7XG4gICAgdmFyIHRhYmluZGV4ID0gdGFiaW5kZXhWYWx1ZShlbGVtZW50KTtcbiAgICBpZiAobm9kZU5hbWUgPT09IFwidXNlXCIgJiYgdGFiaW5kZXggIT09IG51bGwgJiYgIXN1cHBvcnRzJDEuZm9jdXNTdmdVc2VUYWJpbmRleCkge1xuICAgICAgICAvLyA8dXNlPiBjYW5ub3QgYmUgbWFkZSBmb2N1c2FibGUgYnkgYWRkaW5nIGEgdGFiaW5kZXggYXR0cmlidXRlIGFueXdoZXJlIGJ1dCBCbGluayBhbmQgV2ViS2l0XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSBcImZvcmVpZ25vYmplY3RcIikge1xuICAgICAgICAvLyA8dXNlPiBjYW4gb25seSBiZSBtYWRlIGZvY3VzYWJsZSBpbiBCbGluayBhbmQgV2ViS2l0XG4gICAgICAgIHJldHVybiB0YWJpbmRleCAhPT0gbnVsbCAmJiBzdXBwb3J0cyQxLmZvY3VzU3ZnRm9yZWlnbm9iamVjdFRhYmluZGV4O1xuICAgIH1cbiAgICBpZiAoZWxlbWVudE1hdGNoZXMoZWxlbWVudCwgXCJzdmcgYVwiKSAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZShcInhsaW5rOmhyZWZcIikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgoaXNTdmdFbGVtZW50IHx8IGlzU3ZnQ29udGVudCkgJiYgZWxlbWVudC5mb2N1cyAmJiAhc3VwcG9ydHMkMS5mb2N1c1N2Z05lZ2F0aXZlVGFiaW5kZXhBdHRyaWJ1dGUgJiYgdGFiaW5kZXggPCAwKSB7XG4gICAgICAgIC8vIEZpcmVmb3ggNTEgYW5kIDUyIHRyZWF0IGFueSBuYXRpdmVseSB0YWJiYWJsZSBTVkcgZWxlbWVudCB3aXRoXG4gICAgICAgIC8vIHRhYmluZGV4PVwiLTFcIiBhcyB0YWJiYWJsZSBhbmQgZXZlcnl0aGluZyBlbHNlIGFzIGluZXJ0XG4gICAgICAgIC8vIHNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzAyMzQwXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlzU3ZnRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdmFsaWRUYWJpbmRleCB8fCBzdXBwb3J0cyQxLmZvY3VzU3ZnIHx8IHN1cHBvcnRzJDEuZm9jdXNTdmdJbklmcmFtZSB8fCAvLyBJbnRlcm5ldCBFeHBsb3JlciB1bmRlcnN0YW5kcyB0aGUgZm9jdXNhYmxlIGF0dHJpYnV0ZSBpbnRyb2R1Y2VkIGluIFNWRyBUaW55IDEuMlxuICAgICAgICBCb29sZWFuKHN1cHBvcnRzJDEuZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUgJiYgZm9jdXNhYmxlQXR0cmlidXRlICYmIGZvY3VzYWJsZUF0dHJpYnV0ZSA9PT0gXCJ0cnVlXCIpO1xuICAgIH1cbiAgICBpZiAoaXNTdmdDb250ZW50KSB7XG4gICAgICAgIGlmIChzdXBwb3J0cyQxLmZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUgJiYgdmFsaWRUYWJpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1cHBvcnRzJDEuZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIHVuZGVyc3RhbmRzIHRoZSBmb2N1c2FibGUgYXR0cmlidXRlIGludHJvZHVjZWQgaW4gU1ZHIFRpbnkgMS4yXG4gICAgICAgICAgICByZXR1cm4gZm9jdXNhYmxlQXR0cmlidXRlID09PSBcInRydWVcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZWRpdGluZy5odG1sI3NlcXVlbnRpYWwtZm9jdXMtbmF2aWdhdGlvbi1hbmQtdGhlLXRhYmluZGV4LWF0dHJpYnV0ZVxuICAgIGlmICh2YWxpZFRhYmluZGV4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgICBpZiAoaXNVc2VyTW9kaWZ5V3JpdGFibGUoc3R5bGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHMkMS5mb2N1c0ltZ0lzbWFwICYmIG5vZGVOYW1lID09PSBcImltZ1wiICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKFwiaXNtYXBcIikpIHtcbiAgICAgICAgLy8gSUUxMC0xMSBjb25zaWRlcnMgdGhlIDxpbWc+IGluIDxhIGhyZWY+PGltZyBpc21hcD4gZm9jdXNhYmxlXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMjBcbiAgICAgICAgdmFyIGhhc0xpbmtQYXJlbnQgPSBnZXRQYXJlbnRzKHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGVsZW1lbnRcbiAgICAgICAgfSkuc29tZShmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJhXCIgJiYgcGFyZW50Lmhhc0F0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzTGlua1BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8yMVxuICAgIGlmICghZXhjZXB0LnNjcm9sbGFibGUgJiYgc3VwcG9ydHMkMS5mb2N1c1Njcm9sbENvbnRhaW5lcikge1xuICAgICAgICBpZiAoc3VwcG9ydHMkMS5mb2N1c1Njcm9sbENvbnRhaW5lcldpdGhvdXRPdmVyZmxvdykge1xuICAgICAgICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgZG9lcyB3aWxsIGNvbnNpZGVyIHRoZSBzY3JvbGxhYmxlIGFyZWEgZm9jdXNhYmxlXG4gICAgICAgICAgICAvLyBpZiB0aGUgZWxlbWVudCBpcyBhIDxkaXY+IG9yIGEgPHNwYW4+IGFuZCBpdCBpcyBpbiBmYWN0IHNjcm9sbGFibGUsXG4gICAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHRoZSBDU1Mgb3ZlcmZsb3cgcHJvcGVydHlcbiAgICAgICAgICAgIGlmIChpc1Njcm9sbGFibGVDb250YWluZXIoZWxlbWVudCwgbm9kZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzQ3NzT3ZlcmZsb3dTY3JvbGwoc3R5bGUpKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IHJlcXVpcmVzIHByb3BlciBvdmVyZmxvdyBzZXR0aW5nLCBJRSBkb2VzIG5vdCBuZWNlc3NhcmlseVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL292ZXJmbG93XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWV4Y2VwdC5mbGV4Ym94ICYmIHN1cHBvcnRzJDEuZm9jdXNGbGV4Ym94Q29udGFpbmVyICYmIGhhc0Nzc0Rpc3BsYXlGbGV4KHN0eWxlKSkge1xuICAgICAgICAvLyBlbGVtZW50cyB3aXRoIGRpc3BsYXk6ZmxleCBhcmUgZm9jdXNhYmxlIGluIElFMTAtMTFcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKCFleGNlcHQuc2Nyb2xsYWJsZSAmJiBwYXJlbnQpIHtcbiAgICAgICAgdmFyIHBhcmVudE5vZGVOYW1lID0gcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBwYXJlbnRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudCwgbnVsbCk7XG4gICAgICAgIGlmIChzdXBwb3J0cyQxLmZvY3VzU2Nyb2xsQm9keSAmJiBpc1Njcm9sbGFibGVDb250YWluZXIocGFyZW50LCBub2RlTmFtZSwgcGFyZW50Tm9kZU5hbWUsIHBhcmVudFN0eWxlKSkge1xuICAgICAgICAgICAgLy8gc2Nyb2xsYWJsZSBib2RpZXMgYXJlIGZvY3VzYWJsZSBJbnRlcm5ldCBFeHBsb3JlclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8yMVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hpbGRyZW4gb2YgZm9jdXNhYmxlIGVsZW1lbnRzIHdpdGggZGlzcGxheTpmbGV4IGFyZSBmb2N1c2FibGUgaW4gSUUxMC0xMVxuICAgICAgICBpZiAoc3VwcG9ydHMkMS5mb2N1c0NoaWxkcmVuT2ZGb2N1c2FibGVGbGV4Ym94KSB7XG4gICAgICAgICAgICBpZiAoaGFzQ3NzRGlzcGxheUZsZXgocGFyZW50U3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTk9URTogZWxlbWVudHMgbWFya2VkIGFzIGluZXJ0IGFyZSBub3QgZm9jdXNhYmxlLFxuICAgIC8vIGJ1dCB0aGF0IHByb3BlcnR5IGlzIG5vdCBleHBvc2VkIHRvIHRoZSBET01cbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZWRpdGluZy5odG1sI2luZXJ0XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gYmluZCBleGNlcHRpb25zIHRvIGFuIGl0ZXJhdG9yIGNhbGxiYWNrXG5pc0ZvY3VzUmVsZXZhbnRSdWxlcy5leGNlcHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXhjZXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgaXNGb2N1c1JlbGV2YW50ID0gZnVuY3Rpb24gaXNGb2N1c1JlbGV2YW50KGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGlzRm9jdXNSZWxldmFudFJ1bGVzKHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICBleGNlcHQ6IGV4Y2VwdFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGlzRm9jdXNSZWxldmFudC5ydWxlcyA9IGlzRm9jdXNSZWxldmFudFJ1bGVzO1xuICAgIHJldHVybiBpc0ZvY3VzUmVsZXZhbnQ7XG59O1xuLy8gcHJvdmlkZSBpc0ZvY3VzUmVsZXZhbnQoY29udGV4dCkgYXMgZGVmYXVsdCBpdGVyYXRvciBjYWxsYmFja1xudmFyIGlzRm9jdXNSZWxldmFudCA9IGlzRm9jdXNSZWxldmFudFJ1bGVzLmV4Y2VwdCh7fSk7XG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIGNhbGxiYWNrKSB7XG4gICAgLy8gYXR0ZW1wdCB0byB1c2UgbmF0aXZlIG9yIHBvbHlmaWxsZWQgQXJyYXkjZmluZEluZGV4IGZpcnN0XG4gICAgaWYgKGFycmF5LmZpbmRJbmRleCkge1xuICAgICAgICByZXR1cm4gYXJyYXkuZmluZEluZGV4KGNhbGxiYWNrKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAvLyBzaG9ydGN1dCBpZiB0aGUgYXJyYXkgaXMgZW1wdHlcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlIGxvb3Agb3ZlciBhcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmIChjYWxsYmFjayhhcnJheVtpXSwgaSwgYXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBnZXRDb250ZW50RG9jdW1lbnQobm9kZSkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIHdvcmtzIG9uIDxvYmplY3Q+IGFuZCA8aWZyYW1lPlxuICAgICAgICByZXR1cm4gbm9kZS5jb250ZW50RG9jdW1lbnQgfHwgLy8gd29ya3Mgb24gPG9iamVjdD4gYW5kIDxpZnJhbWU+XG4gICAgICAgIG5vZGUuY29udGVudFdpbmRvdyAmJiBub2RlLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQgfHwgLy8gd29ya3Mgb24gPG9iamVjdD4gYW5kIDxpZnJhbWU+IHRoYXQgY29udGFpbiBTVkdcbiAgICAgICAgbm9kZS5nZXRTVkdEb2N1bWVudCAmJiBub2RlLmdldFNWR0RvY3VtZW50KCkgfHwgbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFNlY3VyaXR5RXJyb3I6IEZhaWxlZCB0byByZWFkIHRoZSAnY29udGVudERvY3VtZW50JyBwcm9wZXJ0eSBmcm9tICdIVE1MT2JqZWN0RWxlbWVudCdcbiAgICAgICAgLy8gYWxzbyBJRSBtYXkgdGhyb3cgbWVtYmVyIG5vdCBmb3VuZCBleGNlcHRpb24gZS5nLiBvbiA8b2JqZWN0IHR5cGU9XCJpbWFnZS9wbmdcIj5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgICB2YXIgX2RvY3VtZW50ID0gZ2V0RG9jdW1lbnQobm9kZSk7XG4gICAgcmV0dXJuIF9kb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG59XG52YXIgc2hhZG93UHJlZml4ID0gdm9pZCAwO1xuZnVuY3Rpb24gc2VsZWN0SW5TaGFkb3dzKHNlbGVjdG9yKSB7XG4gICAgaWYgKHR5cGVvZiBzaGFkb3dQcmVmaXggIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIG9wZXJhdG9yID0gY3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvcigpO1xuICAgICAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHNoYWRvd1ByZWZpeCA9IFwiLCBodG1sIFwiICsgb3BlcmF0b3IgKyBcIiBcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXNoYWRvd1ByZWZpeCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RvciArIHNoYWRvd1ByZWZpeCArIHNlbGVjdG9yLnJlcGxhY2UoL1xccyosXFxzKi9nLCBcIixcIikuc3BsaXQoXCIsXCIpLmpvaW4oc2hhZG93UHJlZml4KTtcbn1cbnZhciBzZWxlY3RvciA9IHZvaWQgMDtcbmZ1bmN0aW9uIGZpbmREb2N1bWVudEhvc3RFbGVtZW50KF93aW5kb3cpIHtcbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0SW5TaGFkb3dzKFwib2JqZWN0LCBpZnJhbWVcIik7XG4gICAgfVxuICAgIGlmIChfd2luZG93Ll9mcmFtZUVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gX3dpbmRvdy5fZnJhbWVFbGVtZW50O1xuICAgIH1cbiAgICBfd2luZG93Ll9mcmFtZUVsZW1lbnQgPSBudWxsO1xuICAgIHZhciBwb3RlbnRpYWxIb3N0cyA9IF93aW5kb3cucGFyZW50LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIFtdLnNvbWUuY2FsbChwb3RlbnRpYWxIb3N0cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICB2YXIgX2RvY3VtZW50ID0gZ2V0Q29udGVudERvY3VtZW50KGVsZW1lbnQpO1xuICAgICAgICBpZiAoX2RvY3VtZW50ICE9PSBfd2luZG93LmRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgX3dpbmRvdy5fZnJhbWVFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIF93aW5kb3cuX2ZyYW1lRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGdldEZyYW1lRWxlbWVudChlbGVtZW50KSB7XG4gICAgdmFyIF93aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gICAgaWYgKCFfd2luZG93LnBhcmVudCB8fCBfd2luZG93LnBhcmVudCA9PT0gX3dpbmRvdykge1xuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBwYXJlbnQgYnJvd3NpbmcgY29udGV4dCxcbiAgICAgICAgLy8gd2UncmUgbm90IGdvaW5nIHRvIGdldCBhIGZyYW1lRWxlbWVudCBlaXRoZXIgd2F5XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1dpbmRvdy9mcmFtZUVsZW1lbnRcbiAgICAgICAgLy8gZG9lcyBub3Qgd29yayB3aXRoaW4gPGVtYmVkPiBhbnl3aGVyZSwgYW5kIG5vdCB3aXRoaW4gaW4gPG9iamVjdD4gaW4gSUVcbiAgICAgICAgcmV0dXJuIF93aW5kb3cuZnJhbWVFbGVtZW50IHx8IGZpbmREb2N1bWVudEhvc3RFbGVtZW50KF93aW5kb3cpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3JlbmRlcmluZy5odG1sI2JlaW5nLXJlbmRlcmVkXG4vLyA8YXJlYT4gaXMgbm90IHJlbmRlcmVkLCBidXQgd2UgKmNvbnNpZGVyKiBpdCB2aXNpYmxlIHRvIHNpbXBsZml5IHRoaXMgZnVuY3Rpb24ncyB1c2FnZVxudmFyIG5vdFJlbmRlcmVkRWxlbWVudHNQYXR0ZXJuID0gL14oYXJlYSkkLztcbmZ1bmN0aW9uIGNvbXB1dGVkU3R5bGUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG59XG5mdW5jdGlvbiBub3REaXNwbGF5ZWQoX3BhdGgpIHtcbiAgICByZXR1cm4gX3BhdGguc29tZShmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIC8vIGRpc3BsYXk6bm9uZSBpcyBub3QgdmlzaWJsZSAob3B0aW1pemVkIGF3YXkgYXQgbGF5b3V0KVxuICAgICAgICByZXR1cm4gY29tcHV0ZWRTdHlsZShlbGVtZW50LCBcImRpc3BsYXlcIikgPT09IFwibm9uZVwiO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbm90VmlzaWJsZShfcGF0aCkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5LXVpL2Jsb2IvbWFzdGVyL3VpL2NvcmUuanMjTDEwOS1MMTE0XG4gICAgLy8gTk9URTogYSBuZXN0ZWQgZWxlbWVudCBjYW4gcmV2ZXJzZSB2aXNpYmlsaXR5OmhpZGRlbnxjb2xsYXBzZSBieSBleHBsaWNpdGx5IHNldHRpbmcgdmlzaWJpbGl0eTp2aXNpYmxlXG4gICAgLy8gTk9URTogdmlzaWJpbGl0eSBjYW4gYmUgW1wiXCIsIFwidmlzaWJsZVwiLCBcImhpZGRlblwiLCBcImNvbGxhcHNlXCJdXG4gICAgdmFyIGhpZGRlbiA9IGZpbmRJbmRleChfcGF0aCwgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICB2YXIgdmlzaWJpbGl0eSA9IGNvbXB1dGVkU3R5bGUoZWxlbWVudCwgXCJ2aXNpYmlsaXR5XCIpO1xuICAgICAgICByZXR1cm4gdmlzaWJpbGl0eSA9PT0gXCJoaWRkZW5cIiB8fCB2aXNpYmlsaXR5ID09PSBcImNvbGxhcHNlXCI7XG4gICAgfSk7XG4gICAgaWYgKGhpZGRlbiA9PT0gLTEpIHtcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gaGlkZGVuIGVsZW1lbnRcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdmlzaWJsZSA9IGZpbmRJbmRleChfcGF0aCwgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gY29tcHV0ZWRTdHlsZShlbGVtZW50LCBcInZpc2liaWxpdHlcIikgPT09IFwidmlzaWJsZVwiO1xuICAgIH0pO1xuICAgIGlmICh2aXNpYmxlID09PSAtMSkge1xuICAgICAgICAvLyB0aGVyZSBpcyBubyB2aXNpYmxlIGVsZW1lbnQgKGJ1dCBhIGhpZGRlbiBlbGVtZW50KVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGhpZGRlbiA8IHZpc2libGUpIHtcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBoaWRkZW4gZWxlbWVudCBhbmQgaXQncyBjbG9zZXIgdGhhbiB0aGUgZmlyc3QgdmlzaWJsZSBlbGVtZW50XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyB0aGVyZSBtYXkgYmUgYSBoaWRkZW4gZWxlbWVudCwgYnV0IHRoZSBjbG9zZXN0IGVsZW1lbnQgaXMgdmlzaWJsZVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvbGxhcHNlZFBhcmVudChfcGF0aCkge1xuICAgIHZhciBvZmZzZXQgPSAxO1xuICAgIGlmIChfcGF0aFswXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInN1bW1hcnlcIikge1xuICAgICAgICBvZmZzZXQgPSAyO1xuICAgIH1cbiAgICByZXR1cm4gX3BhdGguc2xpY2Uob2Zmc2V0KS5zb21lKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gXCJjb250ZW50IGNoaWxkcmVuXCIgb2YgYSBjbG9zZWQgZGV0YWlscyBlbGVtZW50IGFyZSBub3QgdmlzaWJsZVxuICAgICAgICByZXR1cm4gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImRldGFpbHNcIiAmJiBlbGVtZW50Lm9wZW4gPT09IGZhbHNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNWaXNpYmxlUnVsZXMoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LCBjb250ZXh0ID0gX3JlZi5jb250ZXh0LCBfcmVmJGV4Y2VwdCA9IF9yZWYuZXhjZXB0LCBleGNlcHQgPSBfcmVmJGV4Y2VwdCA9PT0gdW5kZWZpbmVkID8ge1xuICAgICAgICBub3RSZW5kZXJlZDogZmFsc2UsXG4gICAgICAgIGNzc0Rpc3BsYXk6IGZhbHNlLFxuICAgICAgICBjc3NWaXNpYmlsaXR5OiBmYWxzZSxcbiAgICAgICAgZGV0YWlsc0VsZW1lbnQ6IGZhbHNlLFxuICAgICAgICBicm93c2luZ0NvbnRleHQ6IGZhbHNlXG4gICAgfSA6IF9yZWYkZXhjZXB0O1xuICAgIHZhciBlbGVtZW50ID0gY29udGV4dFRvRWxlbWVudCh7XG4gICAgICAgIGxhYmVsOiBcImlzL3Zpc2libGVcIixcbiAgICAgICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfSk7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghZXhjZXB0Lm5vdFJlbmRlcmVkICYmIG5vdFJlbmRlcmVkRWxlbWVudHNQYXR0ZXJuLnRlc3Qobm9kZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgX3BhdGggPSBnZXRQYXJlbnRzKHtcbiAgICAgICAgY29udGV4dDogZWxlbWVudFxuICAgIH0pO1xuICAgIC8vIGluIEludGVybmV0IEV4cGxvcmVyIDxhdWRpbz4gaGFzIGEgZGVmYXVsdCBkaXNwbGF5OiBub25lLCB3aGVyZSBvdGhlcnMgaGF2ZSBkaXNwbGF5OiBpbmxpbmVcbiAgICAvLyBidXQgSUUgYWxsb3dzIGZvY3VzaW5nIDxhdWRpbyBzdHlsZT1cImRpc3BsYXk6bm9uZVwiPiwgYnV0IG5vdCA8ZGl2IGRpc3BsYXk6bm9uZT48YXVkaW8+XG4gICAgLy8gdGhpcyBpcyBpcnJlbGV2YW50IHRvIG90aGVyIGJyb3dzZXJzLCBhcyB0aGUgY29udHJvbHMgYXR0cmlidXRlIGlzIHJlcXVpcmVkIHRvIG1ha2UgPGF1ZGlvPiBmb2N1c2FibGVcbiAgICB2YXIgaXNBdWRpb1dpdGhvdXRDb250cm9scyA9IG5vZGVOYW1lID09PSBcImF1ZGlvXCIgJiYgIWVsZW1lbnQuaGFzQXR0cmlidXRlKFwiY29udHJvbHNcIik7XG4gICAgaWYgKCFleGNlcHQuY3NzRGlzcGxheSAmJiBub3REaXNwbGF5ZWQoaXNBdWRpb1dpdGhvdXRDb250cm9scyA/IF9wYXRoLnNsaWNlKDEpIDogX3BhdGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFleGNlcHQuY3NzVmlzaWJpbGl0eSAmJiBub3RWaXNpYmxlKF9wYXRoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZXhjZXB0LmRldGFpbHNFbGVtZW50ICYmIGNvbGxhcHNlZFBhcmVudChfcGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWV4Y2VwdC5icm93c2luZ0NvbnRleHQpIHtcbiAgICAgICAgLy8gZWxlbWVudHMgd2l0aGluIGEgYnJvd3NpbmcgY29udGV4dCBhcmUgYWZmZWN0ZWQgYnkgdGhlXG4gICAgICAgIC8vIGJyb3dzaW5nIGNvbnRleHQgaG9zdCBlbGVtZW50J3MgdmlzaWJpbGl0eSBhbmQgdGFiaW5kZXhcbiAgICAgICAgdmFyIGZyYW1lRWxlbWVudCA9IGdldEZyYW1lRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgdmFyIF9pc1Zpc2libGUgPSBpc1Zpc2libGVSdWxlcy5leGNlcHQoZXhjZXB0KTtcbiAgICAgICAgaWYgKGZyYW1lRWxlbWVudCAmJiAhX2lzVmlzaWJsZShmcmFtZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBiaW5kIGV4Y2VwdGlvbnMgdG8gYW4gaXRlcmF0b3IgY2FsbGJhY2tcbmlzVmlzaWJsZVJ1bGVzLmV4Y2VwdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBleGNlcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBpc1Zpc2libGUgPSBmdW5jdGlvbiBpc1Zpc2libGUoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gaXNWaXNpYmxlUnVsZXMoe1xuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgIGV4Y2VwdDogZXhjZXB0XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgaXNWaXNpYmxlLnJ1bGVzID0gaXNWaXNpYmxlUnVsZXM7XG4gICAgcmV0dXJuIGlzVmlzaWJsZTtcbn07XG4vLyBwcm92aWRlIGlzVmlzaWJsZShjb250ZXh0KSBhcyBkZWZhdWx0IGl0ZXJhdG9yIGNhbGxiYWNrXG52YXIgaXNWaXNpYmxlID0gaXNWaXNpYmxlUnVsZXMuZXhjZXB0KHt9KTtcbmZ1bmN0aW9uIGdldE1hcEJ5TmFtZShuYW1lLCBfZG9jdW1lbnQpIHtcbiAgICAvLyBhcHBhcmVudGx5IGdldEVsZW1lbnRzQnlOYW1lKCkgYWxzbyBjb25zaWRlcnMgaWQgYXR0cmlidXRlIGluIElFICYgb3BlcmFcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvZ2V0RWxlbWVudHNCeU5hbWVcbiAgICB2YXIgbWFwID0gX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21hcFtuYW1lPVwiJyArICgwLCBfY3NzZXNjYXBlLmRlZmF1bHQpKG5hbWUpICsgJ1wiXScpO1xuICAgIHJldHVybiBtYXAgfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEltYWdlT2ZBcmVhKGVsZW1lbnQpIHtcbiAgICB2YXIgbWFwID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIGlmICghbWFwLm5hbWUgfHwgbWFwLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwibWFwXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIE5PVEU6IGltYWdlIG1hcHMgY2FuIGFsc28gYmUgYXBwbGllZCB0byA8b2JqZWN0PiB3aXRoIGltYWdlIGNvbnRlbnQsXG4gICAgLy8gYnV0IG5vIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyBhdCB0aGUgbW9tZW50XG4gICAgLy8gSFRNTDUgc3BlY2lmaWVzIEhUTUxNYXBFbGVtZW50LmltYWdlcyB0byBiZSBhbiBIVE1MQ29sbGVjdGlvbiBvZiBhbGxcbiAgICAvLyA8aW1nPiBhbmQgPG9iamVjdD4gcmVmZXJlbmNpbmcgdGhlIDxtYXA+IGVsZW1lbnQsIGJ1dCBubyBicm93c2VyIGltcGxlbWVudHMgdGhpc1xuICAgIC8vICAgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI3RoZS1tYXAtZWxlbWVudFxuICAgIC8vICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxNYXBFbGVtZW50XG4gICAgLy8gdGhlIGltYWdlIG11c3QgYmUgdmFsaWQgYW5kIGxvYWRlZCBmb3IgdGhlIG1hcCB0byB0YWtlIGVmZmVjdFxuICAgIHZhciBfZG9jdW1lbnQgPSBnZXREb2N1bWVudChlbGVtZW50KTtcbiAgICByZXR1cm4gX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2ltZ1t1c2VtYXA9XCIjJyArICgwLCBfY3NzZXNjYXBlLmRlZmF1bHQpKG1hcC5uYW1lKSArICdcIl0nKSB8fCBudWxsO1xufVxudmFyIHN1cHBvcnRzJDIgPSB2b2lkIDA7XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvbWFwXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItdXNlbWFwXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS11aS9ibG9iL21hc3Rlci91aS9jb3JlLmpzI0w4OC1MMTA3XG5mdW5jdGlvbiBpc1ZhbGlkQXJlYShjb250ZXh0KSB7XG4gICAgaWYgKCFzdXBwb3J0cyQyKSB7XG4gICAgICAgIHN1cHBvcnRzJDIgPSBfc3VwcG9ydHMoKTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0VG9FbGVtZW50KHtcbiAgICAgICAgbGFiZWw6IFwiaXMvdmFsaWQtYXJlYVwiLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfSk7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChub2RlTmFtZSAhPT0gXCJhcmVhXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgaGFzVGFiaW5kZXggPSBlbGVtZW50Lmhhc0F0dHJpYnV0ZShcInRhYmluZGV4XCIpO1xuICAgIGlmICghc3VwcG9ydHMkMi5mb2N1c0FyZWFUYWJpbmRleCAmJiBoYXNUYWJpbmRleCkge1xuICAgICAgICAvLyBCbGluayBhbmQgV2ViS2l0IGRvIG5vdCBjb25zaWRlciA8YXJlYSB0YWJpbmRleD1cIi0xXCIgaHJlZj1cIiN2b2lkXCI+IGZvY3VzYWJsZVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBpbWcgPSBnZXRJbWFnZU9mQXJlYShlbGVtZW50KTtcbiAgICBpZiAoIWltZyB8fCAhaXNWaXNpYmxlKGltZykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBGaXJlZm94IG9ubHkgYWxsb3dzIGZ1bGx5IGxvYWRlZCBpbWFnZXMgdG8gcmVmZXJlbmNlIGltYWdlIG1hcHNcbiAgICAvLyBodHRwczovL3N0ZXJlb2Nocm8ubWUvaWRlYXMvZGV0ZWN0aW5nLWJyb2tlbi1pbWFnZXMtanNcbiAgICBpZiAoIXN1cHBvcnRzJDIuZm9jdXNCcm9rZW5JbWFnZU1hcCAmJiAoIWltZy5jb21wbGV0ZSB8fCAhaW1nLm5hdHVyYWxIZWlnaHQgfHwgaW1nLm9mZnNldFdpZHRoIDw9IDAgfHwgaW1nLm9mZnNldEhlaWdodCA8PSAwKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEZpcmVmb3ggc3VwcG9ydHMuY2FuIGZvY3VzIGFyZWEgZWxlbWVudHMgZXZlbiBpZiB0aGV5IGRvbid0IGhhdmUgYW4gaHJlZiBhdHRyaWJ1dGVcbiAgICBpZiAoIXN1cHBvcnRzJDIuZm9jdXNBcmVhV2l0aG91dEhyZWYgJiYgIWVsZW1lbnQuaHJlZikge1xuICAgICAgICAvLyBJbnRlcm5ldCBleHBsb3JlciBzdXBwb3J0cy5jYW4gZm9jdXMgYXJlYSBlbGVtZW50cyB3aXRob3V0IGhyZWYgaWYgZWl0aGVyXG4gICAgICAgIC8vIHRoZSBhcmVhIGVsZW1lbnQgb3IgdGhlIGltYWdlIGVsZW1lbnQgaGFzIGEgdGFiaW5kZXggYXR0cmlidXRlXG4gICAgICAgIHJldHVybiBzdXBwb3J0cyQyLmZvY3VzQXJlYVRhYmluZGV4ICYmIGhhc1RhYmluZGV4IHx8IHN1cHBvcnRzJDIuZm9jdXNBcmVhSW1nVGFiaW5kZXggJiYgaW1nLmhhc0F0dHJpYnV0ZShcInRhYmluZGV4XCIpO1xuICAgIH1cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItdXNlbWFwXG4gICAgdmFyIGNoaWxkT2ZJbnRlcmFjdGl2ZSA9IGdldFBhcmVudHMoe1xuICAgICAgICBjb250ZXh0OiBpbWdcbiAgICB9KS5zbGljZSgxKS5zb21lKGZ1bmN0aW9uKF9lbGVtZW50KSB7XG4gICAgICAgIHZhciBuYW1lID0gX2VsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJhXCI7XG4gICAgfSk7XG4gICAgaWYgKGNoaWxkT2ZJbnRlcmFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxudmFyIHN1cHBvcnRzJDMgPSB2b2lkIDA7XG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZGlzYWJsZWQtZWxlbWVudHMuaHRtbCNjb25jZXB0LWVsZW1lbnQtZGlzYWJsZWRcbnZhciBkaXNhYmxlZEVsZW1lbnRzUGF0dGVybiA9IHZvaWQgMDtcbnZhciBkaXNhYmxlZEVsZW1lbnRzID0ge1xuICAgIGlucHV0OiB0cnVlLFxuICAgIHNlbGVjdDogdHJ1ZSxcbiAgICB0ZXh0YXJlYTogdHJ1ZSxcbiAgICBidXR0b246IHRydWUsXG4gICAgZmllbGRzZXQ6IHRydWUsXG4gICAgZm9ybTogdHJ1ZVxufTtcbmZ1bmN0aW9uIGlzTmF0aXZlRGlzYWJsZWRTdXBwb3J0ZWQoY29udGV4dCkge1xuICAgIGlmICghc3VwcG9ydHMkMykge1xuICAgICAgICBzdXBwb3J0cyQzID0gX3N1cHBvcnRzKCk7XG4gICAgICAgIGlmIChzdXBwb3J0cyQzLmZvY3VzRmllbGRzZXREaXNhYmxlZCkge1xuICAgICAgICAgICAgZGVsZXRlIGRpc2FibGVkRWxlbWVudHMuZmllbGRzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1cHBvcnRzJDMuZm9jdXNGb3JtRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkaXNhYmxlZEVsZW1lbnRzLmZvcm07XG4gICAgICAgIH1cbiAgICAgICAgZGlzYWJsZWRFbGVtZW50c1BhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXihcIiArIE9iamVjdC5rZXlzKGRpc2FibGVkRWxlbWVudHMpLmpvaW4oXCJ8XCIpICsgXCIpJFwiKTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0VG9FbGVtZW50KHtcbiAgICAgICAgbGFiZWw6IFwiaXMvbmF0aXZlLWRpc2FibGVkLXN1cHBvcnRlZFwiLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfSk7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBCb29sZWFuKGRpc2FibGVkRWxlbWVudHNQYXR0ZXJuLnRlc3Qobm9kZU5hbWUpKTtcbn1cbnZhciBzdXBwb3J0cyQ0ID0gdm9pZCAwO1xuZnVuY3Rpb24gaXNEaXNhYmxlZEZpZWxkc2V0KGVsZW1lbnQpIHtcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG5vZGVOYW1lID09PSBcImZpZWxkc2V0XCIgJiYgZWxlbWVudC5kaXNhYmxlZDtcbn1cbmZ1bmN0aW9uIGlzRGlzYWJsZWRGb3JtKGVsZW1lbnQpIHtcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG5vZGVOYW1lID09PSBcImZvcm1cIiAmJiBlbGVtZW50LmRpc2FibGVkO1xufVxuZnVuY3Rpb24gaXNEaXNhYmxlZChjb250ZXh0KSB7XG4gICAgaWYgKCFzdXBwb3J0cyQ0KSB7XG4gICAgICAgIHN1cHBvcnRzJDQgPSBfc3VwcG9ydHMoKTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0VG9FbGVtZW50KHtcbiAgICAgICAgbGFiZWw6IFwiaXMvZGlzYWJsZWRcIixcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH0pO1xuICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZShcImRhdGEtYWxseS1kaXNhYmxlZFwiKSkge1xuICAgICAgICAvLyB0cmVhdCBhbGx5J3MgZWxlbWVudC9kaXNhYmxlZCBsaWtlIHRoZSBET00gbmF0aXZlIGVsZW1lbnQuZGlzYWJsZWRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghaXNOYXRpdmVEaXNhYmxlZFN1cHBvcnRlZChlbGVtZW50KSkge1xuICAgICAgICAvLyBub24tZm9ybSBlbGVtZW50cyBkbyBub3Qgc3VwcG9ydCB0aGUgZGlzYWJsZWQgYXR0cmlidXRlXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuZGlzYWJsZWQpIHtcbiAgICAgICAgLy8gdGhlIGVsZW1lbnQgaXRzZWxmIGlzIGRpc2FibGVkXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgcGFyZW50cyA9IGdldFBhcmVudHMoe1xuICAgICAgICBjb250ZXh0OiBlbGVtZW50XG4gICAgfSk7XG4gICAgaWYgKHBhcmVudHMuc29tZShpc0Rpc2FibGVkRmllbGRzZXQpKSB7XG4gICAgICAgIC8vIGEgcGFyZW50YWwgPGZpZWxkc2V0PiBpcyBkaXNhYmxkIGFuZCBpbmhlcml0cyB0aGUgc3RhdGUgb250byB0aGlzIGVsZW1lbnRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghc3VwcG9ydHMkNC5mb2N1c0Zvcm1EaXNhYmxlZCAmJiBwYXJlbnRzLnNvbWUoaXNEaXNhYmxlZEZvcm0pKSB7XG4gICAgICAgIC8vIGEgcGFyZW50YWwgPGZvcm0+IGlzIGRpc2FibGQgYW5kIGluaGVyaXRzIHRoZSBzdGF0ZSBvbnRvIHRoaXMgZWxlbWVudFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNPbmx5VGFiYmFibGVSdWxlcygpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsIF9yZWYkZXhjZXB0ID0gX3JlZi5leGNlcHQsIGV4Y2VwdCA9IF9yZWYkZXhjZXB0ID09PSB1bmRlZmluZWQgPyB7XG4gICAgICAgIG9ubHlGb2N1c2FibGVCcm93c2luZ0NvbnRleHQ6IGZhbHNlLFxuICAgICAgICB2aXNpYmxlOiBmYWxzZVxuICAgIH0gOiBfcmVmJGV4Y2VwdDtcbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHRUb0VsZW1lbnQoe1xuICAgICAgICBsYWJlbDogXCJpcy9vbmx5LXRhYmJhYmxlXCIsXG4gICAgICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH0pO1xuICAgIGlmICghZXhjZXB0LnZpc2libGUgJiYgIWlzVmlzaWJsZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZXhjZXB0Lm9ubHlGb2N1c2FibGVCcm93c2luZ0NvbnRleHQgJiYgKHBsYXRmb3JtLmlzLkdFQ0tPIHx8IHBsYXRmb3JtLmlzLlRSSURFTlQgfHwgcGxhdGZvcm0uaXMuRURHRSkpIHtcbiAgICAgICAgdmFyIGZyYW1lRWxlbWVudCA9IGdldEZyYW1lRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgaWYgKGZyYW1lRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRhYmluZGV4VmFsdWUoZnJhbWVFbGVtZW50KSA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpZnJhbWVbdGFiaW5kZXg9XCItMVwiXSBhbmQgb2JqZWN0W3RhYmluZGV4PVwiLTFcIl0gaW5oZXJpdCB0aGVcbiAgICAgICAgICAgICAgICAvLyB0YWJiYWJsZSBkZW1vdGlvbiBvbnRvIGVsZW1lbnRzIG9mIHRoZWlyIGJyb3dzaW5nIGNvbnRleHRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgdGFiaW5kZXggPSB0YWJpbmRleFZhbHVlKGVsZW1lbnQpO1xuICAgIGlmIChub2RlTmFtZSA9PT0gXCJsYWJlbFwiICYmIHBsYXRmb3JtLmlzLkdFQ0tPKSB7XG4gICAgICAgIC8vIEZpcmVmb3ggY2Fubm90IGZvY3VzLCBidXQgdGFiIHRvOiBsYWJlbFt0YWJpbmRleD0wXVxuICAgICAgICByZXR1cm4gdGFiaW5kZXggIT09IG51bGwgJiYgdGFiaW5kZXggPj0gMDtcbiAgICB9XG4gICAgLy8gU1ZHIEVsZW1lbnRzIHdlcmUga2V5Ym9hcmQgZm9jdXNhYmxlIGJ1dCBub3Qgc2NyaXB0IGZvY3VzYWJsZSBiZWZvcmUgRmlyZWZveCA1MS5cbiAgICAvLyBGaXJlZm94IDUxIGFkZGVkIHRoZSBmb2N1cyBtYW5hZ2VtZW50IERPTSBBUEkgKC5mb2N1cyBhbmQgLmJsdXIpIHRvIFNWR0VsZW1lbnQsXG4gICAgLy8gc2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc3ODY1NFxuICAgIGlmIChwbGF0Zm9ybS5pcy5HRUNLTyAmJiBlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCAmJiAhZWxlbWVudC5mb2N1cykge1xuICAgICAgICBpZiAobm9kZU5hbWUgPT09IFwiYVwiICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKFwieGxpbms6aHJlZlwiKSkge1xuICAgICAgICAgICAgLy8gYW55IGZvY3VzYWJsZSBjaGlsZCBvZiA8c3ZnPiBjYW5ub3QgYmUgZm9jdXNlZCwgYnV0IHRhYmJlZCB0b1xuICAgICAgICAgICAgaWYgKHBsYXRmb3JtLmlzLkdFQ0tPKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gYmluZCBleGNlcHRpb25zIHRvIGFuIGl0ZXJhdG9yIGNhbGxiYWNrXG5pc09ubHlUYWJiYWJsZVJ1bGVzLmV4Y2VwdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBleGNlcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBpc09ubHlUYWJiYWJsZSA9IGZ1bmN0aW9uIGlzT25seVRhYmJhYmxlKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGlzT25seVRhYmJhYmxlUnVsZXMoe1xuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgIGV4Y2VwdDogZXhjZXB0XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgaXNPbmx5VGFiYmFibGUucnVsZXMgPSBpc09ubHlUYWJiYWJsZVJ1bGVzO1xuICAgIHJldHVybiBpc09ubHlUYWJiYWJsZTtcbn07XG4vLyBwcm92aWRlIGlzT25seVRhYmJhYmxlKGNvbnRleHQpIGFzIGRlZmF1bHQgaXRlcmF0b3IgY2FsbGJhY2tcbnZhciBpc09ubHlUYWJiYWJsZSA9IGlzT25seVRhYmJhYmxlUnVsZXMuZXhjZXB0KHt9KTtcbnZhciBzdXBwb3J0cyQ1ID0gdm9pZCAwO1xuZnVuY3Rpb24gaXNPbmx5Rm9jdXNSZWxldmFudChlbGVtZW50KSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChub2RlTmFtZSA9PT0gXCJlbWJlZFwiIHx8IG5vZGVOYW1lID09PSBcImtleWdlblwiKSB7XG4gICAgICAgIC8vIGVtYmVkIGlzIGNvbnNpZGVyZWQgZm9jdXMtcmVsZXZhbnQgYnV0IG5vdCBmb2N1c2FibGVcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvODJcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBfdGFiaW5kZXggPSB0YWJpbmRleFZhbHVlKGVsZW1lbnQpO1xuICAgIGlmIChlbGVtZW50LnNoYWRvd1Jvb3QgJiYgX3RhYmluZGV4ID09PSBudWxsKSB7XG4gICAgICAgIC8vIFNoYWRvd0RPTSBob3N0IGVsZW1lbnRzICptYXkqIHJlY2VpdmUgZm9jdXNcbiAgICAgICAgLy8gZXZlbiB0aG91Z2ggdGhleSBhcmUgbm90IGNvbnNpZGVyZWQgZm9jdWFibGVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gXCJsYWJlbFwiKSB7XG4gICAgICAgIC8vIDxsYWJlbCB0YWJpbmRleD1cIjBcIj4gaXMgb25seSB0YWJiYWJsZSBpbiBGaXJlZm94LCBub3Qgc2NyaXB0LWZvY3VzYWJsZVxuICAgICAgICAvLyB0aGVyZSdzIG5vIHdheSB0byBtYWtlIGFuIGVsZW1lbnQgZm9jdXNhYmxlIG90aGVyIHRoYW4gYnkgYWRkaW5nIGEgdGFiaW5kZXgsXG4gICAgICAgIC8vIGFuZCBmb2N1cyBiZWhhdmlvciBvZiB0aGUgbGFiZWwgZWxlbWVudCBzZWVtcyBoYXJkLXdpcmVkIHRvIGlnbm9yZSB0YWJpbmRleFxuICAgICAgICAvLyBpbiBzb21lIGJyb3dzZXJzIChsaWtlIEdlY2tvLCBCbGluayBhbmQgV2ViS2l0KVxuICAgICAgICByZXR1cm4gIXN1cHBvcnRzJDUuZm9jdXNMYWJlbFRhYmluZGV4IHx8IF90YWJpbmRleCA9PT0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSBcImxlZ2VuZFwiKSB7XG4gICAgICAgIHJldHVybiBfdGFiaW5kZXggPT09IG51bGw7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0cyQ1LmZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlICYmIChlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCB8fCBub2RlTmFtZSA9PT0gXCJzdmdcIikpIHtcbiAgICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgdW5kZXJzdGFuZHMgdGhlIGZvY3VzYWJsZSBhdHRyaWJ1dGUgaW50cm9kdWNlZCBpbiBTVkcgVGlueSAxLjJcbiAgICAgICAgdmFyIGZvY3VzYWJsZUF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZm9jdXNhYmxlXCIpO1xuICAgICAgICByZXR1cm4gZm9jdXNhYmxlQXR0cmlidXRlICYmIGZvY3VzYWJsZUF0dHJpYnV0ZSA9PT0gXCJmYWxzZVwiO1xuICAgIH1cbiAgICBpZiAobm9kZU5hbWUgPT09IFwiaW1nXCIgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJ1c2VtYXBcIikpIHtcbiAgICAgICAgLy8gR2Vja28sIFRyaWRlbnQgYW5kIEVkZ2UgZG8gbm90IGFsbG93IGFuIGltYWdlIHdpdGggYW4gaW1hZ2UgbWFwIGFuZCB0YWJpbmRleCB0byBiZSBmb2N1c2VkLFxuICAgICAgICAvLyBpdCBhcHBlYXJzIHRoZSB0YWJpbmRleCBpcyBvdmVycnVsZWQgc28gZm9jdXMgaXMgc3RpbGwgZm9yd2FyZGVkIHRvIHRoZSA8bWFwPlxuICAgICAgICByZXR1cm4gX3RhYmluZGV4ID09PSBudWxsIHx8ICFzdXBwb3J0cyQ1LmZvY3VzSW1nVXNlbWFwVGFiaW5kZXg7XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gXCJhcmVhXCIpIHtcbiAgICAgICAgLy8gYWxsIDxhcmVhPnMgYXJlIGNvbnNpZGVyZWQgcmVsZXZhbnQsXG4gICAgICAgIC8vIGJ1dCBvbmx5IHRoZSB2YWxpZCA8YXJlYT5zIGFyZSBmb2N1c2FibGVcbiAgICAgICAgcmV0dXJuICFpc1ZhbGlkQXJlYShlbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNGb2N1c2FibGVSdWxlcygpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsIF9yZWYkZXhjZXB0ID0gX3JlZi5leGNlcHQsIGV4Y2VwdCA9IF9yZWYkZXhjZXB0ID09PSB1bmRlZmluZWQgPyB7XG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgIG9ubHlUYWJiYWJsZTogZmFsc2VcbiAgICB9IDogX3JlZiRleGNlcHQ7XG4gICAgaWYgKCFzdXBwb3J0cyQ1KSB7XG4gICAgICAgIHN1cHBvcnRzJDUgPSBfc3VwcG9ydHMoKTtcbiAgICB9XG4gICAgdmFyIF9pc09ubHlUYWJiYWJsZSA9IGlzT25seVRhYmJhYmxlLnJ1bGVzLmV4Y2VwdCh7XG4gICAgICAgIG9ubHlGb2N1c2FibGVCcm93c2luZ0NvbnRleHQ6IHRydWUsXG4gICAgICAgIHZpc2libGU6IGV4Y2VwdC52aXNpYmxlXG4gICAgfSk7XG4gICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0VG9FbGVtZW50KHtcbiAgICAgICAgbGFiZWw6IFwiaXMvZm9jdXNhYmxlXCIsXG4gICAgICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH0pO1xuICAgIHZhciBmb2N1c1JlbGV2YW50ID0gaXNGb2N1c1JlbGV2YW50LnJ1bGVzKHtcbiAgICAgICAgY29udGV4dDogZWxlbWVudCxcbiAgICAgICAgZXhjZXB0OiBleGNlcHRcbiAgICB9KTtcbiAgICBpZiAoIWZvY3VzUmVsZXZhbnQgfHwgaXNPbmx5Rm9jdXNSZWxldmFudChlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZXhjZXB0LmRpc2FibGVkICYmIGlzRGlzYWJsZWQoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWV4Y2VwdC5vbmx5VGFiYmFibGUgJiYgX2lzT25seVRhYmJhYmxlKGVsZW1lbnQpKSB7XG4gICAgICAgIC8vIHNvbWUgZWxlbWVudHMgbWF5IGJlIGtleWJvYXJkIGZvY3VzYWJsZSwgYnV0IG5vdCBzY3JpcHQgZm9jdXNhYmxlXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gZWxlbWVudHMgdGhhdCBhcmUgbm90IHJlbmRlcmVkLCBjYW5ub3QgYmUgZm9jdXNlZFxuICAgIGlmICghZXhjZXB0LnZpc2libGUpIHtcbiAgICAgICAgdmFyIHZpc2liaWxpdHlPcHRpb25zID0ge1xuICAgICAgICAgICAgY29udGV4dDogZWxlbWVudCxcbiAgICAgICAgICAgIGV4Y2VwdDoge31cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHN1cHBvcnRzJDUuZm9jdXNJbkhpZGRlbklmcmFtZSkge1xuICAgICAgICAgICAgLy8gV2ViS2l0IGFuZCBCbGluayBjYW4gZm9jdXMgY29udGVudCBpbiBoaWRkZW4gPGlmcmFtZT4gYW5kIDxvYmplY3Q+XG4gICAgICAgICAgICB2aXNpYmlsaXR5T3B0aW9ucy5leGNlcHQuYnJvd3NpbmdDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VwcG9ydHMkNS5mb2N1c09iamVjdFN2Z0hpZGRlbikge1xuICAgICAgICAgICAgLy8gQmxpbmsgYWxsb3dzIGZvY3VzaW5nIHRoZSBvYmplY3QgZWxlbWVudCwgZXZlbiBpZiBpdCBoYXMgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgICAgICAgICAgLy8gQGJyb3dzZXItaXNzdWUgQmxpbmsgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4NjE5MVxuICAgICAgICAgICAgdmFyIF9ub2RlTmFtZTIgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoX25vZGVOYW1lMiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlPcHRpb25zLmV4Y2VwdC5jc3NWaXNpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVmlzaWJsZS5ydWxlcyh2aXNpYmlsaXR5T3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZnJhbWVFbGVtZW50ID0gZ2V0RnJhbWVFbGVtZW50KGVsZW1lbnQpO1xuICAgIGlmIChmcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF9ub2RlTmFtZSA9IGZyYW1lRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoX25vZGVOYW1lID09PSBcIm9iamVjdFwiICYmICFzdXBwb3J0cyQ1LmZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoIWZyYW1lRWxlbWVudC5vZmZzZXRXaWR0aCB8fCAhZnJhbWVFbGVtZW50Lm9mZnNldEhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIFdlYktpdCBjYW4gbm90IGZvY3VzIGNvbnRlbnQgaW4gPG9iamVjdD4gaWYgaXQgZG9lc24ndCBoYXZlIGRpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChub2RlTmFtZSA9PT0gXCJzdmdcIiAmJiBzdXBwb3J0cyQ1LmZvY3VzU3ZnSW5JZnJhbWUgJiYgIWZyYW1lRWxlbWVudCAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZShcInRhYmluZGV4XCIpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBiaW5kIGV4Y2VwdGlvbnMgdG8gYW4gaXRlcmF0b3IgY2FsbGJhY2tcbmlzRm9jdXNhYmxlUnVsZXMuZXhjZXB0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4Y2VwdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIGlzRm9jdXNhYmxlID0gZnVuY3Rpb24gaXNGb2N1c2FibGUoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gaXNGb2N1c2FibGVSdWxlcyh7XG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgZXhjZXB0OiBleGNlcHRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBpc0ZvY3VzYWJsZS5ydWxlcyA9IGlzRm9jdXNhYmxlUnVsZXM7XG4gICAgcmV0dXJuIGlzRm9jdXNhYmxlO1xufTtcbi8vIHByb3ZpZGUgaXNGb2N1c1JlbGV2YW50KGNvbnRleHQpIGFzIGRlZmF1bHQgaXRlcmF0b3IgY2FsbGJhY2tcbnZhciBpc0ZvY3VzYWJsZSA9IGlzRm9jdXNhYmxlUnVsZXMuZXhjZXB0KHt9KTtcbmZ1bmN0aW9uIGNyZWF0ZUZpbHRlcihjb25kaXRpb24pIHtcbiAgICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL05vZGVGaWx0ZXJcbiAgICB2YXIgZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIFNoYWRvd1Jvb3QgZWxlbWVudHMgcmVnYXJkbGVzcyBvZiB0aGVtIGJlaW5nIGZvY3VzYWJsZSxcbiAgICAgICAgICAgIC8vIHNvIHRoZXkgY2FuIGJlIHdhbGtlZCByZWN1cnNpdmVseSBsYXRlclxuICAgICAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZGl0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBmaW5kcyBlbGVtZW50cyB0aGF0IGNvdWxkIGhhdmUgYmVlbiBmb3VuZCBieSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKClcbiAgICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgfTtcbiAgICAvLyBJRSByZXF1aXJlcyBhIGZ1bmN0aW9uLCBCcm93c2VycyByZXF1aXJlIHthY2NlcHROb2RlOiBmdW5jdGlvbn1cbiAgICAvLyBzZWUgaHR0cDovL3d3dy5iZW5uYWRlbC5jb20vYmxvZy8yNjA3LWZpbmRpbmctaHRtbC1jb21tZW50LW5vZGVzLWluLXRoZS1kb20tdXNpbmctdHJlZXdhbGtlci5odG1cbiAgICBmaWx0ZXIuYWNjZXB0Tm9kZSA9IGZpbHRlcjtcbiAgICByZXR1cm4gZmlsdGVyO1xufVxudmFyIFBvc3NpYmx5Rm9jdXNhYmxlRmlsdGVyID0gY3JlYXRlRmlsdGVyKGlzRm9jdXNSZWxldmFudCk7XG5mdW5jdGlvbiBxdWVyeUZvY3VzYWJsZVN0cmljdCgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsIGluY2x1ZGVDb250ZXh0ID0gX3JlZi5pbmNsdWRlQ29udGV4dCwgaW5jbHVkZU9ubHlUYWJiYWJsZSA9IF9yZWYuaW5jbHVkZU9ubHlUYWJiYWJsZSwgc3RyYXRlZ3kgPSBfcmVmLnN0cmF0ZWd5O1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cbiAgICB2YXIgX2lzRm9jdXNhYmxlID0gaXNGb2N1c2FibGUucnVsZXMuZXhjZXB0KHtcbiAgICAgICAgb25seVRhYmJhYmxlOiBpbmNsdWRlT25seVRhYmJhYmxlXG4gICAgfSk7XG4gICAgdmFyIF9kb2N1bWVudCA9IGdldERvY3VtZW50KGNvbnRleHQpO1xuICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvY3JlYXRlVHJlZVdhbGtlclxuICAgIHZhciB3YWxrZXIgPSBfZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcigvLyByb290IGVsZW1lbnQgdG8gc3RhcnQgc2VhcmNoIGluXG4gICAgY29udGV4dCwgLy8gZWxlbWVudCB0eXBlIGZpbHRlclxuICAgIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCAvLyBjdXN0b20gTm9kZUZpbHRlciBmaWx0ZXJcbiAgICBzdHJhdGVneSA9PT0gXCJhbGxcIiA/IFBvc3NpYmx5Rm9jdXNhYmxlRmlsdGVyIDogY3JlYXRlRmlsdGVyKF9pc0ZvY3VzYWJsZSksIC8vIGRlcHJlY2F0ZWQsIGJ1dCBJRSByZXF1aXJlcyBpdFxuICAgIGZhbHNlKTtcbiAgICB2YXIgbGlzdCA9IFtdO1xuICAgIHdoaWxlKHdhbGtlci5uZXh0Tm9kZSgpKXtcbiAgICAgICAgaWYgKHdhbGtlci5jdXJyZW50Tm9kZS5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICBpZiAoX2lzRm9jdXNhYmxlKHdhbGtlci5jdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2god2Fsa2VyLmN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3QgPSBsaXN0LmNvbmNhdChxdWVyeUZvY3VzYWJsZVN0cmljdCh7XG4gICAgICAgICAgICAgICAgY29udGV4dDogd2Fsa2VyLmN1cnJlbnROb2RlLnNoYWRvd1Jvb3QsXG4gICAgICAgICAgICAgICAgaW5jbHVkZU9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZSxcbiAgICAgICAgICAgICAgICBzdHJhdGVneTogc3RyYXRlZ3lcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3QucHVzaCh3YWxrZXIuY3VycmVudE5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCBjb250ZXh0IGlmIHJlcXVlc3RlZCBhbmQgZm9jdXNhYmxlXG4gICAgaWYgKGluY2x1ZGVDb250ZXh0KSB7XG4gICAgICAgIGlmIChzdHJhdGVneSA9PT0gXCJhbGxcIikge1xuICAgICAgICAgICAgaWYgKGlzRm9jdXNSZWxldmFudChjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIGxpc3QudW5zaGlmdChjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChfaXNGb2N1c2FibGUoY29udGV4dCkpIHtcbiAgICAgICAgICAgIGxpc3QudW5zaGlmdChjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn1cbi8vIE5PVEU6IHRoaXMgc2VsZWN0b3IgTVVTVCAqbmV2ZXIqIGJlIHVzZWQgZGlyZWN0bHksXG52YXIgc3VwcG9ydHMkNiA9IHZvaWQgMDtcbnZhciBzZWxlY3RvciQxID0gdm9pZCAwO1xuZnVuY3Rpb24gc2VsZWN0b3IkMigpIHtcbiAgICBpZiAoIXN1cHBvcnRzJDYpIHtcbiAgICAgICAgc3VwcG9ydHMkNiA9IF9zdXBwb3J0cygpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlbGVjdG9yJDEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yJDE7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjc2VxdWVudGlhbC1mb2N1cy1uYXZpZ2F0aW9uLWFuZC10aGUtdGFiaW5kZXgtYXR0cmlidXRlXG4gICAgc2VsZWN0b3IkMSA9IFwiXCIgKyAvLyBJRTExIHN1cHBvcnRzLmNhbiBmb2N1cyA8dGFibGU+IGFuZCA8dGQ+XG4gICAgKHN1cHBvcnRzJDYuZm9jdXNUYWJsZSA/IFwidGFibGUsIHRkLFwiIDogXCJcIikgKyAvLyBJRTExIHN1cHBvcnRzLmNhbiBmb2N1cyA8ZmllbGRzZXQ+XG4gICAgKHN1cHBvcnRzJDYuZm9jdXNGaWVsZHNldCA/IFwiZmllbGRzZXQsXCIgOiBcIlwiKSArIC8vIE5hbWVzcGFjZSBwcm9ibGVtcyBvZiBbeGxpbms6aHJlZl0gZXhwbGFpbmVkIGluIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMzA0Nzg4OC81MTUxMjRcbiAgICAvLyBzdmcgYVsqfGhyZWZdIGRvZXMgbm90IG1hdGNoIGluIElFOSwgYnV0IHNpbmNlIHdlJ3JlIGZpbHRlcmluZ1xuICAgIC8vIHRocm91Z2ggaXMvZm9jdXNhYmxlIHdlIGNhbiBpbmNsdWRlIGFsbCA8YT4gZnJvbSBTVkdcbiAgICBcInN2ZyBhLFwiICsgLy8gbWF5IGJlaGF2ZSBhcyAnc3ZnLCBzdmcgKiwnIGluIGNocm9tZSBhcyAqZXZlcnkqIHN2ZyBlbGVtZW50IHdpdGggYSBmb2N1cyBldmVudCBsaXN0ZW5lciBpcyBmb2N1c2FibGVcbiAgICAvLyBuYXZpZ2F0aW9uYWwgZWxlbWVudHNcbiAgICBcImFbaHJlZl0sXCIgKyAvLyB2YWxpZGl0eSBkZXRlcm1pbmVkIGJ5IGlzL3ZhbGlkLWFyZWEuanNcbiAgICBcImFyZWFbaHJlZl0sXCIgKyAvLyB2YWxpZGl0eSBkZXRlcm1pbmVkIGJ5IGlzL2Rpc2FibGVkLmpzXG4gICAgXCJpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgYnV0dG9uLFwiICsgLy8gYnJvd3NpbmcgY29udGV4dCBjb250YWluZXJzXG4gICAgXCJpZnJhbWUsIG9iamVjdCwgZW1iZWQsXCIgKyAvLyBpbnRlcmFjdGl2ZSBjb250ZW50XG4gICAgXCJrZXlnZW4sXCIgKyAoc3VwcG9ydHMkNi5mb2N1c0F1ZGlvV2l0aG91dENvbnRyb2xzID8gXCJhdWRpbyxcIiA6IFwiYXVkaW9bY29udHJvbHNdLFwiKSArIChzdXBwb3J0cyQ2LmZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHMgPyBcInZpZGVvLFwiIDogXCJ2aWRlb1tjb250cm9sc10sXCIpICsgKHN1cHBvcnRzJDYuZm9jdXNTdW1tYXJ5ID8gXCJzdW1tYXJ5LFwiIDogXCJcIikgKyAvLyB2YWxpZGl0eSBkZXRlcm1pbmVkIGJ5IGlzL3ZhbGlkLXRhYmluZGV4LmpzXG4gICAgXCJbdGFiaW5kZXhdLFwiICsgLy8gZWRpdGluZyBob3N0c1xuICAgIFwiW2NvbnRlbnRlZGl0YWJsZV1cIjtcbiAgICAvLyB3aGVyZSBTaGFkb3dET00gaXMgc3VwcG9ydGVkLCB3ZSBhbHNvIHdhbnQgdGhlIHNoYWRvd2VkIGZvY3VzYWJsZSBlbGVtZW50cyAodmlhIFwiPj4+XCIgb3IgXCIvZGVlcC9cIilcbiAgICBzZWxlY3RvciQxID0gc2VsZWN0SW5TaGFkb3dzKHNlbGVjdG9yJDEpO1xuICAgIHJldHVybiBzZWxlY3RvciQxO1xufVxuZnVuY3Rpb24gcXVlcnlGb2N1c2FibGVRdWljaygpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsIGluY2x1ZGVDb250ZXh0ID0gX3JlZi5pbmNsdWRlQ29udGV4dCwgaW5jbHVkZU9ubHlUYWJiYWJsZSA9IF9yZWYuaW5jbHVkZU9ubHlUYWJiYWJsZTtcbiAgICB2YXIgX3NlbGVjdG9yID0gc2VsZWN0b3IkMigpO1xuICAgIHZhciBlbGVtZW50cyA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbChfc2VsZWN0b3IpO1xuICAgIC8vIHRoZSBzZWxlY3RvciBwb3RlbnRpYWxseSBtYXRjaGVzIG1vcmUgdGhhbiByZWFsbHkgaXMgZm9jdXNhYmxlXG4gICAgdmFyIF9pc0ZvY3VzYWJsZSA9IGlzRm9jdXNhYmxlLnJ1bGVzLmV4Y2VwdCh7XG4gICAgICAgIG9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZVxuICAgIH0pO1xuICAgIHZhciByZXN1bHQgPSBbXS5maWx0ZXIuY2FsbChlbGVtZW50cywgX2lzRm9jdXNhYmxlKTtcbiAgICAvLyBhZGQgY29udGV4dCBpZiByZXF1ZXN0ZWQgYW5kIGZvY3VzYWJsZVxuICAgIGlmIChpbmNsdWRlQ29udGV4dCAmJiBfaXNGb2N1c2FibGUoY29udGV4dCkpIHtcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQoY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBxdWVyeUZvY3VzYWJsZSgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsIGluY2x1ZGVDb250ZXh0ID0gX3JlZi5pbmNsdWRlQ29udGV4dCwgaW5jbHVkZU9ubHlUYWJiYWJsZSA9IF9yZWYuaW5jbHVkZU9ubHlUYWJiYWJsZSwgX3JlZiRzdHJhdGVneSA9IF9yZWYuc3RyYXRlZ3ksIHN0cmF0ZWd5ID0gX3JlZiRzdHJhdGVneSA9PT0gdW5kZWZpbmVkID8gXCJxdWlja1wiIDogX3JlZiRzdHJhdGVneTtcbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHRUb0VsZW1lbnQoe1xuICAgICAgICBsYWJlbDogXCJxdWVyeS9mb2N1c2FibGVcIixcbiAgICAgICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxuICAgICAgICBkZWZhdWx0VG9Eb2N1bWVudDogdHJ1ZSxcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH0pO1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBjb250ZXh0OiBlbGVtZW50LFxuICAgICAgICBpbmNsdWRlQ29udGV4dDogaW5jbHVkZUNvbnRleHQsXG4gICAgICAgIGluY2x1ZGVPbmx5VGFiYmFibGU6IGluY2x1ZGVPbmx5VGFiYmFibGUsXG4gICAgICAgIHN0cmF0ZWd5OiBzdHJhdGVneVxuICAgIH07XG4gICAgaWYgKHN0cmF0ZWd5ID09PSBcInF1aWNrXCIpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5Rm9jdXNhYmxlUXVpY2sob3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChzdHJhdGVneSA9PT0gXCJzdHJpY3RcIiB8fCBzdHJhdGVneSA9PT0gXCJhbGxcIikge1xuICAgICAgICByZXR1cm4gcXVlcnlGb2N1c2FibGVTdHJpY3Qob3B0aW9ucyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3F1ZXJ5L2ZvY3VzYWJsZSByZXF1aXJlcyBvcHRpb24uc3RyYXRlZ3kgdG8gYmUgb25lIG9mIFtcInF1aWNrXCIsIFwic3RyaWN0XCIsIFwiYWxsXCJdJyk7XG59XG52YXIgc3VwcG9ydHMkNyA9IHZvaWQgMDtcbi8vIEludGVybmV0IEV4cGxvcmVyIDExIGNvbnNpZGVycyBmaWVsZHNldCwgdGFibGUsIHRkIGZvY3VzYWJsZSwgYnV0IG5vdCB0YWJiYWJsZVxuLy8gSW50ZXJuZXQgRXhwbG9yZXIgMTEgY29uc2lkZXJzIGJvZHkgdG8gaGF2ZSBbdGFiaW5kZXg9MF0sIGJ1dCBkb2VzIG5vdCBhbGxvdyB0YWJiaW5nIHRvIGl0XG52YXIgZm9jdXNhYmxlRWxlbWVudHNQYXR0ZXJuID0gL14oZmllbGRzZXR8dGFibGV8dGR8Ym9keSkkLztcbmZ1bmN0aW9uIGlzVGFiYmFibGVSdWxlcygpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsIF9yZWYkZXhjZXB0ID0gX3JlZi5leGNlcHQsIGV4Y2VwdCA9IF9yZWYkZXhjZXB0ID09PSB1bmRlZmluZWQgPyB7XG4gICAgICAgIGZsZXhib3g6IGZhbHNlLFxuICAgICAgICBzY3JvbGxhYmxlOiBmYWxzZSxcbiAgICAgICAgc2hhZG93OiBmYWxzZSxcbiAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgIG9ubHlUYWJiYWJsZTogZmFsc2VcbiAgICB9IDogX3JlZiRleGNlcHQ7XG4gICAgaWYgKCFzdXBwb3J0cyQ3KSB7XG4gICAgICAgIHN1cHBvcnRzJDcgPSBfc3VwcG9ydHMoKTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0VG9FbGVtZW50KHtcbiAgICAgICAgbGFiZWw6IFwiaXMvdGFiYmFibGVcIixcbiAgICAgICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfSk7XG4gICAgaWYgKHBsYXRmb3JtLmlzLkJMSU5LICYmIHBsYXRmb3JtLmlzLkFORFJPSUQgJiYgcGxhdGZvcm0ubWFqb3JWZXJzaW9uID4gNDIpIHtcbiAgICAgICAgLy8gRXh0ZXJuYWwga2V5Ym9hcmQgc3VwcG9ydCB3b3JrZWQgZmluZSBpbiBDSHJvbWUgNDIsIGJ1dCBzdG9wcGVkIHdvcmtpbmcgaW4gQ2hyb21lIDQ1LlxuICAgICAgICAvLyBUaGUgb24tc2NyZWVuIGtleWJvYXJkIGRvZXMgbm90IHByb3ZpZGUgYSB3YXkgdG8gZm9jdXMgdGhlIG5leHQgaW5wdXQgZWxlbWVudCAobGlrZSBpT1MgZG9lcykuXG4gICAgICAgIC8vIFRoYXQgbGVhdmVzIHVzIHdpdGggbm8gb3B0aW9uIHRvIGFkdmFuY2UgZm9jdXMgYnkga2V5Ym9hcmQsIGVyZ28gbm90aGluZyBpcyB0YWJiYWJsZSAoa2V5Ym9hcmQgZm9jdXNhYmxlKS5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZnJhbWVFbGVtZW50ID0gZ2V0RnJhbWVFbGVtZW50KGVsZW1lbnQpO1xuICAgIGlmIChmcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHBsYXRmb3JtLmlzLldFQktJVCAmJiBwbGF0Zm9ybS5pcy5JT1MpIHtcbiAgICAgICAgICAgIC8vIGlPUyBvbmx5IGRvZXMgbm90IGNvbnNpZGVyIGFueXRoaW5nIGZyb20gYW5vdGhlciBicm93c2luZyBjb250ZXh0IGtleWJvYXJkIGZvY3VzYWJsZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmcmFtZVt0YWJpbmRleD1cIi0xXCJdIGFuZCBvYmplY3RbdGFiaW5kZXg9XCItMVwiXSBpbmhlcml0IHRoZVxuICAgICAgICAvLyB0YWJiYWJsZSBkZW1vdGlvbiBvbnRvIGVsZW1lbnRzIG9mIHRoZWlyIGJyb3dzaW5nIGNvbnRleHRzXG4gICAgICAgIGlmICh0YWJpbmRleFZhbHVlKGZyYW1lRWxlbWVudCkgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFleGNlcHQudmlzaWJsZSAmJiAocGxhdGZvcm0uaXMuQkxJTksgfHwgcGxhdGZvcm0uaXMuV0VCS0lUKSAmJiAhaXNWaXNpYmxlKGZyYW1lRWxlbWVudCkpIHtcbiAgICAgICAgICAgIC8vIEJsaW5rIGFuZCBXZWJLaXQgY29uc2lkZXIgZWxlbWVudHMgaW4gaGlkZGVuIGJyb3dzaW5nIGNvbnRleHRzIGZvY3VzYWJsZSwgYnV0IG5vdCB0YWJiYWJsZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlYmtpdCBhbmQgQmxpbmsgZG9uJ3QgY29uc2lkZXIgYW55dGhpbmcgaW4gPG9iamVjdD4gdGFiYmFibGVcbiAgICAgICAgLy8gQmxpbmsgZml4ZWQgdGhhdCBmaXhlZCBpbiBDaHJvbWUgNTQsIE9wZXJhIDQxXG4gICAgICAgIHZhciBmcmFtZU5vZGVOYW1lID0gZnJhbWVFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChmcmFtZU5vZGVOYW1lID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB2YXIgaXNGaXhlZEJsaW5rID0gcGxhdGZvcm0ubmFtZSA9PT0gXCJDaHJvbWVcIiAmJiBwbGF0Zm9ybS5tYWpvclZlcnNpb24gPj0gNTQgfHwgcGxhdGZvcm0ubmFtZSA9PT0gXCJPcGVyYVwiICYmIHBsYXRmb3JtLm1ham9yVmVyc2lvbiA+PSA0MTtcbiAgICAgICAgICAgIGlmIChwbGF0Zm9ybS5pcy5XRUJLSVQgfHwgcGxhdGZvcm0uaXMuQkxJTksgJiYgIWlzRml4ZWRCbGluaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIF90YWJpbmRleCA9IHRhYmluZGV4VmFsdWUoZWxlbWVudCk7XG4gICAgdmFyIHRhYmluZGV4ID0gX3RhYmluZGV4ID09PSBudWxsID8gbnVsbCA6IF90YWJpbmRleCA+PSAwO1xuICAgIGlmIChwbGF0Zm9ybS5pcy5FREdFICYmIHBsYXRmb3JtLm1ham9yVmVyc2lvbiA+PSAxNCAmJiBmcmFtZUVsZW1lbnQgJiYgZWxlbWVudC5vd25lclNWR0VsZW1lbnQgJiYgX3RhYmluZGV4IDwgMCkge1xuICAgICAgICAvLyBFZGdlIDE0KyBjb25zaWRlcnMgPGEgeGxpbms6aHJlZj1cIuKAplwiIHRhYmluZGV4PVwiLTFcIj4ga2V5Ym9hcmQgZm9jdXNhYmxlXG4gICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGlzIGluIGEgbmVzdGVkIGJyb3dzaW5nIGNvbnRleHRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBoYXNUYWJiYWJsZVRhYmluZGV4T3JOb25lID0gdGFiaW5kZXggIT09IGZhbHNlO1xuICAgIHZhciBoYXNUYWJiYWJsZVRhYmluZGV4ID0gX3RhYmluZGV4ICE9PSBudWxsICYmIF90YWJpbmRleCA+PSAwO1xuICAgIC8vIE5PVEU6IEZpcmVmb3ggMzEgY29uc2lkZXJzIFtjb250ZW50ZWRpdGFibGVdIHRvIGhhdmUgW3RhYmluZGV4PS0xXSwgYnV0IGFsbG93cyB0YWJiaW5nIHRvIGl0XG4gICAgLy8gZml4ZWQgaW4gRmlyZWZveCA0MCB0aGUgbGF0ZXN0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTE4NTY1N1xuICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSkge1xuICAgICAgICAvLyB0YWJiaW5nIGNhbiBzdGlsbCBiZSBkaXNhYmxlZCBieSBleHBsaWNpdGx5IHByb3ZpZGluZyBbdGFiaW5kZXg9XCItMVwiXVxuICAgICAgICByZXR1cm4gaGFzVGFiYmFibGVUYWJpbmRleE9yTm9uZTtcbiAgICB9XG4gICAgaWYgKGZvY3VzYWJsZUVsZW1lbnRzUGF0dGVybi50ZXN0KG5vZGVOYW1lKSAmJiB0YWJpbmRleCAhPT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwbGF0Zm9ybS5pcy5XRUJLSVQgJiYgcGxhdGZvcm0uaXMuSU9TKSB7XG4gICAgICAgIC8vIGlPUyBvbmx5IGNvbnNpZGVycyBhIGhhbmQgZnVsbCBvZiBlbGVtZW50cyB0YWJiYWJsZSAoa2V5Ym9hcmQgZm9jdXNhYmxlKVxuICAgICAgICAvLyB0aGlzIGhvbGRzIHRydWUgZXZlbiB3aXRoIGV4dGVybmFsIGtleWJvYXJkc1xuICAgICAgICB2YXIgcG90ZW50aWFsbHlUYWJiYWJsZSA9IG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgZWxlbWVudC50eXBlID09PSBcInRleHRcIiB8fCBlbGVtZW50LnR5cGUgPT09IFwicGFzc3dvcmRcIiB8fCBub2RlTmFtZSA9PT0gXCJzZWxlY3RcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpO1xuICAgICAgICBpZiAoIXBvdGVudGlhbGx5VGFiYmFibGUpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICAgICAgICAgICAgcG90ZW50aWFsbHlUYWJiYWJsZSA9IGlzVXNlck1vZGlmeVdyaXRhYmxlKHN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBvdGVudGlhbGx5VGFiYmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZU5hbWUgPT09IFwidXNlXCIgJiYgX3RhYmluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChwbGF0Zm9ybS5pcy5CTElOSyB8fCBwbGF0Zm9ybS5pcy5XRUJLSVQgJiYgcGxhdGZvcm0ubWFqb3JWZXJzaW9uID09PSA5KSB7XG4gICAgICAgICAgICAvLyBJbiBDaHJvbWUgYW5kIFNhZmFyaSA5IHRoZSA8dXNlPiBlbGVtZW50IGlzIGtleWJvYXJkIGZvY3VzYWJsZSBldmVuIGZvciB0YWJpbmRleD1cIi0xXCJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbGVtZW50TWF0Y2hlcyhlbGVtZW50LCBcInN2ZyBhXCIpICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKFwieGxpbms6aHJlZlwiKSkge1xuICAgICAgICBpZiAoaGFzVGFiYmFibGVUYWJpbmRleE9yTm9uZSkge1xuICAgICAgICAgICAgLy8gaW4gVHJpZGVudCBhbmQgR2Vja28gU1ZHRWxlbWVudCBkb2VzIG5vdCBoYW5kbGUgdGhlIHRhYkluZGV4IHByb3BlcnR5IHByb3Blcmx5XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudC5mb2N1cyAmJiAhc3VwcG9ydHMkNy5mb2N1c1N2Z05lZ2F0aXZlVGFiaW5kZXhBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggNTEgYW5kIDUyIHRyZWF0IGFueSBuYXRpdmVseSB0YWJiYWJsZSBTVkcgZWxlbWVudCB3aXRoXG4gICAgICAgICAgICAvLyB0YWJpbmRleD1cIi0xXCIgYXMgdGFiYmFibGUgYW5kIGV2ZXJ5dGhpbmcgZWxzZSBhcyBpbmVydFxuICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzMDIzNDBcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gXCJzdmdcIiAmJiBzdXBwb3J0cyQ3LmZvY3VzU3ZnSW5JZnJhbWUgJiYgaGFzVGFiYmFibGVUYWJpbmRleE9yTm9uZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtLmlzLlRSSURFTlQgfHwgcGxhdGZvcm0uaXMuRURHRSkge1xuICAgICAgICBpZiAobm9kZU5hbWUgPT09IFwic3ZnXCIpIHtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0cyQ3LmZvY3VzU3ZnKSB7XG4gICAgICAgICAgICAgICAgLy8gb2xkZXIgSW50ZXJuZXQgRXhwbG9yZXJzIGNvbnNpZGVyIDxzdmc+IGtleWJvYXJkIGZvY3VzYWJsZVxuICAgICAgICAgICAgICAgIC8vIHVubGVzcyB0aGV5IGhhdmUgZm9jc2FibGU9XCJmYWxzZVwiLCBidXQgdGhlbiB0aGV5IHdvdWxkbid0XG4gICAgICAgICAgICAgICAgLy8gYmUgZm9jdXNhYmxlIGFuZCB0aHVzIG5vdCBldmVuIHJlYWNoIHRoaXMgZmlsdGVyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbGVtZW50cyB0aGF0IGhhdmUgW2ZvY3VzYWJsZV0gYXJlIGF1dG9tYXRpY2FsbHkga2V5Ym9hcmQgZm9jdXNhYmxlIHJlZ2FyZGxlc3Mgb2YgdGhlIGF0dHJpYnV0ZSdzIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJmb2N1c2FibGVcIikgfHwgaGFzVGFiYmFibGVUYWJpbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudC5vd25lclNWR0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0cyQ3LmZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUgJiYgaGFzVGFiYmFibGVUYWJpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxlbWVudHMgdGhhdCBoYXZlIFtmb2N1c2FibGVdIGFyZSBhdXRvbWF0aWNhbGx5IGtleWJvYXJkIGZvY3VzYWJsZSByZWdhcmRsZXNzIG9mIHRoZSBhdHRyaWJ1dGUncyB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKFwiZm9jdXNhYmxlXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnRhYkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oZXhjZXB0Lm9ubHlUYWJiYWJsZSk7XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gXCJhdWRpb1wiKSB7XG4gICAgICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJjb250cm9sc1wiKSkge1xuICAgICAgICAgICAgLy8gSW4gSW50ZXJuZXQgRXhwbG9yZXIgdGhlIDxhdWRpbz4gZWxlbWVudCBpcyBmb2N1c2FibGUsIGJ1dCBub3QgdGFiYmFibGUsIGFuZCB0YWJJbmRleCBwcm9wZXJ0eSBpcyB3cm9uZ1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHBsYXRmb3JtLmlzLkJMSU5LKSB7XG4gICAgICAgICAgICAvLyBJbiBDaHJvbWUgPGF1ZGlvIGNvbnRyb2xzIHRhYmluZGV4PVwiLTFcIj4gcmVtYWlucyBrZXlib2FyZCBmb2N1c2FibGVcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gXCJ2aWRlb1wiKSB7XG4gICAgICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJjb250cm9sc1wiKSkge1xuICAgICAgICAgICAgaWYgKHBsYXRmb3JtLmlzLlRSSURFTlQgfHwgcGxhdGZvcm0uaXMuRURHRSkge1xuICAgICAgICAgICAgICAgIC8vIEluIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIHRoZSA8dmlkZW8+IGVsZW1lbnQgaXMgZm9jdXNhYmxlLCBidXQgbm90IHRhYmJhYmxlLCBhbmQgdGFiSW5kZXggcHJvcGVydHkgaXMgd3JvbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGxhdGZvcm0uaXMuQkxJTksgfHwgcGxhdGZvcm0uaXMuR0VDS08pIHtcbiAgICAgICAgICAgIC8vIEluIENocm9tZSBhbmQgRmlyZWZveCA8dmlkZW8gY29udHJvbHMgdGFiaW5kZXg9XCItMVwiPiByZW1haW5zIGtleWJvYXJkIGZvY3VzYWJsZVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChwbGF0Zm9ybS5pcy5CTElOSyB8fCBwbGF0Zm9ybS5pcy5XRUJLSVQpIHtcbiAgICAgICAgICAgIC8vIEluIGFsbCBCbGluayBhbmQgV2ViS2l0IGJhc2VkIGJyb3dzZXJzIDxlbWJlZD4gYW5kIDxvYmplY3Q+IGFyZSBuZXZlciBrZXlib2FyZCBmb2N1c2FibGUsIGV2ZW4gd2l0aCB0YWJpbmRleD1cIjBcIiBzZXRcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZU5hbWUgPT09IFwiaWZyYW1lXCIpIHtcbiAgICAgICAgLy8gSW4gSW50ZXJuZXQgRXhwbG9yZXIgYWxsIGlmcmFtZXMgYXJlIG9ubHkgZm9jdXNhYmxlXG4gICAgICAgIC8vIEluIFdlYktpdCwgQmxpbmsgYW5kIEdlY2tvIGlmcmFtZXMgbWF5IGJlIHRhYmJhYmxlIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICAgICAgICAvLyBTaW5jZSB3ZSBjYW4ndCByZWxpYWJseSBpbnZlc3RpZ2F0ZSBpZnJhbWUgZG9jdW1lbnRzIGJlY2F1c2Ugb2YgdGhlXG4gICAgICAgIC8vIFNhbWVPcmlnaW5Qb2xpY3ksIHdlJ3JlIGRlY2xhcmluZyBldmVyeXRoaW5nIG9ubHkgZm9jdXNhYmxlLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZXhjZXB0LnNjcm9sbGFibGUgJiYgcGxhdGZvcm0uaXMuR0VDS08pIHtcbiAgICAgICAgLy8gRmlyZWZveCBjb25zaWRlcnMgc2Nyb2xsYWJsZSBjb250YWluZXJzIGtleWJvYXJkIGZvY3VzYWJsZSxcbiAgICAgICAgLy8gZXZlbiB0aG91Z2ggdGhlaXIgdGFiSW5kZXggcHJvcGVydHkgaXMgLTFcbiAgICAgICAgdmFyIF9zdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ3NzT3ZlcmZsb3dTY3JvbGwoX3N0eWxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhc1RhYmJhYmxlVGFiaW5kZXhPck5vbmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtLmlzLlRSSURFTlQgfHwgcGxhdGZvcm0uaXMuRURHRSkge1xuICAgICAgICAvLyBJRSBhbmQgRWRnZSBkZWdyYWRlIDxhcmVhPiB0byBzY3JpcHQgZm9jdXNhYmxlLCBpZiB0aGUgaW1hZ2VcbiAgICAgICAgLy8gdXNpbmcgdGhlIDxtYXA+IGhhcyBiZWVuIGdpdmVuIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICBpZiAobm9kZU5hbWUgPT09IFwiYXJlYVwiKSB7XG4gICAgICAgICAgICB2YXIgaW1nID0gZ2V0SW1hZ2VPZkFyZWEoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaW1nICYmIHRhYmluZGV4VmFsdWUoaW1nKSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9zdHlsZTIgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgICAgICAgaWYgKGlzVXNlck1vZGlmeVdyaXRhYmxlKF9zdHlsZTIpKSB7XG4gICAgICAgICAgICAvLyBwcmV2ZW50IGJlaW5nIHN3YWxsb3dlZCBieSB0aGUgb3ZlcnplYWxvdXMgaXNTY3JvbGxhYmxlQ29udGFpbmVyKCkgYmVsb3dcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnRhYkluZGV4ID49IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFleGNlcHQuZmxleGJveCAmJiBoYXNDc3NEaXNwbGF5RmxleChfc3R5bGUyKSkge1xuICAgICAgICAgICAgaWYgKF90YWJpbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYXNUYWJiYWJsZVRhYmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzRm9jdXNSZWxldmFudFdpdGhvdXRGbGV4Ym94KGVsZW1lbnQpICYmIGlzVGFiYmFibGVXaXRob3V0RmxleGJveChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJRSBjb25zaWRlcnMgc2Nyb2xsYWJsZSBjb250YWluZXJzIHNjcmlwdCBmb2N1c2FibGUgb25seSxcbiAgICAgICAgLy8gZXZlbiB0aG91Z2ggdGhlaXIgdGFiSW5kZXggcHJvcGVydHkgaXMgMFxuICAgICAgICBpZiAoaXNTY3JvbGxhYmxlQ29udGFpbmVyKGVsZW1lbnQsIG5vZGVOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnROb2RlTmFtZSA9IHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIHBhcmVudFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocGFyZW50LCBudWxsKTtcbiAgICAgICAgICAgIC8vIElFIGNvbnNpZGVycyBzY3JvbGxhYmxlIGJvZGllcyBzY3JpcHQgZm9jdXNhYmxlIG9ubHksXG4gICAgICAgICAgICBpZiAoaXNTY3JvbGxhYmxlQ29udGFpbmVyKHBhcmVudCwgbm9kZU5hbWUsIHBhcmVudE5vZGVOYW1lLCBwYXJlbnRTdHlsZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGlsZHJlbiBvZiBmb2N1c2FibGUgZWxlbWVudHMgd2l0aCBkaXNwbGF5OmZsZXggYXJlIGZvY3VzYWJsZSBpbiBJRTEwLTExLFxuICAgICAgICAgICAgLy8gZXZlbiB0aG91Z2ggdGhlaXIgdGFiSW5kZXggcHJvcGVydHkgc3VnZ2VzdHMgb3RoZXJ3aXNlXG4gICAgICAgICAgICBpZiAoaGFzQ3NzRGlzcGxheUZsZXgocGFyZW50U3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gdmFsdWUgb2YgdGFiaW5kZXggdGFrZXMgcHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgIHJldHVybiBoYXNUYWJiYWJsZVRhYmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvUEYvYXJpYS1wcmFjdGljZXMvI2ZvY3VzX3RhYmluZGV4XG4gICAgcmV0dXJuIGVsZW1lbnQudGFiSW5kZXggPj0gMDtcbn1cbi8vIGJpbmQgZXhjZXB0aW9ucyB0byBhbiBpdGVyYXRvciBjYWxsYmFja1xuaXNUYWJiYWJsZVJ1bGVzLmV4Y2VwdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBleGNlcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBpc1RhYmJhYmxlID0gZnVuY3Rpb24gaXNUYWJiYWJsZShjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBpc1RhYmJhYmxlUnVsZXMoe1xuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgIGV4Y2VwdDogZXhjZXB0XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgaXNUYWJiYWJsZS5ydWxlcyA9IGlzVGFiYmFibGVSdWxlcztcbiAgICByZXR1cm4gaXNUYWJiYWJsZTtcbn07XG52YXIgaXNGb2N1c1JlbGV2YW50V2l0aG91dEZsZXhib3ggPSBpc0ZvY3VzUmVsZXZhbnQucnVsZXMuZXhjZXB0KHtcbiAgICBmbGV4Ym94OiB0cnVlXG59KTtcbnZhciBpc1RhYmJhYmxlV2l0aG91dEZsZXhib3ggPSBpc1RhYmJhYmxlUnVsZXMuZXhjZXB0KHtcbiAgICBmbGV4Ym94OiB0cnVlXG59KTtcbi8vIHByb3ZpZGUgaXNUYWJiYWJsZShjb250ZXh0KSBhcyBkZWZhdWx0IGl0ZXJhdG9yIGNhbGxiYWNrXG52YXIgaXNUYWJiYWJsZSA9IGlzVGFiYmFibGVSdWxlcy5leGNlcHQoe30pO1xuZnVuY3Rpb24gcXVlcnlUYWJiYWJsZSgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsIGluY2x1ZGVDb250ZXh0ID0gX3JlZi5pbmNsdWRlQ29udGV4dCwgaW5jbHVkZU9ubHlUYWJiYWJsZSA9IF9yZWYuaW5jbHVkZU9ubHlUYWJiYWJsZSwgc3RyYXRlZ3kgPSBfcmVmLnN0cmF0ZWd5O1xuICAgIHZhciBfaXNUYWJiYWJsZSA9IGlzVGFiYmFibGUucnVsZXMuZXhjZXB0KHtcbiAgICAgICAgb25seVRhYmJhYmxlOiBpbmNsdWRlT25seVRhYmJhYmxlXG4gICAgfSk7XG4gICAgcmV0dXJuIHF1ZXJ5Rm9jdXNhYmxlKHtcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgaW5jbHVkZUNvbnRleHQ6IGluY2x1ZGVDb250ZXh0LFxuICAgICAgICBpbmNsdWRlT25seVRhYmJhYmxlOiBpbmNsdWRlT25seVRhYmJhYmxlLFxuICAgICAgICBzdHJhdGVneTogc3RyYXRlZ3lcbiAgICB9KS5maWx0ZXIoX2lzVGFiYmFibGUpO1xufVxuLy8gc29ydHMgYSBsaXN0IG9mIGVsZW1lbnRzIGFjY29yZGluZyB0byB0aGVpciBvcmRlciBpbiB0aGUgRE9NXG5mdW5jdGlvbiBjb21wYXJlRG9tUG9zaXRpb24oYSwgYikge1xuICAgIHJldHVybiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBzb3J0RG9tT3JkZXIoZWxlbWVudHMpIHtcbiAgICByZXR1cm4gZWxlbWVudHMuc29ydChjb21wYXJlRG9tUG9zaXRpb24pO1xufVxuZnVuY3Rpb24gZ2V0Rmlyc3RTdWNjZXNzb3JPZmZzZXQobGlzdCwgdGFyZ2V0KSB7XG4gICAgLy8gZmluZCB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGNvbWVzIEFGVEVSIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgIHJldHVybiBmaW5kSW5kZXgobGlzdCwgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uT2Zmc2V0cyhsaXN0LCBlbGVtZW50cywgcmVzb2x2ZUVsZW1lbnQpIHtcbiAgICAvLyBpbnN0ZWFkIG9mIG11dGF0aW5nIHRoZSBlbGVtZW50cyBsaXN0IGRpcmVjdGx5LCByZW1lbWJlciBwb3NpdGlvbiBhbmQgbWFwXG4gICAgLy8gdG8gaW5qZWN0IGxhdGVyLCB3aGVuIHdlIGNhbiBkbyB0aGlzIG1vcmUgZWZmaWNpZW50bHlcbiAgICB2YXIgaW5zZXJ0aW9ucyA9IFtdO1xuICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICB2YXIgcmVwbGFjZSA9IHRydWU7XG4gICAgICAgIHZhciBvZmZzZXQgPSBsaXN0LmluZGV4T2YoZWxlbWVudCk7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBlbGVtZW50IGlzIG5vdCBpbiB0YXJnZXQgbGlzdFxuICAgICAgICAgICAgb2Zmc2V0ID0gZ2V0Rmlyc3RTdWNjZXNzb3JPZmZzZXQobGlzdCwgZWxlbWVudCk7XG4gICAgICAgICAgICByZXBsYWNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2Nlc3NvciBpbiB0aGUgdGFic2VxdWVuY2UsXG4gICAgICAgICAgICAvLyBtZWFuaW5nIHRoZSBpbWFnZSBtdXN0IGJlIHRoZSBsYXN0IGVsZW1lbnRcbiAgICAgICAgICAgIG9mZnNldCA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFsbG93IHRoZSBjb25zdW1lciB0byByZXBsYWNlIHRoZSBpbmplY3RlZCBlbGVtZW50XG4gICAgICAgIHZhciBpbmplY3Rpb25zID0gbm9kZUFycmF5KHJlc29sdmVFbGVtZW50ID8gcmVzb2x2ZUVsZW1lbnQoZWxlbWVudCkgOiBlbGVtZW50KTtcbiAgICAgICAgaWYgKCFpbmplY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gd2UgY2FuJ3QgaW5qZWN0IHplcm8gZWxlbWVudHNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRpb25zLnB1c2goe1xuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgICAgICAgICAgZWxlbWVudHM6IGluamVjdGlvbnNcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGluc2VydGlvbnM7XG59XG5mdW5jdGlvbiBpbnNlcnRFbGVtZW50c0F0T2Zmc2V0cyhsaXN0LCBpbnNlcnRpb25zKSB7XG4gICAgLy8gcmVtZW1iZXIgdGhlIG51bWJlciBvZiBlbGVtZW50cyB3ZSBoYXZlIGFscmVhZHkgaW5qZWN0ZWRcbiAgICAvLyBzbyB3ZSBhY2NvdW50IGZvciB0aGUgY2F1c2VkIGluZGV4IG9mZnNldFxuICAgIHZhciBpbnNlcnRlZCA9IDA7XG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgd2UgaW5zZXJ0IHRoZSBlbGVtZW50cyBpbiBzZXF1ZW5jZSxcbiAgICAvLyBvdGhlcndpc2UgdGhlIG9mZnNldCBjb21wZW5zYXRpb24gd29uJ3Qgd29ya1xuICAgIGluc2VydGlvbnMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLm9mZnNldCAtIGIub2Zmc2V0O1xuICAgIH0pO1xuICAgIGluc2VydGlvbnMuZm9yRWFjaChmdW5jdGlvbihpbnNlcnRpb24pIHtcbiAgICAgICAgLy8gYXJyYXkuc3BsaWNlIGhhcyBhbiBhbm5veWluZyBmdW5jdGlvbiBzaWduYXR1cmUgOihcbiAgICAgICAgdmFyIHJlbW92ZSA9IGluc2VydGlvbi5yZXBsYWNlID8gMSA6IDA7XG4gICAgICAgIHZhciBhcmdzID0gW1xuICAgICAgICAgICAgaW5zZXJ0aW9uLm9mZnNldCArIGluc2VydGVkLFxuICAgICAgICAgICAgcmVtb3ZlXG4gICAgICAgIF0uY29uY2F0KGluc2VydGlvbi5lbGVtZW50cyk7XG4gICAgICAgIGxpc3Quc3BsaWNlLmFwcGx5KGxpc3QsIGFyZ3MpO1xuICAgICAgICBpbnNlcnRlZCArPSBpbnNlcnRpb24uZWxlbWVudHMubGVuZ3RoIC0gcmVtb3ZlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbWVyZ2VJbkRvbU9yZGVyKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSwgbGlzdCA9IF9yZWYubGlzdCwgZWxlbWVudHMgPSBfcmVmLmVsZW1lbnRzLCByZXNvbHZlRWxlbWVudCA9IF9yZWYucmVzb2x2ZUVsZW1lbnQ7XG4gICAgLy8gb3BlcmF0ZSBvbiBhIGNvcHkgc28gd2UgZG9uJ3QgbXV0YXRlIHRoZSBvcmlnaW5hbCBhcnJheVxuICAgIHZhciBfbGlzdCA9IGxpc3Quc2xpY2UoMCk7XG4gICAgLy8gbWFrZSBzdXJlIHRoZSBlbGVtZW50cyB3ZSdyZSBpbmplY3RpbmcgYXJlIHByb3ZpZGVkIGluIERPTSBvcmRlclxuICAgIHZhciBfZWxlbWVudHMgPSBub2RlQXJyYXkoZWxlbWVudHMpLnNsaWNlKDApO1xuICAgIHNvcnREb21PcmRlcihfZWxlbWVudHMpO1xuICAgIC8vIGZpbmQgdGhlIG9mZnNldHMgd2l0aGluIHRoZSB0YXJnZXQgYXJyYXkgKGxpc3QpIGF0IHdoaWNoIHRvIGluamVjdFxuICAgIC8vIGVhY2ggaW5kaXZpZHVhbCBlbGVtZW50IChmcm9tIGVsZW1lbnRzKVxuICAgIHZhciBpbnNlcnRpb25zID0gZmluZEluc2VydGlvbk9mZnNldHMoX2xpc3QsIF9lbGVtZW50cywgcmVzb2x2ZUVsZW1lbnQpO1xuICAgIC8vIGFjdHVhbGx5IGluamVjdCB0aGUgZWxlbWVudHMgaW50byB0aGUgdGFyZ2V0IGFycmF5IGF0IHRoZSBpZGVudGlmaWVkIHBvc2l0aW9uc1xuICAgIGluc2VydEVsZW1lbnRzQXRPZmZzZXRzKF9saXN0LCBpbnNlcnRpb25zKTtcbiAgICByZXR1cm4gX2xpc3Q7XG59XG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gICAgfTtcbn0oKTtcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbnZhciBNYXBzID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTWFwcyhjb250ZXh0KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXBzKTtcbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBnZXREb2N1bWVudChjb250ZXh0KTtcbiAgICAgICAgdGhpcy5tYXBzID0ge307XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhNYXBzLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRBcmVhc0ZvclwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFyZWFzRm9yKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWFwc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbWFwIGlzIG5vdCBkZWZpbmVkIHdpdGhpbiB0aGUgY29udGV4dCwgc28gd2VcbiAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBnbyBmaW5kIGl0IGVsc2V3aGVyZSBpbiB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRNYXBCeU5hbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcHNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJhZGRNYXBCeU5hbWVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRNYXBCeU5hbWUobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSBnZXRNYXBCeU5hbWUobmFtZSwgdGhpcy5fZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmICghbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIG1hcCwgdGhlIGltZ1t1c2VtYXBdIHdhc24ndCBkb2luZyBhbnl0aGluZyBhbnl3YXlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1hcHNbbWFwLm5hbWVdID0gcXVlcnlUYWJiYWJsZSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IG1hcFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZXh0cmFjdEFyZWFzRnJvbUxpc3RcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0QXJlYXNGcm9tTGlzdChlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgPGFyZWE+IGVsZW1lbnRzIGZyb20gdGhlIGVsZW1lbnRzIGxpc3QsXG4gICAgICAgICAgICAgICAgLy8gYnV0IHB1dCB0aGVtIHRoZSBtYXAgZm9yIGxhdGVyIHJldHJpZXZhbFxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZSAhPT0gXCJhcmVhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXBzW21hcC5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBzW21hcC5uYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwc1ttYXAubmFtZV0ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIE1hcHM7XG59KCk7XG5mdW5jdGlvbiBzb3J0QXJlYShlbGVtZW50cywgY29udGV4dCkge1xuICAgIC8vIGltYWdlcyAtIHVubGVzcyB0aGV5IGFyZSBmb2N1c2FibGUgdGhlbXNlbHZlcywgbGlrZWx5IG5vdFxuICAgIC8vIHBhcnQgb2YgdGhlIGVsZW1lbnRzIGxpc3QsIHNvIHdlJ2xsIGhhdmUgdG8gZmluZCB0aGVtIGFuZFxuICAgIC8vIHNvcnQgdGhlbSBpbnRvIHRoZSBlbGVtZW50cyBsaXN0IG1hbnVhbGx5XG4gICAgdmFyIHVzZW1hcHMgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbWdbdXNlbWFwXVwiKTtcbiAgICB2YXIgbWFwcyA9IG5ldyBNYXBzKGNvbnRleHQpO1xuICAgIC8vIHJlbW92ZSBhbGwgPGFyZWE+IGVsZW1lbnRzIGZyb20gdGhlIGVsZW1lbnRzIGxpc3QsXG4gICAgLy8gYnV0IHB1dCB0aGVtIHRoZSBtYXAgZm9yIGxhdGVyIHJldHJpZXZhbFxuICAgIHZhciBfZWxlbWVudHMgPSBtYXBzLmV4dHJhY3RBcmVhc0Zyb21MaXN0KGVsZW1lbnRzKTtcbiAgICBpZiAoIXVzZW1hcHMubGVuZ3RoKSB7XG4gICAgICAgIC8vIHRoZSBjb250ZXh0IGRvZXMgbm90IGNvbnRhaW4gYW55IDxhcmVhPnMgc28gbm8gbmVlZFxuICAgICAgICAvLyB0byByZXBsYWNlIGFueXRoaW5nLCBqdXN0IHJlbW92ZSBhbnkgbWFwc1xuICAgICAgICByZXR1cm4gX2VsZW1lbnRzO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VJbkRvbU9yZGVyKHtcbiAgICAgICAgbGlzdDogX2VsZW1lbnRzLFxuICAgICAgICBlbGVtZW50czogdXNlbWFwcyxcbiAgICAgICAgcmVzb2x2ZUVsZW1lbnQ6IGZ1bmN0aW9uIHJlc29sdmVFbGVtZW50KGltYWdlKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGltYWdlLmdldEF0dHJpYnV0ZShcInVzZW1hcFwiKS5zbGljZSgxKTtcbiAgICAgICAgICAgIHJldHVybiBtYXBzLmdldEFyZWFzRm9yKG5hbWUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG52YXIgX2NyZWF0ZUNsYXNzJDEgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICAgICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICB9O1xufSgpO1xuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrJDEoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG52YXIgU2hhZG93cyA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFNoYWRvd3MoY29udGV4dCwgc29ydEVsZW1lbnRzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayQxKHRoaXMsIFNoYWRvd3MpO1xuICAgICAgICAvLyBkb2N1bWVudCBjb250ZXh0IHdlJ3JlIHdvcmtpbmcgd2l0aFxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAvLyBjYWxsYmFjayB0aGF0IHNvcnRzIGFuIGFycmF5IG9mIGVsZW1lbnRzXG4gICAgICAgIHRoaXMuc29ydEVsZW1lbnRzID0gc29ydEVsZW1lbnRzO1xuICAgICAgICAvLyByZWZlcmVuY2UgdG8gY3JlYXRlIHVuaXF1ZSBJRHMgZm9yIGVhY2ggU2hhZG93SG9zdFxuICAgICAgICB0aGlzLmhvc3RDb3VudGVyID0gMTtcbiAgICAgICAgLy8gcmVmZXJlbmNlIG1hcCBmb3IgY2hpbGQtU2hhZG93SG9zdHMgb2YgYSBTaGFkb3dIb3N0XG4gICAgICAgIHRoaXMuaW5Ib3N0ID0ge307XG4gICAgICAgIC8vIHJlZmVyZW5jZSBtYXAgZm9yIGNoaWxkLVNoYWRvd0hvc3Qgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgIHRoaXMuaW5Eb2N1bWVudCA9IFtdO1xuICAgICAgICAvLyByZWZlcmVuY2UgbWFwIGZvciBTaGFkb3dIb3N0c1xuICAgICAgICB0aGlzLmhvc3RzID0ge307XG4gICAgICAgIC8vIHJlZmVyZW5jZSBtYXAgZm9yIHRhYmJhYmxlIGVsZW1lbnRzIG9mIGEgU2hhZG93SG9zdFxuICAgICAgICB0aGlzLmVsZW1lbnRzID0ge307XG4gICAgfVxuICAgIC8vIHJlbWVtYmVyIHdoaWNoIGhvc3RzIHdlIGhhdmUgdG8gc29ydCB3aXRoaW4gbGF0ZXJcbiAgICBfY3JlYXRlQ2xhc3MkMShTaGFkb3dzLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJfcmVnaXN0ZXJIb3N0XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZ2lzdGVySG9zdChob3N0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3QuX3NvcnRpbmdJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG1ha2UgdGhlIFNoYWRvd0hvc3QgaWRlbnRpZmlhYmxlIChzZWUgY2xlYW51cCgpIGZvciB1bmRvKVxuICAgICAgICAgICAgICAgIGhvc3QuX3NvcnRpbmdJZCA9IFwic2hhZG93LVwiICsgdGhpcy5ob3N0Q291bnRlcisrO1xuICAgICAgICAgICAgICAgIHRoaXMuaG9zdHNbaG9zdC5fc29ydGluZ0lkXSA9IGhvc3Q7XG4gICAgICAgICAgICAgICAgLy8gaG9zdHMgbWF5IGNvbnRhaW4gb3RoZXIgaG9zdHNcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SG9zdCA9IGdldFNoYWRvd0hvc3Qoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBob3N0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJIb3N0KHBhcmVudEhvc3QpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWdpc3Rlckhvc3RQYXJlbnQoaG9zdCwgcGFyZW50SG9zdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbkRvY3VtZW50LnB1c2goaG9zdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiX3JlZ2lzdGVySG9zdFBhcmVudFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWdpc3Rlckhvc3RQYXJlbnQoaG9zdCwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluSG9zdFtwYXJlbnQuX3NvcnRpbmdJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbkhvc3RbcGFyZW50Ll9zb3J0aW5nSWRdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaW5Ib3N0W3BhcmVudC5fc29ydGluZ0lkXS5wdXNoKGhvc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiX3JlZ2lzdGVyRWxlbWVudFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWdpc3RlckVsZW1lbnQoZWxlbWVudCwgaG9zdCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5lbGVtZW50c1tob3N0Ll9zb3J0aW5nSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbaG9zdC5fc29ydGluZ0lkXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2hvc3QuX3NvcnRpbmdJZF0ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImV4dHJhY3RFbGVtZW50c1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3RFbGVtZW50cyhlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdCA9IGdldFNoYWRvd0hvc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFob3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWdpc3Rlckhvc3QoaG9zdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyRWxlbWVudChlbGVtZW50LCBob3N0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwic29ydFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2VsZW1lbnRzID0gdGhpcy5faW5qZWN0SG9zdHMoZWxlbWVudHMpO1xuICAgICAgICAgICAgICAgIF9lbGVtZW50cyA9IHRoaXMuX3JlcGxhY2VIb3N0cyhfZWxlbWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2VsZW1lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiX2luamVjdEhvc3RzXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2luamVjdEhvc3RzKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5ob3N0cykuZm9yRWFjaChmdW5jdGlvbihfc29ydGluZ0lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfbGlzdCA9IHRoaXMuZWxlbWVudHNbX3NvcnRpbmdJZF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZWxlbWVudHMgPSB0aGlzLmluSG9zdFtfc29ydGluZ0lkXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jb250ZXh0ID0gdGhpcy5ob3N0c1tfc29ydGluZ0lkXS5zaGFkb3dSb290O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzW19zb3J0aW5nSWRdID0gdGhpcy5fbWVyZ2UoX2xpc3QsIF9lbGVtZW50cywgX2NvbnRleHQpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXJnZShlbGVtZW50cywgdGhpcy5pbkRvY3VtZW50LCB0aGlzLmNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiX21lcmdlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21lcmdlKGxpc3QsIGVsZW1lbnRzLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lcmdlZCA9IG1lcmdlSW5Eb21PcmRlcih7XG4gICAgICAgICAgICAgICAgICAgIGxpc3Q6IGxpc3QsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNvcnRFbGVtZW50cyhtZXJnZWQsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiX3JlcGxhY2VIb3N0c1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXBsYWNlSG9zdHMoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VJbkRvbU9yZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdDogZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiB0aGlzLmluRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVFbGVtZW50OiB0aGlzLl9yZXNvbHZlSG9zdEVsZW1lbnQuYmluZCh0aGlzKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiX3Jlc29sdmVIb3N0RWxlbWVudFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNvbHZlSG9zdEVsZW1lbnQoaG9zdCkge1xuICAgICAgICAgICAgICAgIHZhciBtZXJnZWQgPSBtZXJnZUluRG9tT3JkZXIoe1xuICAgICAgICAgICAgICAgICAgICBsaXN0OiB0aGlzLmVsZW1lbnRzW2hvc3QuX3NvcnRpbmdJZF0sXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiB0aGlzLmluSG9zdFtob3N0Ll9zb3J0aW5nSWRdLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlRWxlbWVudDogdGhpcy5fcmVzb2x2ZUhvc3RFbGVtZW50LmJpbmQodGhpcylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgX3RhYmluZGV4ID0gdGFiaW5kZXhWYWx1ZShob3N0KTtcbiAgICAgICAgICAgICAgICBpZiAoX3RhYmluZGV4ICE9PSBudWxsICYmIF90YWJpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0XG4gICAgICAgICAgICAgICAgICAgIF0uY29uY2F0KG1lcmdlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJfY2xlYW51cFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbnVwKCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aG9zZSBpZGVudGlmZXJzIHdlIHB1dCBvbiB0aGUgU2hhZG93SG9zdCB0byBhdm9pZCB1c2luZyBNYXAoKVxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuaG9zdHMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhvc3RzW2tleV0uX3NvcnRpbmdJZDtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBTaGFkb3dzO1xufSgpO1xuZnVuY3Rpb24gc29ydFNoYWRvd2VkKGVsZW1lbnRzLCBjb250ZXh0LCBzb3J0RWxlbWVudHMpIHtcbiAgICB2YXIgc2hhZG93cyA9IG5ldyBTaGFkb3dzKGNvbnRleHQsIHNvcnRFbGVtZW50cyk7XG4gICAgdmFyIF9lbGVtZW50cyA9IHNoYWRvd3MuZXh0cmFjdEVsZW1lbnRzKGVsZW1lbnRzKTtcbiAgICBpZiAoX2VsZW1lbnRzLmxlbmd0aCA9PT0gZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIC8vIG5vIHNoYWRvd2VkIGNvbnRlbnQgZm91bmQsIG5vIG5lZWQgdG8gY29udGludWVcbiAgICAgICAgcmV0dXJuIHNvcnRFbGVtZW50cyhlbGVtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBzaGFkb3dzLnNvcnQoX2VsZW1lbnRzKTtcbn1cbmZ1bmN0aW9uIHNvcnRUYWJpbmRleChlbGVtZW50cykge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC50YWJJbmRleFxuICAgIC8vIGVsZW1lbnRzIHdpdGggdGFiSW5kZXggXCIwXCIgKGluY2x1ZGluZyB0YWJiYWJsZUVsZW1lbnRzIHdpdGhvdXQgdGFiSW5kZXgpIHNob3VsZCBiZSBuYXZpZ2F0ZWQgaW4gdGhlIG9yZGVyIHRoZXkgYXBwZWFyLlxuICAgIC8vIGVsZW1lbnRzIHdpdGggYSBwb3NpdGl2ZSB0YWJJbmRleDpcbiAgICAvLyAgIEVsZW1lbnRzIHRoYXQgaGF2ZSBpZGVudGljYWwgdGFiSW5kZXhlcyBzaG91bGQgYmUgbmF2aWdhdGVkIGluIHRoZSBvcmRlciB0aGV5IGFwcGVhci5cbiAgICAvLyAgIE5hdmlnYXRpb24gcHJvY2VlZHMgZnJvbSB0aGUgbG93ZXN0IHRhYkluZGV4IHRvIHRoZSBoaWdoZXN0IHRhYkluZGV4LlxuICAgIC8vIE5PVEU6IHNvcnQgaW1wbGVtZW50YXRpb24gbWF5IGJlIHVuc3RhYmxlIGFuZCB0aHVzIG1lc3MgdXAgRE9NIG9yZGVyLFxuICAgIC8vIHRoYXQncyB3aHkgd2UgYnVpbGQgYSBtYXAgdGhhdCdzIGJlaW5nIHNvcnRlZCBpbnN0ZWFkLiBJZiB3ZSB3ZXJlIGFibGUgdG8gcmVseVxuICAgIC8vIG9uIGEgc3RhYmxlIHNvcnRpbmcgYWxnb3JpdGhtLCBzb3J0VGFiaW5kZXgoKSBjb3VsZCBiZSBhcyBzaW1wbGUgYXNcbiAgICAvLyBlbGVtZW50cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEudGFiSW5kZXggLSBiLnRhYkluZGV4OyB9KTtcbiAgICAvLyBhdCB0aGlzIHRpbWUgQ2hyb21lIGRvZXMgbm90IHVzZSBhIHN0YWJsZSBzb3J0aW5nIGFsZ29yaXRobVxuICAgIC8vIHNlZSBodHRwOi8vYmxvZy5yb2RuZXlyZWhtLmRlL2FyY2hpdmVzLzE0LVNvcnRpbmctV2VyZS1Eb2luZy1JdC1Xcm9uZy5odG1sI3N0YWJpbGl0eVxuICAgIC8vIE5PVEU6IGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIHNlZW1lZCBsaWtlIG1vcmUgb3ZlcmhlYWQgdGhhbiBqdXN0IHNvcnRpbmcgdGhpcyB3aXRoIGJ1Y2tldHNcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuICAgIHZhciBtYXAgPSB7fTtcbiAgICB2YXIgaW5kZXhlcyA9IFtdO1xuICAgIHZhciBub3JtYWwgPSBlbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAvLyBpbiBUcmlkZW50IGFuZCBHZWNrbyBTVkdFbGVtZW50IGRvZXMgbm90IGtub3cgYWJvdXQgdGhlIHRhYkluZGV4IHByb3BlcnR5XG4gICAgICAgIHZhciB0YWJJbmRleCA9IGVsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgIGlmICh0YWJJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0YWJJbmRleCA9IHRhYmluZGV4VmFsdWUoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXh0cmFjdCBlbGVtZW50cyB0aGF0IGRvbid0IG5lZWQgc29ydGluZ1xuICAgICAgICBpZiAodGFiSW5kZXggPD0gMCB8fCB0YWJJbmRleCA9PT0gbnVsbCB8fCB0YWJJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1hcFt0YWJJbmRleF0pIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBzb3J0YWJsZSBidWNrZXQgZm9yIGRvbS1vcmRlci1wcmVzZXJ2YXRpb24gb2YgZWxlbWVudHMgd2l0aCB0aGUgc2FtZSB0YWJJbmRleFxuICAgICAgICAgICAgbWFwW3RhYkluZGV4XSA9IFtdO1xuICAgICAgICAgICAgLy8gbWFpbnRhaW4gYSBsaXN0IG9mIHVuaXF1ZSB0YWJJbmRleGVzXG4gICAgICAgICAgICBpbmRleGVzLnB1c2godGFiSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNvcnQgZWxlbWVudCBpbnRvIHRoZSBwcm9wZXIgYnVja2V0XG4gICAgICAgIG1hcFt0YWJJbmRleF0ucHVzaChlbGVtZW50KTtcbiAgICAgICAgLy8gZWxlbWVudCBtb3ZlZCB0byBzb3J0aW5nIG1hcCwgc28gbm90IFwibm9ybWFsXCIgYW55bW9yZVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgLy8gc29ydCB0aGUgdGFiaW5kZXggYXNjZW5kaW5nLFxuICAgIC8vIHRoZW4gcmVzb2x2ZSB0aGVtIHRvIHRoZWlyIGFwcHJvcHJpYXRlIGJ1Y2tldHMsXG4gICAgLy8gdGhlbiBmbGF0dGVuIHRoZSBhcnJheSBvZiBhcnJheXMgdG8gYW4gYXJyYXlcbiAgICB2YXIgX2VsZW1lbnRzID0gaW5kZXhlcy5zb3J0KCkubWFwKGZ1bmN0aW9uKHRhYkluZGV4KSB7XG4gICAgICAgIHJldHVybiBtYXBbdGFiSW5kZXhdO1xuICAgIH0pLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50LmNvbmNhdChwcmV2aW91cyk7XG4gICAgfSwgbm9ybWFsKTtcbiAgICByZXR1cm4gX2VsZW1lbnRzO1xufVxudmFyIHN1cHBvcnRzJDggPSB2b2lkIDA7XG5mdW5jdGlvbiBtb3ZlQ29udGV4dFRvQmVnaW5uaW5nKGVsZW1lbnRzLCBjb250ZXh0KSB7XG4gICAgdmFyIHBvcyA9IGVsZW1lbnRzLmluZGV4T2YoY29udGV4dCk7XG4gICAgaWYgKHBvcyA+IDApIHtcbiAgICAgICAgdmFyIHRtcCA9IGVsZW1lbnRzLnNwbGljZShwb3MsIDEpO1xuICAgICAgICByZXR1cm4gdG1wLmNvbmNhdChlbGVtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50cztcbn1cbmZ1bmN0aW9uIHNvcnRFbGVtZW50cyhlbGVtZW50cywgX2NvbnRleHQpIHtcbiAgICBpZiAoc3VwcG9ydHMkOC50YWJzZXF1ZW5jZUFyZWFBdEltZ1Bvc2l0aW9uKSB7XG4gICAgICAgIC8vIFNvbWUgYnJvd3NlcnMgc29ydCA8YXJlYT4gaW4gRE9NIG9yZGVyLCBzb21lIHBsYWNlIHRoZSA8YXJlYT5zXG4gICAgICAgIC8vIHdoZXJlIHRoZSA8aW1nPiByZWZlcmVjaW5nIHRoZW0gd291bGQndmUgYmVlbiBpbiBET00gb3JkZXIuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvNVxuICAgICAgICBlbGVtZW50cyA9IHNvcnRBcmVhKGVsZW1lbnRzLCBfY29udGV4dCk7XG4gICAgfVxuICAgIGVsZW1lbnRzID0gc29ydFRhYmluZGV4KGVsZW1lbnRzKTtcbiAgICByZXR1cm4gZWxlbWVudHM7XG59XG5mdW5jdGlvbiBxdWVyeVRhYnNlcXVlbmNlKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSwgY29udGV4dCA9IF9yZWYuY29udGV4dCwgaW5jbHVkZUNvbnRleHQgPSBfcmVmLmluY2x1ZGVDb250ZXh0LCBpbmNsdWRlT25seVRhYmJhYmxlID0gX3JlZi5pbmNsdWRlT25seVRhYmJhYmxlLCBzdHJhdGVneSA9IF9yZWYuc3RyYXRlZ3k7XG4gICAgaWYgKCFzdXBwb3J0cyQ4KSB7XG4gICAgICAgIHN1cHBvcnRzJDggPSBfc3VwcG9ydHMoKTtcbiAgICB9XG4gICAgdmFyIF9jb250ZXh0ID0gbm9kZUFycmF5KGNvbnRleHQpWzBdIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgZWxlbWVudHMgPSBxdWVyeVRhYmJhYmxlKHtcbiAgICAgICAgY29udGV4dDogX2NvbnRleHQsXG4gICAgICAgIGluY2x1ZGVDb250ZXh0OiBpbmNsdWRlQ29udGV4dCxcbiAgICAgICAgaW5jbHVkZU9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZSxcbiAgICAgICAgc3RyYXRlZ3k6IHN0cmF0ZWd5XG4gICAgfSk7XG4gICAgaWYgKGRvY3VtZW50LmJvZHkuY3JlYXRlU2hhZG93Um9vdCAmJiBwbGF0Zm9ybS5pcy5CTElOSykge1xuICAgICAgICAvLyBzb3J0IHRhYmluZGV4IGxvY2FsaXplZCB0byBzaGFkb3cgZG9tXG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzZcbiAgICAgICAgZWxlbWVudHMgPSBzb3J0U2hhZG93ZWQoZWxlbWVudHMsIF9jb250ZXh0LCBzb3J0RWxlbWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnRzID0gc29ydEVsZW1lbnRzKGVsZW1lbnRzLCBfY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChpbmNsdWRlQ29udGV4dCkge1xuICAgICAgICAvLyBpZiB3ZSBpbmNsdWRlIHRoZSBjb250ZXh0IGl0c2VsZiwgaXQgaGFzIHRvIGJlIHRoZSBmaXJzdFxuICAgICAgICAvLyBlbGVtZW50IG9mIHRoZSBzZXF1ZW5jZVxuICAgICAgICBlbGVtZW50cyA9IG1vdmVDb250ZXh0VG9CZWdpbm5pbmcoZWxlbWVudHMsIF9jb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xufVxuLy8gY29kZXMgbW9zdGx5IGNsb25lZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rZWl0aGFtdXMvandlcnR5L2Jsb2IvbWFzdGVyL2p3ZXJ0eS5qc1xuLy8gZGVsaWJlcmF0ZWx5IG5vdCBleHBvc2luZyBjaGFyYWN0ZXJzIGxpa2UgPCwuLSMqIGJlY2F1c2UgdGhleSB2YXJ5ICp3aWxkbHkqXG4vLyBhY3Jvc3Mga2V5Ym9hcmQgbGF5b3V0cyBhbmQgbWF5IGNhdXNlIHZhcmlvdXMgcHJvYmxlbXNcbi8vIChlLmcuIFwiKlwiIGlzIFwiU2hpZnQgK1wiIG9uIGEgR2VybWFuIE1hYyBrZXlib2FyZClcbi8vIChlLmcuIFwiQFwiIGlzIFwiQWx0IExcIiBvbiBhIEdlcm1hbiBNYWMga2V5Ym9hcmQpXG52YXIga2V5Y29kZSA9IHtcbiAgICAvLyBFbGVtZW50IEZvY3VzXG4gICAgdGFiOiA5LFxuICAgIC8vIE5hdmlnYXRpb25cbiAgICBsZWZ0OiAzNyxcbiAgICB1cDogMzgsXG4gICAgcmlnaHQ6IDM5LFxuICAgIGRvd246IDQwLFxuICAgIHBhZ2VVcDogMzMsXG4gICAgXCJwYWdlLXVwXCI6IDMzLFxuICAgIHBhZ2VEb3duOiAzNCxcbiAgICBcInBhZ2UtZG93blwiOiAzNCxcbiAgICBlbmQ6IDM1LFxuICAgIGhvbWU6IDM2LFxuICAgIC8vIEFjdGlvblxuICAgIGVudGVyOiAxMyxcbiAgICBlc2NhcGU6IDI3LFxuICAgIHNwYWNlOiAzMixcbiAgICAvLyBNb2RpZmllclxuICAgIHNoaWZ0OiAxNixcbiAgICBjYXBzTG9jazogMjAsXG4gICAgXCJjYXBzLWxvY2tcIjogMjAsXG4gICAgY3RybDogMTcsXG4gICAgYWx0OiAxOCxcbiAgICBtZXRhOiA5MSxcbiAgICAvLyBpbiBmaXJlZm94OiAyMjRcbiAgICAvLyBvbiBtYWMgKGNocm9tZSk6IG1ldGEtbGVmdD05MSwgbWV0YS1yaWdodD05M1xuICAgIC8vIG9uIHdpbiAoSUUxMSk6IG1ldGEtbGVmdD05MSwgbWV0YS1yaWdodD05MlxuICAgIHBhdXNlOiAxOSxcbiAgICAvLyBDb250ZW50IE1hbmlwdWxhdGlvblxuICAgIGluc2VydDogNDUsXG4gICAgZGVsZXRlOiA0NixcbiAgICBiYWNrc3BhY2U6IDgsXG4gICAgLy8gdGhlIHNhbWUgbG9naWNhbCBrZXkgbWF5IGJlIGlkZW50aWZpZWQgdGhyb3VnaCBkaWZmZXJlbnQga2V5Q29kZXNcbiAgICBfYWxpYXM6IHtcbiAgICAgICAgOTE6IFtcbiAgICAgICAgICAgIDkyLFxuICAgICAgICAgICAgOTMsXG4gICAgICAgICAgICAyMjRcbiAgICAgICAgXVxuICAgIH1cbn07XG4vLyBGdW5jdGlvbiBrZXlzICgxMTIgLSAxMzcpXG4vLyBOT1RFOiBub3QgZXZlcnkga2V5Ym9hcmQga25vd3MgRjEzK1xuZm9yKHZhciBuID0gMTsgbiA8IDI2OyBuKyspe1xuICAgIGtleWNvZGVbXCJmXCIgKyBuXSA9IG4gKyAxMTE7XG59XG4vLyBOdW1iZXIga2V5cyAoNDgtNTcsIG51bXBhZCA5Ni0xMDUpXG4vLyBOT1RFOiBub3QgZXZlcnkga2V5Ym9hcmQga25vd3MgbnVtLTArXG5mb3IodmFyIF9uID0gMDsgX24gPCAxMDsgX24rKyl7XG4gICAgdmFyIGNvZGUgPSBfbiArIDQ4O1xuICAgIHZhciBudW1Db2RlID0gX24gKyA5NjtcbiAgICBrZXljb2RlW19uXSA9IGNvZGU7XG4gICAga2V5Y29kZVtcIm51bS1cIiArIF9uXSA9IG51bUNvZGU7XG4gICAga2V5Y29kZS5fYWxpYXNbY29kZV0gPSBbXG4gICAgICAgIG51bUNvZGVcbiAgICBdO1xufVxuLy8gTGF0aW4gY2hhcmFjdGVycyAoNjUgLSA5MClcbmZvcih2YXIgX24yID0gMDsgX24yIDwgMjY7IF9uMisrKXtcbiAgICB2YXIgX2NvZGUgPSBfbjIgKyA2NTtcbiAgICB2YXIgbmFtZSQxID0gU3RyaW5nLmZyb21DaGFyQ29kZShfY29kZSkudG9Mb3dlckNhc2UoKTtcbiAgICBrZXljb2RlW25hbWUkMV0gPSBfY29kZTtcbn1cbnZhciBtb2RpZmllciA9IHtcbiAgICBhbHQ6IFwiYWx0S2V5XCIsXG4gICAgY3RybDogXCJjdHJsS2V5XCIsXG4gICAgbWV0YTogXCJtZXRhS2V5XCIsXG4gICAgc2hpZnQ6IFwic2hpZnRLZXlcIlxufTtcbnZhciBtb2RpZmllclNlcXVlbmNlID0gT2JqZWN0LmtleXMobW9kaWZpZXIpLm1hcChmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyW25hbWVdO1xufSk7XG5mdW5jdGlvbiBjcmVhdGVFeHBlY3RlZE1vZGlmaWVycyhpZ25vcmVNb2RpZmllcnMpIHtcbiAgICB2YXIgdmFsdWUgPSBpZ25vcmVNb2RpZmllcnMgPyBudWxsIDogZmFsc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWx0S2V5OiB2YWx1ZSxcbiAgICAgICAgY3RybEtleTogdmFsdWUsXG4gICAgICAgIG1ldGFLZXk6IHZhbHVlLFxuICAgICAgICBzaGlmdEtleTogdmFsdWVcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgICB2YXIgaWdub3JlTW9kaWZpZXJzID0gbW9kaWZpZXJzLmluZGV4T2YoXCIqXCIpICE9PSAtMTtcbiAgICB2YXIgZXhwZWN0ZWQgPSBjcmVhdGVFeHBlY3RlZE1vZGlmaWVycyhpZ25vcmVNb2RpZmllcnMpO1xuICAgIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbiA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgY292ZXJlZCB0aGUgYWxsLWluIG9wZXJhdG9yXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2Ugd2FudCB0aGUgbW9kaWZpZXIgcHJlc3NlZFxuICAgICAgICB2YXIgdmFsdWUgPSB0cnVlO1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSB0b2tlbi5zbGljZSgwLCAxKTtcbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSBcIj9cIikge1xuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgY2FyZSBpZiB0aGUgbW9kaWZpZXIgaXMgcHJlc3NlZFxuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdG9yID09PSBcIiFcIikge1xuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdGhlIG1vZGlmaWVyIHByZXNzZWRcbiAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBjb21wZW5zYXRlIGZvciB0aGUgbW9kaWZpZXIncyBvcGVyYXRvclxuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbi5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0gbW9kaWZpZXJbdG9rZW5dO1xuICAgICAgICBpZiAoIXByb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBtb2RpZmllciBcIicgKyB0b2tlbiArICdcIicpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdGVkW3Byb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXhwZWN0ZWQ7XG59XG5mdW5jdGlvbiByZXNvbHZlS2V5KGtleSkge1xuICAgIHZhciBjb2RlID0ga2V5Y29kZVtrZXldIHx8IHBhcnNlSW50KGtleSwgMTApO1xuICAgIGlmICghY29kZSB8fCB0eXBlb2YgY29kZSAhPT0gXCJudW1iZXJcIiB8fCBpc05hTihjb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY29kZVxuICAgIF0uY29uY2F0KGtleWNvZGUuX2FsaWFzW2NvZGVdIHx8IFtdKTtcbn1cbmZ1bmN0aW9uIG1hdGNoTW9kaWZpZXJzKGV4cGVjdGVkLCBldmVudCkge1xuICAgIC8vIHJldHVybnMgdHJ1ZSBvbiBtYXRjaFxuICAgIHJldHVybiAhbW9kaWZpZXJTZXF1ZW5jZS5zb21lKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgLy8gcmV0dXJucyB0cnVlIG9uIG1pc21hdGNoXG4gICAgICAgIHJldHVybiB0eXBlb2YgZXhwZWN0ZWRbcHJvcF0gPT09IFwiYm9vbGVhblwiICYmIEJvb2xlYW4oZXZlbnRbcHJvcF0pICE9PSBleHBlY3RlZFtwcm9wXTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGtleUJpbmRpbmcodGV4dCkge1xuICAgIHJldHVybiB0ZXh0LnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uKF90ZXh0KSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSBfdGV4dC5zcGxpdChcIitcIik7XG4gICAgICAgIHZhciBfbW9kaWZpZXJzID0gcmVzb2x2ZU1vZGlmaWVycyh0b2tlbnMuc2xpY2UoMCwgLTEpKTtcbiAgICAgICAgdmFyIF9rZXlDb2RlcyA9IHJlc29sdmVLZXkodG9rZW5zLnNsaWNlKC0xKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXlDb2RlczogX2tleUNvZGVzLFxuICAgICAgICAgICAgbW9kaWZpZXJzOiBfbW9kaWZpZXJzLFxuICAgICAgICAgICAgbWF0Y2hNb2RpZmllcnM6IG1hdGNoTW9kaWZpZXJzLmJpbmQobnVsbCwgX21vZGlmaWVycylcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbi8vIE5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24gaXMgYXZhaWxhYmxlIHNpbmNlIElFOVxuLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Ob2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG4vLyBjYWxsYmFjayByZXR1cm5zIHRydWUgd2hlbiBlbGVtZW50IGlzIGNvbnRhaW5lZCBieSBwYXJlbnQgb3IgaXMgdGhlIHBhcmVudCBzdWl0ZWQgZm9yIHVzZSB3aXRoIEFycmF5LnNvbWUoKVxuLypcbiAgVVNBR0U6XG4gICAgdmFyIGlzQ2hpbGRPZiA9IGdldFBhcmVudENvbXBhcmF0b3Ioe3BhcmVudDogc29tZU5vZGV9KTtcbiAgICBsaXN0T2ZFbGVtZW50cy5zb21lKGlzQ2hpbGRPZilcbiovIGZ1bmN0aW9uIGdldFBhcmVudENvbXBhcmF0b3IoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LCBwYXJlbnQgPSBfcmVmLnBhcmVudCwgZWxlbWVudCA9IF9yZWYuZWxlbWVudCwgaW5jbHVkZVNlbGYgPSBfcmVmLmluY2x1ZGVTZWxmO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzQ2hpbGRPZihub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbihpbmNsdWRlU2VsZiAmJiBub2RlID09PSBwYXJlbnQgfHwgcGFyZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5vZGUpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaXNQYXJlbnRPZihub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbihpbmNsdWRlU2VsZiAmJiBlbGVtZW50ID09PSBub2RlIHx8IG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudCkgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ1dGlsL2NvbXBhcmUtcG9zaXRpb24jZ2V0UGFyZW50Q29tcGFyYXRvciByZXF1aXJlZCBlaXRoZXIgb3B0aW9ucy5wYXJlbnQgb3Igb3B0aW9ucy5lbGVtZW50XCIpO1xufVxuLy8gQnVnIDI4NjkzMyAtIEtleSBldmVudHMgaW4gdGhlIGF1dG9jb21wbGV0ZSBwb3B1cCBzaG91bGQgYmUgaGlkZGVuIGZyb20gcGFnZSBzY3JpcHRzXG4vLyBAYnJvd3Nlci1pc3N1ZSBHZWNrbyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yODY5MzNcbmZ1bmN0aW9uIHdoZW5LZXkoKSB7XG4gICAgdmFyIG1hcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIGJpbmRpbmdzID0ge307XG4gICAgdmFyIGNvbnRleHQgPSBub2RlQXJyYXkobWFwLmNvbnRleHQpWzBdIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBkZWxldGUgbWFwLmNvbnRleHQ7XG4gICAgdmFyIGZpbHRlciA9IG5vZGVBcnJheShtYXAuZmlsdGVyKTtcbiAgICBkZWxldGUgbWFwLmZpbHRlcjtcbiAgICB2YXIgbWFwS2V5cyA9IE9iamVjdC5rZXlzKG1hcCk7XG4gICAgaWYgKCFtYXBLZXlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwid2hlbi9rZXkgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIG9wdGlvbiBrZXlcIik7XG4gICAgfVxuICAgIHZhciByZWdpc3RlckJpbmRpbmcgPSBmdW5jdGlvbiByZWdpc3RlckJpbmRpbmcoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQua2V5Q29kZXMuZm9yRWFjaChmdW5jdGlvbihjb2RlKSB7XG4gICAgICAgICAgICBpZiAoIWJpbmRpbmdzW2NvZGVdKSB7XG4gICAgICAgICAgICAgICAgYmluZGluZ3NbY29kZV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpbmRpbmdzW2NvZGVdLnB1c2goZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIG1hcEtleXMuZm9yRWFjaChmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWFwW3RleHRdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3doZW4va2V5IHJlcXVpcmVzIG9wdGlvbltcIicgKyB0ZXh0ICsgJ1wiXSB0byBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFkZENhbGxiYWNrID0gZnVuY3Rpb24gYWRkQ2FsbGJhY2soZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LmNhbGxiYWNrID0gbWFwW3RleHRdO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICB9O1xuICAgICAgICBrZXlCaW5kaW5nKHRleHQpLm1hcChhZGRDYWxsYmFjaykuZm9yRWFjaChyZWdpc3RlckJpbmRpbmcpO1xuICAgIH0pO1xuICAgIHZhciBoYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZWxlbWVudHMgd2l0aGluIHRoZSBleGVtcHRlZCBzdWItdHJlZXNcbiAgICAgICAgICAgIHZhciBpc1BhcmVudE9mRWxlbWVudCA9IGdldFBhcmVudENvbXBhcmF0b3Ioe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICBpbmNsdWRlU2VsZjogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZmlsdGVyLnNvbWUoaXNQYXJlbnRPZkVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSBldmVudC5rZXlDb2RlIHx8IGV2ZW50LndoaWNoO1xuICAgICAgICBpZiAoIWJpbmRpbmdzW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBiaW5kaW5nc1trZXldLmZvckVhY2goZnVuY3Rpb24oX2V2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIV9ldmVudC5tYXRjaE1vZGlmaWVycyhldmVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZXZlbnQuY2FsbGJhY2suY2FsbChjb250ZXh0LCBldmVudCwgZGlzZW5nYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb250ZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24sIGZhbHNlKTtcbiAgICB2YXIgZGlzZW5nYWdlID0gZnVuY3Rpb24gZGlzZW5nYWdlKCkge1xuICAgICAgICBjb250ZXh0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24sIGZhbHNlKTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc2VuZ2FnZTogZGlzZW5nYWdlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9kZWZhdWx0KHBhcmFtKSB7XG4gICAgbGV0IHsgY29udGV4dCB9ID0gcGFyYW0gPT09IHZvaWQgMCA/IHt9IDogcGFyYW07XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgc3VwcG9ydHMgdGVzdHMgYXJlIHJ1biBiZWZvcmUgaW50ZXJjZXB0aW5nIHRoZSBUYWIga2V5LFxuICAgIC8vIG9yIElFMTAgYW5kIElFMTEgd2lsbCBmYWlsIHRvIHByb2Nlc3MgdGhlIGZpcnN0IFRhYiBrZXkgZXZlbnQuIE5vdFxuICAgIC8vIGxpbWl0aW5nIHRoaXMgd2FybS11cCB0byBJRSBiZWNhdXNlIGl0IG1heSBiZSBhIHByb2JsZW0gZWxzZXdoZXJlLCB0b28uXG4gICAgcXVlcnlUYWJzZXF1ZW5jZSgpO1xuICAgIHJldHVybiB3aGVuS2V5KHtcbiAgICAgICAgLy8gU2FmYXJpIG9uIE9TWCBtYXkgcmVxdWlyZSBBTFQrVEFCIHRvIHJlYWNoIGxpbmtzLFxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8xNDZcbiAgICAgICAgXCI/YWx0Kz9zaGlmdCt0YWJcIjogZnVuY3Rpb24gYWx0U2hpZnRUYWIoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIHdlJ3JlIGNvbXBsZXRlbHkgdGFraW5nIG92ZXIgdGhlIFRhYiBrZXkgaGFuZGxpbmdcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgc2VxdWVuY2UgPSBxdWVyeVRhYnNlcXVlbmNlKHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBiYWNrd2FyZCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgICAgICAgICAgdmFyIGZpcnN0ID0gc2VxdWVuY2VbMF07XG4gICAgICAgICAgICB2YXIgbGFzdCA9IHNlcXVlbmNlW3NlcXVlbmNlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgLy8gd3JhcCBhcm91bmQgZmlyc3QgdG8gbGFzdCwgbGFzdCB0byBmaXJzdFxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGJhY2t3YXJkID8gZmlyc3QgOiBsYXN0O1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGJhY2t3YXJkID8gbGFzdCA6IGZpcnN0O1xuICAgICAgICAgICAgaWYgKGlzQWN0aXZlRWxlbWVudChzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmluZCBjdXJyZW50IHBvc2l0aW9uIGluIHRhYnNlcXVlbmNlXG4gICAgICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gc2VxdWVuY2Uuc29tZShmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNBY3RpdmVFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAvLyByZWRpcmVjdCB0byBmaXJzdCBhcyB3ZSdyZSBub3QgaW4gb3VyIHRhYnNlcXVlbmNlXG4gICAgICAgICAgICAgICAgZmlyc3QuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzaGlmdCBmb2N1cyB0byBwcmV2aW91cy9uZXh0IGVsZW1lbnQgaW4gdGhlIHNlcXVlbmNlXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gYmFja3dhcmQgPyAtMSA6IDE7XG4gICAgICAgICAgICBzZXF1ZW5jZVtjdXJyZW50SW5kZXggKyBvZmZzZXRdLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFpbnRhaW4tLXRhYi1mb2N1cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2RlZmF1bHQiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX3BsYXRmb3JtIiwiXyIsIl9jc3Nlc2NhcGUiLCJub2RlQXJyYXkiLCJpbnB1dCIsIkFycmF5IiwiaXNBcnJheSIsIm5vZGVUeXBlIiwidW5kZWZpbmVkIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwibGVuZ3RoIiwic2xpY2UiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiY29udGV4dFRvRWxlbWVudCIsIl9yZWYiLCJjb250ZXh0IiwiX3JlZiRsYWJlbCIsImxhYmVsIiwicmVzb2x2ZURvY3VtZW50IiwiZGVmYXVsdFRvRG9jdW1lbnQiLCJlbGVtZW50IiwiTm9kZSIsIkRPQ1VNRU5UX05PREUiLCJkb2N1bWVudEVsZW1lbnQiLCJFTEVNRU5UX05PREUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwiZ2V0U2hhZG93SG9zdCIsImFyZ3VtZW50cyIsImNvbnRhaW5lciIsInBhcmVudE5vZGUiLCJob3N0IiwiZ2V0RG9jdW1lbnQiLCJub2RlIiwib3duZXJEb2N1bWVudCIsImlzQWN0aXZlRWxlbWVudCIsIl9kb2N1bWVudCIsImFjdGl2ZUVsZW1lbnQiLCJzaGFkb3dIb3N0Iiwic2hhZG93Um9vdCIsImdldFBhcmVudHMiLCJsaXN0IiwicHVzaCIsIm5hbWVzIiwibmFtZSIsImZpbmRNZXRob2ROYW1lIiwic29tZSIsIl9uYW1lIiwiZWxlbWVudE1hdGNoZXMiLCJzZWxlY3RvciIsInBsYXRmb3JtIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiZGVmYXVsdCIsIm9zIiwiZmFtaWx5IiwiQU5EUk9JRCIsIldJTkRPV1MiLCJPU1giLCJJT1MiLCJCTElOSyIsImxheW91dCIsIkdFQ0tPIiwiVFJJREVOVCIsIkVER0UiLCJXRUJLSVQiLCJ2ZXJzaW9uIiwicGFyc2VGbG9hdCIsIm1ham9yVmVyc2lvbiIsIk1hdGgiLCJmbG9vciIsImlzIiwiSUU5IiwiSUUxMCIsIklFMTEiLCJiZWZvcmUiLCJkYXRhIiwid2luZG93U2Nyb2xsVG9wIiwid2luZG93Iiwic2Nyb2xsVG9wIiwid2luZG93U2Nyb2xsTGVmdCIsInNjcm9sbExlZnQiLCJib2R5U2Nyb2xsVG9wIiwiYm9keSIsImJvZHlTY3JvbGxMZWZ0IiwiaWZyYW1lIiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsImFwcGVuZENoaWxkIiwiX3dpbmRvdyIsImNvbnRlbnRXaW5kb3ciLCJvcGVuIiwiY2xvc2UiLCJ3cmFwcGVyIiwidGVzdCIsIm9wdGlvbnMiLCJpbm5lckhUTUwiLCJmb2N1cyIsIm11dGF0ZSIsInZhbGlkYXRlIiwiYWZ0ZXIiLCJibHVyIiwicmVtb3ZlQ2hpbGQiLCJkZXRlY3RGb2N1cyIsInRlc3RzIiwicmVzdWx0cyIsImtleXMiLCJtYXAiLCJrZXkiLCJ2ZXJzaW9uJDEiLCJyZWFkTG9jYWxTdG9yYWdlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImUiLCJ3cml0ZUxvY2FsU3RvcmFnZSIsImhhc0ZvY3VzIiwicmVtb3ZlSXRlbSIsInNldEl0ZW0iLCJ1c2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJjYWNoZUtleSIsImNhY2hlIiwiY2FjaGUkMSIsInNldCIsInZhbHVlcyIsImZvckVhY2giLCJ0aW1lIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiY3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvciIsImNvbWJpbmF0b3IiLCJxdWVyeVNlbGVjdG9yIiwibm9BcnJvd0Fycm93QXJyb3ciLCJub0RlZXAiLCJnaWYiLCJmb2N1c0FyZWFJbWdUYWJpbmRleCIsImZvY3VzQXJlYVRhYmluZGV4IiwiZm9jdXNUYXJnZXQiLCJmb2N1c0FyZWFXaXRob3V0SHJlZiIsImZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHMiLCJpbnZhbGlkR2lmIiwiZm9jdXNCcm9rZW5JbWFnZU1hcCIsImZvY3VzQ2hpbGRyZW5PZkZvY3VzYWJsZUZsZXhib3giLCJmb2N1c0ZpZWxkc2V0RGlzYWJsZWQiLCJmb2N1c0ZpZWxkc2V0IiwiZm9jdXNGbGV4Ym94Q29udGFpbmVyIiwiZm9jdXNGb3JtRGlzYWJsZWQiLCJmb2N1c0ltZ0lzbWFwIiwiaHJlZiIsImZvY3VzSW1nVXNlbWFwVGFiaW5kZXgiLCJmb2N1c0luSGlkZGVuSWZyYW1lIiwiaWZyYW1lRG9jdW1lbnQiLCJzdHlsZSIsInZpc2liaWxpdHkiLCJyZXN1bHQiLCJmb2N1c0luWmVyb0RpbWVuc2lvbk9iamVjdCIsImZvY3VzSW52YWxpZFRhYmluZGV4IiwiZm9jdXNMYWJlbFRhYmluZGV4IiwidmFyaWFibGVUb1ByZXZlbnREZWFkQ29kZUVsaW1pbmF0aW9uIiwib2Zmc2V0SGVpZ2h0Iiwic3ZnIiwiZm9jdXNPYmplY3RTdmdIaWRkZW4iLCJmb2N1c09iamVjdFN2ZyIsInJlc3VsdCQxIiwiZm9jdXNPYmplY3RTd2YiLCJmb2N1c1JlZGlyZWN0SW1nVXNlbWFwIiwidGFyZ2V0IiwiZm9jdXNSZWRpcmVjdExlZ2VuZCIsImZvY3VzYWJsZSIsInRhYmJhYmxlIiwiZm9jdXNTY3JvbGxCb2R5IiwiZm9jdXNTY3JvbGxDb250YWluZXJXaXRob3V0T3ZlcmZsb3ciLCJmb2N1c1Njcm9sbENvbnRhaW5lciIsImZvY3VzU3VtbWFyeSIsImZpcnN0RWxlbWVudENoaWxkIiwibWFrZUZvY3VzYWJsZUZvcmVpZ25PYmplY3QiLCJmb3JlaWduT2JqZWN0IiwiY3JlYXRlRWxlbWVudE5TIiwid2lkdGgiLCJiYXNlVmFsIiwiaGVpZ2h0IiwibGFzdENoaWxkIiwidHlwZSIsImZvY3VzU3ZnRm9yZWlnbk9iamVjdEhhY2siLCJpc1N2Z0VsZW1lbnQiLCJvd25lclNWR0VsZW1lbnQiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiZGlzYWJsZWQiLCJnZW5lcmF0ZSIsIkhUTUxFbGVtZW50IiwicHJvdG90eXBlIiwiZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUiLCJmb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlIiwiZm9jdXNTdmdOZWdhdGl2ZVRhYmluZGV4QXR0cmlidXRlIiwiZm9jdXNTdmdVc2VUYWJpbmRleCIsImpvaW4iLCJmb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwicmVzdWx0JDIiLCJCb29sZWFuIiwiU1ZHRWxlbWVudCIsImZvY3VzU3ZnSW5JZnJhbWUiLCJmb2N1c1N2ZyIsImZpcnN0Q2hpbGQiLCJmb2N1c1RhYmluZGV4VHJhaWxpbmdDaGFyYWN0ZXJzIiwiZm9jdXNUYWJsZSIsImZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHMiLCJyZXN1bHQkMyIsInRhYnNlcXVlbmNlQXJlYUF0SW1nUG9zaXRpb24iLCJ0ZXN0Q2FsbGJhY2tzIiwidGVzdERlc2NyaXB0aW9ucyIsImV4ZWN1dGVUZXN0cyIsInN1cHBvcnRzQ2FjaGUiLCJfc3VwcG9ydHMiLCJzdXBwb3J0cyIsInZhbGlkSW50ZWdlclBhdHRlcm5Ob1RyYWlsaW5nIiwidmFsaWRJbnRlZ2VyUGF0dGVybldpdGhUcmFpbGluZyIsImlzVmFsaWRUYWJpbmRleCIsInZhbGlkSW50ZWdlclBhdHRlcm4iLCJoYXNUYWJpbmRleCIsImhhc0F0dHJpYnV0ZSIsImhhc1RhYkluZGV4IiwidGFiaW5kZXgiLCJnZXRBdHRyaWJ1dGUiLCJ0YWJpbmRleFZhbHVlIiwiYXR0cmlidXRlTmFtZSIsInBhcnNlSW50IiwiaXNOYU4iLCJpc1VzZXJNb2RpZnlXcml0YWJsZSIsInVzZXJNb2RpZnkiLCJ3ZWJraXRVc2VyTW9kaWZ5IiwiaW5kZXhPZiIsImhhc0Nzc092ZXJmbG93U2Nyb2xsIiwiZ2V0UHJvcGVydHlWYWx1ZSIsIm92ZXJmbG93IiwiaGFzQ3NzRGlzcGxheUZsZXgiLCJkaXNwbGF5IiwiaXNTY3JvbGxhYmxlQ29udGFpbmVyIiwicGFyZW50Tm9kZU5hbWUiLCJwYXJlbnRTdHlsZSIsInNjcm9sbEhlaWdodCIsIm9mZnNldFdpZHRoIiwic2Nyb2xsV2lkdGgiLCJzdXBwb3J0cyQxIiwiaXNGb2N1c1JlbGV2YW50UnVsZXMiLCJfcmVmJGV4Y2VwdCIsImV4Y2VwdCIsImZsZXhib3giLCJzY3JvbGxhYmxlIiwic2hhZG93Iiwic3ZnVHlwZSIsInZhbGlkVGFiaW5kZXgiLCJpc1N2Z0NvbnRlbnQiLCJmb2N1c2FibGVBdHRyaWJ1dGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiaGFzTGlua1BhcmVudCIsInBhcmVudCIsInBhcmVudEVsZW1lbnQiLCJpc0ZvY3VzUmVsZXZhbnQiLCJydWxlcyIsImZpbmRJbmRleCIsImFycmF5IiwiY2FsbGJhY2siLCJpIiwiZ2V0Q29udGVudERvY3VtZW50IiwiY29udGVudERvY3VtZW50IiwiZ2V0U1ZHRG9jdW1lbnQiLCJnZXRXaW5kb3ciLCJkZWZhdWx0VmlldyIsInNoYWRvd1ByZWZpeCIsInNlbGVjdEluU2hhZG93cyIsIm9wZXJhdG9yIiwicmVwbGFjZSIsInNwbGl0IiwiZmluZERvY3VtZW50SG9zdEVsZW1lbnQiLCJfZnJhbWVFbGVtZW50IiwicG90ZW50aWFsSG9zdHMiLCJnZXRGcmFtZUVsZW1lbnQiLCJmcmFtZUVsZW1lbnQiLCJub3RSZW5kZXJlZEVsZW1lbnRzUGF0dGVybiIsImNvbXB1dGVkU3R5bGUiLCJwcm9wZXJ0eSIsIm5vdERpc3BsYXllZCIsIl9wYXRoIiwibm90VmlzaWJsZSIsImhpZGRlbiIsInZpc2libGUiLCJjb2xsYXBzZWRQYXJlbnQiLCJvZmZzZXQiLCJpc1Zpc2libGVSdWxlcyIsIm5vdFJlbmRlcmVkIiwiY3NzRGlzcGxheSIsImNzc1Zpc2liaWxpdHkiLCJkZXRhaWxzRWxlbWVudCIsImJyb3dzaW5nQ29udGV4dCIsImlzQXVkaW9XaXRob3V0Q29udHJvbHMiLCJfaXNWaXNpYmxlIiwiaXNWaXNpYmxlIiwiZ2V0TWFwQnlOYW1lIiwiZ2V0SW1hZ2VPZkFyZWEiLCJzdXBwb3J0cyQyIiwiaXNWYWxpZEFyZWEiLCJpbWciLCJjb21wbGV0ZSIsIm5hdHVyYWxIZWlnaHQiLCJjaGlsZE9mSW50ZXJhY3RpdmUiLCJfZWxlbWVudCIsInN1cHBvcnRzJDMiLCJkaXNhYmxlZEVsZW1lbnRzUGF0dGVybiIsImRpc2FibGVkRWxlbWVudHMiLCJzZWxlY3QiLCJ0ZXh0YXJlYSIsImJ1dHRvbiIsImZpZWxkc2V0IiwiZm9ybSIsImlzTmF0aXZlRGlzYWJsZWRTdXBwb3J0ZWQiLCJSZWdFeHAiLCJzdXBwb3J0cyQ0IiwiaXNEaXNhYmxlZEZpZWxkc2V0IiwiaXNEaXNhYmxlZEZvcm0iLCJpc0Rpc2FibGVkIiwicGFyZW50cyIsImlzT25seVRhYmJhYmxlUnVsZXMiLCJvbmx5Rm9jdXNhYmxlQnJvd3NpbmdDb250ZXh0IiwiaXNPbmx5VGFiYmFibGUiLCJzdXBwb3J0cyQ1IiwiaXNPbmx5Rm9jdXNSZWxldmFudCIsIl90YWJpbmRleCIsImlzRm9jdXNhYmxlUnVsZXMiLCJvbmx5VGFiYmFibGUiLCJfaXNPbmx5VGFiYmFibGUiLCJmb2N1c1JlbGV2YW50IiwidmlzaWJpbGl0eU9wdGlvbnMiLCJfbm9kZU5hbWUyIiwiX25vZGVOYW1lIiwiaXNGb2N1c2FibGUiLCJjcmVhdGVGaWx0ZXIiLCJjb25kaXRpb24iLCJmaWx0ZXIiLCJOb2RlRmlsdGVyIiwiRklMVEVSX0FDQ0VQVCIsIkZJTFRFUl9TS0lQIiwiYWNjZXB0Tm9kZSIsIlBvc3NpYmx5Rm9jdXNhYmxlRmlsdGVyIiwicXVlcnlGb2N1c2FibGVTdHJpY3QiLCJpbmNsdWRlQ29udGV4dCIsImluY2x1ZGVPbmx5VGFiYmFibGUiLCJzdHJhdGVneSIsIl9pc0ZvY3VzYWJsZSIsIndhbGtlciIsImNyZWF0ZVRyZWVXYWxrZXIiLCJTSE9XX0VMRU1FTlQiLCJuZXh0Tm9kZSIsImN1cnJlbnROb2RlIiwiY29uY2F0IiwidW5zaGlmdCIsInN1cHBvcnRzJDYiLCJzZWxlY3RvciQxIiwic2VsZWN0b3IkMiIsInF1ZXJ5Rm9jdXNhYmxlUXVpY2siLCJfc2VsZWN0b3IiLCJlbGVtZW50cyIsInF1ZXJ5Rm9jdXNhYmxlIiwiX3JlZiRzdHJhdGVneSIsInN1cHBvcnRzJDciLCJmb2N1c2FibGVFbGVtZW50c1BhdHRlcm4iLCJpc1RhYmJhYmxlUnVsZXMiLCJmcmFtZU5vZGVOYW1lIiwiaXNGaXhlZEJsaW5rIiwiaGFzVGFiYmFibGVUYWJpbmRleE9yTm9uZSIsImhhc1RhYmJhYmxlVGFiaW5kZXgiLCJwb3RlbnRpYWxseVRhYmJhYmxlIiwidGFiSW5kZXgiLCJfc3R5bGUiLCJfc3R5bGUyIiwiaXNGb2N1c1JlbGV2YW50V2l0aG91dEZsZXhib3giLCJpc1RhYmJhYmxlV2l0aG91dEZsZXhib3giLCJpc1RhYmJhYmxlIiwicXVlcnlUYWJiYWJsZSIsIl9pc1RhYmJhYmxlIiwiY29tcGFyZURvbVBvc2l0aW9uIiwiYSIsImIiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsIkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyIsInNvcnREb21PcmRlciIsInNvcnQiLCJnZXRGaXJzdFN1Y2Nlc3Nvck9mZnNldCIsImZpbmRJbnNlcnRpb25PZmZzZXRzIiwicmVzb2x2ZUVsZW1lbnQiLCJpbnNlcnRpb25zIiwiaW5qZWN0aW9ucyIsImluc2VydEVsZW1lbnRzQXRPZmZzZXRzIiwiaW5zZXJ0ZWQiLCJpbnNlcnRpb24iLCJyZW1vdmUiLCJhcmdzIiwic3BsaWNlIiwiYXBwbHkiLCJtZXJnZUluRG9tT3JkZXIiLCJfbGlzdCIsIl9lbGVtZW50cyIsIl9jcmVhdGVDbGFzcyIsImRlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJNYXBzIiwibWFwcyIsImdldEFyZWFzRm9yIiwiYWRkTWFwQnlOYW1lIiwiZXh0cmFjdEFyZWFzRnJvbUxpc3QiLCJzb3J0QXJlYSIsInVzZW1hcHMiLCJpbWFnZSIsIl9jcmVhdGVDbGFzcyQxIiwiX2NsYXNzQ2FsbENoZWNrJDEiLCJTaGFkb3dzIiwic29ydEVsZW1lbnRzIiwiaG9zdENvdW50ZXIiLCJpbkhvc3QiLCJpbkRvY3VtZW50IiwiaG9zdHMiLCJfcmVnaXN0ZXJIb3N0IiwiX3NvcnRpbmdJZCIsInBhcmVudEhvc3QiLCJfcmVnaXN0ZXJIb3N0UGFyZW50IiwiX3JlZ2lzdGVyRWxlbWVudCIsImV4dHJhY3RFbGVtZW50cyIsIl9pbmplY3RIb3N0cyIsIl9yZXBsYWNlSG9zdHMiLCJfY2xlYW51cCIsIl9jb250ZXh0IiwiX21lcmdlIiwibWVyZ2VkIiwiX3Jlc29sdmVIb3N0RWxlbWVudCIsImJpbmQiLCJzb3J0U2hhZG93ZWQiLCJzaGFkb3dzIiwic29ydFRhYmluZGV4IiwiaW5kZXhlcyIsIm5vcm1hbCIsInJlZHVjZVJpZ2h0IiwicHJldmlvdXMiLCJjdXJyZW50Iiwic3VwcG9ydHMkOCIsIm1vdmVDb250ZXh0VG9CZWdpbm5pbmciLCJwb3MiLCJ0bXAiLCJxdWVyeVRhYnNlcXVlbmNlIiwiY3JlYXRlU2hhZG93Um9vdCIsImtleWNvZGUiLCJ0YWIiLCJsZWZ0IiwidXAiLCJyaWdodCIsImRvd24iLCJwYWdlVXAiLCJwYWdlRG93biIsImVuZCIsImhvbWUiLCJlbnRlciIsImVzY2FwZSIsInNwYWNlIiwic2hpZnQiLCJjYXBzTG9jayIsImN0cmwiLCJhbHQiLCJtZXRhIiwicGF1c2UiLCJpbnNlcnQiLCJkZWxldGUiLCJiYWNrc3BhY2UiLCJfYWxpYXMiLCJuIiwiX24iLCJjb2RlIiwibnVtQ29kZSIsIl9uMiIsIl9jb2RlIiwibmFtZSQxIiwiZnJvbUNoYXJDb2RlIiwibW9kaWZpZXIiLCJtb2RpZmllclNlcXVlbmNlIiwiY3JlYXRlRXhwZWN0ZWRNb2RpZmllcnMiLCJpZ25vcmVNb2RpZmllcnMiLCJhbHRLZXkiLCJjdHJsS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5IiwicmVzb2x2ZU1vZGlmaWVycyIsIm1vZGlmaWVycyIsImV4cGVjdGVkIiwidG9rZW4iLCJwcm9wZXJ0eU5hbWUiLCJyZXNvbHZlS2V5IiwibWF0Y2hNb2RpZmllcnMiLCJldmVudCIsInByb3AiLCJrZXlCaW5kaW5nIiwidGV4dCIsIl90ZXh0IiwidG9rZW5zIiwiX21vZGlmaWVycyIsIl9rZXlDb2RlcyIsImtleUNvZGVzIiwiZ2V0UGFyZW50Q29tcGFyYXRvciIsImluY2x1ZGVTZWxmIiwiaXNDaGlsZE9mIiwiRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZIiwiaXNQYXJlbnRPZiIsIndoZW5LZXkiLCJiaW5kaW5ncyIsIm1hcEtleXMiLCJyZWdpc3RlckJpbmRpbmciLCJhZGRDYWxsYmFjayIsImhhbmRsZUtleURvd24iLCJkZWZhdWx0UHJldmVudGVkIiwiaXNQYXJlbnRPZkVsZW1lbnQiLCJrZXlDb2RlIiwid2hpY2giLCJfZXZlbnQiLCJkaXNlbmdhZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInBhcmFtIiwiYWx0U2hpZnRUYWIiLCJwcmV2ZW50RGVmYXVsdCIsInNlcXVlbmNlIiwiYmFja3dhcmQiLCJmaXJzdCIsImxhc3QiLCJzb3VyY2UiLCJjdXJyZW50SW5kZXgiLCJmb3VuZCIsImluZGV4IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/maintain--tab-focus.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/styles.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/styles.js ***!
  \**********************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"styles\", ({\n    enumerable: true,\n    get: function() {\n        return styles;\n    }\n}));\nconst _tagged_template_literal_loose = __webpack_require__(/*! @swc/helpers/_/_tagged_template_literal_loose */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_tagged_template_literal_loose.js\");\nconst _nooptemplate = __webpack_require__(/*! ../../helpers/noop-template */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\");\nfunction _templateObject() {\n    const data = _tagged_template_literal_loose._([\n        \"\\n  [data-nextjs-dialog-overlay] {\\n    position: fixed;\\n    top: 0;\\n    right: 0;\\n    bottom: 0;\\n    left: 0;\\n    overflow: auto;\\n    z-index: 9000;\\n\\n    display: flex;\\n    align-content: center;\\n    align-items: center;\\n    flex-direction: column;\\n    padding: 10vh 15px 0;\\n  }\\n\\n  @media (max-height: 812px) {\\n    [data-nextjs-dialog-overlay] {\\n      padding: 15px 15px 0;\\n    }\\n  }\\n\\n  [data-nextjs-dialog-backdrop] {\\n    position: fixed;\\n    top: 0;\\n    right: 0;\\n    bottom: 0;\\n    left: 0;\\n    background-color: rgba(17, 17, 17, 0.2);\\n    pointer-events: all;\\n    z-index: -1;\\n  }\\n\\n  [data-nextjs-dialog-backdrop-fixed] {\\n    cursor: not-allowed;\\n    -webkit-backdrop-filter: blur(8px);\\n    backdrop-filter: blur(8px);\\n  }\\n\"\n    ]);\n    _templateObject = function() {\n        return data;\n    };\n    return data;\n}\nconst styles = (0, _nooptemplate.noop)(_templateObject());\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=styles.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9PdmVybGF5L3N0eWxlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsMENBQXlDO0lBQ3JDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsaUNBQWlDQyxtQkFBT0EsQ0FBQyw0SUFBK0M7QUFDOUYsTUFBTUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQyx1SkFBNkI7QUFDM0QsU0FBU0U7SUFDTCxNQUFNQyxPQUFPSiwrQkFBK0JLLENBQUMsQ0FBQztRQUMxQztLQUNIO0lBQ0RGLGtCQUFrQjtRQUNkLE9BQU9DO0lBQ1g7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsTUFBTUwsU0FBUyxDQUFDLEdBQUdHLGNBQWNJLElBQUksRUFBRUg7QUFFdkMsSUFBSSxDQUFDLE9BQU9SLFFBQVFZLE9BQU8sS0FBSyxjQUFlLE9BQU9aLFFBQVFZLE9BQU8sS0FBSyxZQUFZWixRQUFRWSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9aLFFBQVFZLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktmLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUVksT0FBTyxFQUFFLGNBQWM7UUFBRVgsT0FBTztJQUFLO0lBQ25FSCxPQUFPZ0IsTUFBTSxDQUFDZCxRQUFRWSxPQUFPLEVBQUVaO0lBQy9CZSxPQUFPZixPQUFPLEdBQUdBLFFBQVFZLE9BQU87QUFDbEMsRUFFQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9jb21wb25lbnRzL092ZXJsYXkvc3R5bGVzLmpzP2UyYjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHlsZXNcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9XG59KTtcbmNvbnN0IF90YWdnZWRfdGVtcGxhdGVfbGl0ZXJhbF9sb29zZSA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9fdGFnZ2VkX3RlbXBsYXRlX2xpdGVyYWxfbG9vc2VcIik7XG5jb25zdCBfbm9vcHRlbXBsYXRlID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcbmZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdCgpIHtcbiAgICBjb25zdCBkYXRhID0gX3RhZ2dlZF90ZW1wbGF0ZV9saXRlcmFsX2xvb3NlLl8oW1xuICAgICAgICBcIlxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1vdmVybGF5XSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgei1pbmRleDogOTAwMDtcXG5cXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBwYWRkaW5nOiAxMHZoIDE1cHggMDtcXG4gIH1cXG5cXG4gIEBtZWRpYSAobWF4LWhlaWdodDogODEycHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZy1vdmVybGF5XSB7XFxuICAgICAgcGFkZGluZzogMTVweCAxNXB4IDA7XFxuICAgIH1cXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3BdIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB0b3A6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBib3R0b206IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTcsIDE3LCAxNywgMC4yKTtcXG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcXG4gICAgei1pbmRleDogLTE7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhY2tkcm9wLWZpeGVkXSB7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxuICAgIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOiBibHVyKDhweCk7XFxuICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cig4cHgpO1xcbiAgfVxcblwiXG4gICAgXSk7XG4gICAgX3RlbXBsYXRlT2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIGRhdGE7XG59XG5jb25zdCBzdHlsZXMgPSAoMCwgX25vb3B0ZW1wbGF0ZS5ub29wKShfdGVtcGxhdGVPYmplY3QoKSk7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic3R5bGVzIiwiX3RhZ2dlZF90ZW1wbGF0ZV9saXRlcmFsX2xvb3NlIiwicmVxdWlyZSIsIl9ub29wdGVtcGxhdGUiLCJfdGVtcGxhdGVPYmplY3QiLCJkYXRhIiwiXyIsIm5vb3AiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Overlay/styles.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/ShadowPortal.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/ShadowPortal.js ***!
  \********************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ShadowPortal\", ({\n    enumerable: true,\n    get: function() {\n        return ShadowPortal;\n    }\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _reactdom = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\nfunction ShadowPortal(param) {\n    _s();\n    let { children } = param;\n    let portalNode = _react.useRef(null);\n    let shadowNode = _react.useRef(null);\n    let [, forceUpdate] = _react.useState();\n    _react.useLayoutEffect(()=>{\n        const ownerDocument = document;\n        portalNode.current = ownerDocument.createElement(\"nextjs-portal\");\n        shadowNode.current = portalNode.current.attachShadow({\n            mode: \"open\"\n        });\n        ownerDocument.body.appendChild(portalNode.current);\n        forceUpdate({});\n        return ()=>{\n            if (portalNode.current && portalNode.current.ownerDocument) {\n                portalNode.current.ownerDocument.body.removeChild(portalNode.current);\n            }\n        };\n    }, []);\n    return shadowNode.current ? /*#__PURE__*/ (0, _reactdom.createPortal)(children, shadowNode.current) : null;\n}\n_s(ShadowPortal, \"P7YL0rn/sjH62F7+OsEXN5GMw3U=\");\n_c = ShadowPortal;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=ShadowPortal.js.map\nvar _c;\n$RefreshReg$(_c, \"ShadowPortal\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9TaGFkb3dQb3J0YWwuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsZ0RBQStDO0lBQzNDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsNEJBQTRCQyxtQkFBT0EsQ0FBQyxrSUFBMEM7QUFDcEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLDBCQUEwQkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyxtRkFBTztBQUN4RSxNQUFNRyxZQUFZSCxtQkFBT0EsQ0FBQywyRkFBVztBQUNyQyxTQUFTRixhQUFhTSxLQUFLOztJQUN2QixJQUFJLEVBQUVDLFFBQVEsRUFBRSxHQUFHRDtJQUNuQixJQUFJRSxhQUFhTCxPQUFPTSxNQUFNLENBQUM7SUFDL0IsSUFBSUMsYUFBYVAsT0FBT00sTUFBTSxDQUFDO0lBQy9CLElBQUksR0FBR0UsWUFBWSxHQUFHUixPQUFPUyxRQUFRO0lBQ3JDVCxPQUFPVSxlQUFlLENBQUM7UUFDbkIsTUFBTUMsZ0JBQWdCQztRQUN0QlAsV0FBV1EsT0FBTyxHQUFHRixjQUFjRyxhQUFhLENBQUM7UUFDakRQLFdBQVdNLE9BQU8sR0FBR1IsV0FBV1EsT0FBTyxDQUFDRSxZQUFZLENBQUM7WUFDakRDLE1BQU07UUFDVjtRQUNBTCxjQUFjTSxJQUFJLENBQUNDLFdBQVcsQ0FBQ2IsV0FBV1EsT0FBTztRQUNqREwsWUFBWSxDQUFDO1FBQ2IsT0FBTztZQUNILElBQUlILFdBQVdRLE9BQU8sSUFBSVIsV0FBV1EsT0FBTyxDQUFDRixhQUFhLEVBQUU7Z0JBQ3hETixXQUFXUSxPQUFPLENBQUNGLGFBQWEsQ0FBQ00sSUFBSSxDQUFDRSxXQUFXLENBQUNkLFdBQVdRLE9BQU87WUFDeEU7UUFDSjtJQUNKLEdBQUcsRUFBRTtJQUNMLE9BQU9OLFdBQVdNLE9BQU8sR0FBaUIsV0FBSCxHQUFJLElBQUdYLFVBQVVrQixZQUFZLEVBQUVoQixVQUFVRyxXQUFXTSxPQUFPLElBQUk7QUFDMUc7R0FwQlNoQjtLQUFBQTtBQXNCVCxJQUFJLENBQUMsT0FBT0osUUFBUTRCLE9BQU8sS0FBSyxjQUFlLE9BQU81QixRQUFRNEIsT0FBTyxLQUFLLFlBQVk1QixRQUFRNEIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPNUIsUUFBUTRCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcksvQixPQUFPQyxjQUFjLENBQUNDLFFBQVE0QixPQUFPLEVBQUUsY0FBYztRQUFFM0IsT0FBTztJQUFLO0lBQ25FSCxPQUFPZ0MsTUFBTSxDQUFDOUIsUUFBUTRCLE9BQU8sRUFBRTVCO0lBQy9CK0IsT0FBTy9CLE9BQU8sR0FBR0EsUUFBUTRCLE9BQU87QUFDbEMsRUFFQSx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9jb21wb25lbnRzL1NoYWRvd1BvcnRhbC5qcz8xZjExIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2hhZG93UG9ydGFsXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTaGFkb3dQb3J0YWw7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmRcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX3JlYWN0ZG9tID0gcmVxdWlyZShcInJlYWN0LWRvbVwiKTtcbmZ1bmN0aW9uIFNoYWRvd1BvcnRhbChwYXJhbSkge1xuICAgIGxldCB7IGNoaWxkcmVuIH0gPSBwYXJhbTtcbiAgICBsZXQgcG9ydGFsTm9kZSA9IF9yZWFjdC51c2VSZWYobnVsbCk7XG4gICAgbGV0IHNoYWRvd05vZGUgPSBfcmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGxldCBbLCBmb3JjZVVwZGF0ZV0gPSBfcmVhY3QudXNlU3RhdGUoKTtcbiAgICBfcmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgcG9ydGFsTm9kZS5jdXJyZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibmV4dGpzLXBvcnRhbFwiKTtcbiAgICAgICAgc2hhZG93Tm9kZS5jdXJyZW50ID0gcG9ydGFsTm9kZS5jdXJyZW50LmF0dGFjaFNoYWRvdyh7XG4gICAgICAgICAgICBtb2RlOiBcIm9wZW5cIlxuICAgICAgICB9KTtcbiAgICAgICAgb3duZXJEb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBvcnRhbE5vZGUuY3VycmVudCk7XG4gICAgICAgIGZvcmNlVXBkYXRlKHt9KTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAocG9ydGFsTm9kZS5jdXJyZW50ICYmIHBvcnRhbE5vZGUuY3VycmVudC5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgcG9ydGFsTm9kZS5jdXJyZW50Lm93bmVyRG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChwb3J0YWxOb2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gc2hhZG93Tm9kZS5jdXJyZW50ID8gLyojX19QVVJFX18qLyAoMCwgX3JlYWN0ZG9tLmNyZWF0ZVBvcnRhbCkoY2hpbGRyZW4sIHNoYWRvd05vZGUuY3VycmVudCkgOiBudWxsO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaGFkb3dQb3J0YWwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIlNoYWRvd1BvcnRhbCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiXyIsIl9yZWFjdGRvbSIsInBhcmFtIiwiY2hpbGRyZW4iLCJwb3J0YWxOb2RlIiwidXNlUmVmIiwic2hhZG93Tm9kZSIsImZvcmNlVXBkYXRlIiwidXNlU3RhdGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJvd25lckRvY3VtZW50IiwiZG9jdW1lbnQiLCJjdXJyZW50IiwiY3JlYXRlRWxlbWVudCIsImF0dGFjaFNoYWRvdyIsIm1vZGUiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsImNyZWF0ZVBvcnRhbCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/ShadowPortal.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/EditorLink.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/EditorLink.js ***!
  \***************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"EditorLink\", ({\n    enumerable: true,\n    get: function() {\n        return EditorLink;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _useopenineditor = __webpack_require__(/*! ../../helpers/use-open-in-editor */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-open-in-editor.js\");\nfunction EditorLink(param) {\n    let { file, isSourceFile, location } = param;\n    var _location_line, _location_column;\n    const open = (0, _useopenineditor.useOpenInEditor)({\n        file,\n        lineNumber: (_location_line = location == null ? void 0 : location.line) != null ? _location_line : 1,\n        column: (_location_column = location == null ? void 0 : location.column) != null ? _location_column : 0\n    });\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"div\", {\n        \"data-with-open-in-editor-link\": true,\n        \"data-with-open-in-editor-link-source-file\": isSourceFile ? true : undefined,\n        \"data-with-open-in-editor-link-import-trace\": isSourceFile ? undefined : true,\n        tabIndex: 10,\n        role: \"link\",\n        onClick: open,\n        title: \"Click to open in your editor\",\n        children: [\n            file,\n            location ? \":\" + location.line + \":\" + location.column : null,\n            /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"svg\", {\n                xmlns: \"http://www.w3.org/2000/svg\",\n                viewBox: \"0 0 24 24\",\n                fill: \"none\",\n                stroke: \"currentColor\",\n                strokeWidth: \"2\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(\"path\", {\n                        d: \"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\"\n                    }),\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(\"polyline\", {\n                        points: \"15 3 21 3 21 9\"\n                    }),\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(\"line\", {\n                        x1: \"10\",\n                        y1: \"14\",\n                        x2: \"21\",\n                        y2: \"3\"\n                    })\n                ]\n            })\n        ]\n    });\n}\n_c = EditorLink;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=EditorLink.js.map\nvar _c;\n$RefreshReg$(_c, \"EditorLink\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9UZXJtaW5hbC9FZGl0b3JMaW5rLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCw4Q0FBNkM7SUFDekNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQywyQkFBMkJDLG1CQUFPQSxDQUFDLGdJQUF5QztBQUNsRixNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyxxR0FBbUI7QUFDL0MsTUFBTUUsU0FBUyxXQUFXLEdBQUdILHlCQUF5QkksQ0FBQyxDQUFDSCxtQkFBT0EsQ0FBQyxtRkFBTztBQUN2RSxNQUFNSSxtQkFBbUJKLG1CQUFPQSxDQUFDLGlLQUFrQztBQUNuRSxTQUFTRixXQUFXTyxLQUFLO0lBQ3JCLElBQUksRUFBRUMsSUFBSSxFQUFFQyxZQUFZLEVBQUVDLFFBQVEsRUFBRSxHQUFHSDtJQUN2QyxJQUFJSSxnQkFBZ0JDO0lBQ3BCLE1BQU1DLE9BQU8sQ0FBQyxHQUFHUCxpQkFBaUJRLGVBQWUsRUFBRTtRQUMvQ047UUFDQU8sWUFBWSxDQUFDSixpQkFBaUJELFlBQVksT0FBTyxLQUFLLElBQUlBLFNBQVNNLElBQUksS0FBSyxPQUFPTCxpQkFBaUI7UUFDcEdNLFFBQVEsQ0FBQ0wsbUJBQW1CRixZQUFZLE9BQU8sS0FBSyxJQUFJQSxTQUFTTyxNQUFNLEtBQUssT0FBT0wsbUJBQW1CO0lBQzFHO0lBQ0EsT0FBcUIsV0FBSCxHQUFJLElBQUdULFlBQVllLElBQUksRUFBRSxPQUFPO1FBQzlDLGlDQUFpQztRQUNqQyw2Q0FBNkNULGVBQWUsT0FBT1U7UUFDbkUsOENBQThDVixlQUFlVSxZQUFZO1FBQ3pFQyxVQUFVO1FBQ1ZDLE1BQU07UUFDTkMsU0FBU1Q7UUFDVFUsT0FBTztRQUNQQyxVQUFVO1lBQ05oQjtZQUNBRSxXQUFXLE1BQU1BLFNBQVNNLElBQUksR0FBRyxNQUFNTixTQUFTTyxNQUFNLEdBQUc7WUFDekQsV0FBVyxHQUFJLElBQUdkLFlBQVllLElBQUksRUFBRSxPQUFPO2dCQUN2Q08sT0FBTztnQkFDUEMsU0FBUztnQkFDVEMsTUFBTTtnQkFDTkMsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkMsZUFBZTtnQkFDZkMsZ0JBQWdCO2dCQUNoQlAsVUFBVTtvQkFDTixXQUFXLEdBQUksSUFBR3JCLFlBQVk2QixHQUFHLEVBQUUsUUFBUTt3QkFDdkNDLEdBQUc7b0JBQ1A7b0JBQ0EsV0FBVyxHQUFJLElBQUc5QixZQUFZNkIsR0FBRyxFQUFFLFlBQVk7d0JBQzNDRSxRQUFRO29CQUNaO29CQUNBLFdBQVcsR0FBSSxJQUFHL0IsWUFBWTZCLEdBQUcsRUFBRSxRQUFRO3dCQUN2Q0csSUFBSTt3QkFDSkMsSUFBSTt3QkFDSkMsSUFBSTt3QkFDSkMsSUFBSTtvQkFDUjtpQkFDSDtZQUNMO1NBQ0g7SUFDTDtBQUNKO0tBNUNTdEM7QUE4Q1QsSUFBSSxDQUFDLE9BQU9KLFFBQVEyQyxPQUFPLEtBQUssY0FBZSxPQUFPM0MsUUFBUTJDLE9BQU8sS0FBSyxZQUFZM0MsUUFBUTJDLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTzNDLFFBQVEyQyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLOUMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRMkMsT0FBTyxFQUFFLGNBQWM7UUFBRTFDLE9BQU87SUFBSztJQUNuRUgsT0FBTytDLE1BQU0sQ0FBQzdDLFFBQVEyQyxPQUFPLEVBQUUzQztJQUMvQjhDLE9BQU85QyxPQUFPLEdBQUdBLFFBQVEyQyxPQUFPO0FBQ2xDLEVBRUEsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9UZXJtaW5hbC9FZGl0b3JMaW5rLmpzPzk2YzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFZGl0b3JMaW5rXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBFZGl0b3JMaW5rO1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9qc3hydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX3VzZW9wZW5pbmVkaXRvciA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL3VzZS1vcGVuLWluLWVkaXRvclwiKTtcbmZ1bmN0aW9uIEVkaXRvckxpbmsocGFyYW0pIHtcbiAgICBsZXQgeyBmaWxlLCBpc1NvdXJjZUZpbGUsIGxvY2F0aW9uIH0gPSBwYXJhbTtcbiAgICB2YXIgX2xvY2F0aW9uX2xpbmUsIF9sb2NhdGlvbl9jb2x1bW47XG4gICAgY29uc3Qgb3BlbiA9ICgwLCBfdXNlb3BlbmluZWRpdG9yLnVzZU9wZW5JbkVkaXRvcikoe1xuICAgICAgICBmaWxlLFxuICAgICAgICBsaW5lTnVtYmVyOiAoX2xvY2F0aW9uX2xpbmUgPSBsb2NhdGlvbiA9PSBudWxsID8gdm9pZCAwIDogbG9jYXRpb24ubGluZSkgIT0gbnVsbCA/IF9sb2NhdGlvbl9saW5lIDogMSxcbiAgICAgICAgY29sdW1uOiAoX2xvY2F0aW9uX2NvbHVtbiA9IGxvY2F0aW9uID09IG51bGwgPyB2b2lkIDAgOiBsb2NhdGlvbi5jb2x1bW4pICE9IG51bGwgPyBfbG9jYXRpb25fY29sdW1uIDogMFxuICAgIH0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3hzKShcImRpdlwiLCB7XG4gICAgICAgIFwiZGF0YS13aXRoLW9wZW4taW4tZWRpdG9yLWxpbmtcIjogdHJ1ZSxcbiAgICAgICAgXCJkYXRhLXdpdGgtb3Blbi1pbi1lZGl0b3ItbGluay1zb3VyY2UtZmlsZVwiOiBpc1NvdXJjZUZpbGUgPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgICAgICBcImRhdGEtd2l0aC1vcGVuLWluLWVkaXRvci1saW5rLWltcG9ydC10cmFjZVwiOiBpc1NvdXJjZUZpbGUgPyB1bmRlZmluZWQgOiB0cnVlLFxuICAgICAgICB0YWJJbmRleDogMTAsXG4gICAgICAgIHJvbGU6IFwibGlua1wiLFxuICAgICAgICBvbkNsaWNrOiBvcGVuLFxuICAgICAgICB0aXRsZTogXCJDbGljayB0byBvcGVuIGluIHlvdXIgZWRpdG9yXCIsXG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgbG9jYXRpb24gPyBcIjpcIiArIGxvY2F0aW9uLmxpbmUgKyBcIjpcIiArIGxvY2F0aW9uLmNvbHVtbiA6IG51bGwsXG4gICAgICAgICAgICAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3hzKShcInN2Z1wiLCB7XG4gICAgICAgICAgICAgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICAgICAgICAgICAgICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICAgICAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIyXCIsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShcInBhdGhcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZDogXCJNMTggMTN2NmEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMlY4YTIgMiAwIDAgMSAyLTJoNlwiXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwicG9seWxpbmVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBcIjE1IDMgMjEgMyAyMSA5XCJcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJsaW5lXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxOiBcIjEwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB5MTogXCIxNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDI6IFwiMjFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyOiBcIjNcIlxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIF1cbiAgICB9KTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RWRpdG9yTGluay5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiRWRpdG9yTGluayIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfanN4cnVudGltZSIsIl9yZWFjdCIsIl8iLCJfdXNlb3BlbmluZWRpdG9yIiwicGFyYW0iLCJmaWxlIiwiaXNTb3VyY2VGaWxlIiwibG9jYXRpb24iLCJfbG9jYXRpb25fbGluZSIsIl9sb2NhdGlvbl9jb2x1bW4iLCJvcGVuIiwidXNlT3BlbkluRWRpdG9yIiwibGluZU51bWJlciIsImxpbmUiLCJjb2x1bW4iLCJqc3hzIiwidW5kZWZpbmVkIiwidGFiSW5kZXgiLCJyb2xlIiwib25DbGljayIsInRpdGxlIiwiY2hpbGRyZW4iLCJ4bWxucyIsInZpZXdCb3giLCJmaWxsIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VMaW5lY2FwIiwic3Ryb2tlTGluZWpvaW4iLCJqc3giLCJkIiwicG9pbnRzIiwieDEiLCJ5MSIsIngyIiwieTIiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/EditorLink.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/Terminal.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/Terminal.js ***!
  \*************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Terminal\", ({\n    enumerable: true,\n    get: function() {\n        return Terminal;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _anser = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/compiled/anser */ \"(app-pages-browser)/./node_modules/next/dist/compiled/anser/index.js\"));\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _hotlinkedtext = __webpack_require__(/*! ../hot-linked-text */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/hot-linked-text/index.js\");\nconst _EditorLink = __webpack_require__(/*! ./EditorLink */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/EditorLink.js\");\nfunction getFile(lines) {\n    const contentFileName = lines.shift();\n    if (!contentFileName) return null;\n    const [fileName, line, column] = contentFileName.split(\":\", 3);\n    const parsedLine = Number(line);\n    const parsedColumn = Number(column);\n    const hasLocation = !Number.isNaN(parsedLine) && !Number.isNaN(parsedColumn);\n    return {\n        fileName: hasLocation ? fileName : contentFileName,\n        location: hasLocation ? {\n            line: parsedLine,\n            column: parsedColumn\n        } : undefined\n    };\n}\nfunction getImportTraceFiles(lines) {\n    if (lines.some((line)=>/ReactServerComponentsError:/.test(line)) || lines.some((line)=>/Import trace for requested module:/.test(line))) {\n        // Grab the lines at the end containing the files\n        const files = [];\n        while(/.+\\..+/.test(lines[lines.length - 1]) && !lines[lines.length - 1].includes(\":\")){\n            const file = lines.pop().trim();\n            files.unshift(file);\n        }\n        return files;\n    }\n    return [];\n}\nfunction getEditorLinks(content) {\n    const lines = content.split(\"\\n\");\n    const file = getFile(lines);\n    const importTraceFiles = getImportTraceFiles(lines);\n    return {\n        file,\n        source: lines.join(\"\\n\"),\n        importTraceFiles\n    };\n}\nconst Terminal = function Terminal(param) {\n    _s();\n    let { content } = param;\n    const { file, source, importTraceFiles } = _react.useMemo(()=>getEditorLinks(content), [\n        content\n    ]);\n    const decoded = _react.useMemo(()=>{\n        return _anser.default.ansiToJson(source, {\n            json: true,\n            use_classes: true,\n            remove_empty: true\n        });\n    }, [\n        source\n    ]);\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"div\", {\n        \"data-nextjs-terminal\": true,\n        children: [\n            file && /*#__PURE__*/ (0, _jsxruntime.jsx)(_EditorLink.EditorLink, {\n                isSourceFile: true,\n                file: file.fileName,\n                location: file.location\n            }, file.fileName),\n            /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"pre\", {\n                children: [\n                    decoded.map((entry, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(\"span\", {\n                            style: {\n                                color: entry.fg ? \"var(--color-\" + entry.fg + \")\" : undefined,\n                                ...entry.decoration === \"bold\" ? {\n                                    fontWeight: 800\n                                } : entry.decoration === \"italic\" ? {\n                                    fontStyle: \"italic\"\n                                } : undefined\n                            },\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hotlinkedtext.HotlinkedText, {\n                                text: entry.content\n                            })\n                        }, \"terminal-entry-\" + index)),\n                    importTraceFiles.map((importTraceFile)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(_EditorLink.EditorLink, {\n                            isSourceFile: false,\n                            file: importTraceFile\n                        }, importTraceFile))\n                ]\n            })\n        ]\n    });\n};\n_s(Terminal, \"nkmao/TIox3Jie/+6JvWO3hTKPQ=\");\n_c = Terminal;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=Terminal.js.map\nvar _c;\n$RefreshReg$(_c, \"Terminal\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9UZXJtaW5hbC9UZXJtaW5hbC5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0FBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCw0Q0FBMkM7SUFDdkNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQywyQkFBMkJDLG1CQUFPQSxDQUFDLGdJQUF5QztBQUNsRixNQUFNQyw0QkFBNEJELG1CQUFPQSxDQUFDLGtJQUEwQztBQUNwRixNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyxxR0FBbUI7QUFDL0MsTUFBTUcsU0FBUyxXQUFXLEdBQUdKLHlCQUF5QkssQ0FBQyxDQUFDSixtQkFBT0EsQ0FBQyxzR0FBMEI7QUFDMUYsTUFBTUssU0FBUyxXQUFXLEdBQUdKLDBCQUEwQkcsQ0FBQyxDQUFDSixtQkFBT0EsQ0FBQyxtRkFBTztBQUN4RSxNQUFNTSxpQkFBaUJOLG1CQUFPQSxDQUFDLHlKQUFvQjtBQUNuRCxNQUFNTyxjQUFjUCxtQkFBT0EsQ0FBQyxpSkFBYztBQUMxQyxTQUFTUSxRQUFRQyxLQUFLO0lBQ2xCLE1BQU1DLGtCQUFrQkQsTUFBTUUsS0FBSztJQUNuQyxJQUFJLENBQUNELGlCQUFpQixPQUFPO0lBQzdCLE1BQU0sQ0FBQ0UsVUFBVUMsTUFBTUMsT0FBTyxHQUFHSixnQkFBZ0JLLEtBQUssQ0FBQyxLQUFLO0lBQzVELE1BQU1DLGFBQWFDLE9BQU9KO0lBQzFCLE1BQU1LLGVBQWVELE9BQU9IO0lBQzVCLE1BQU1LLGNBQWMsQ0FBQ0YsT0FBT0csS0FBSyxDQUFDSixlQUFlLENBQUNDLE9BQU9HLEtBQUssQ0FBQ0Y7SUFDL0QsT0FBTztRQUNITixVQUFVTyxjQUFjUCxXQUFXRjtRQUNuQ1csVUFBVUYsY0FBYztZQUNwQk4sTUFBTUc7WUFDTkYsUUFBUUk7UUFDWixJQUFJSTtJQUNSO0FBQ0o7QUFDQSxTQUFTQyxvQkFBb0JkLEtBQUs7SUFDOUIsSUFBSUEsTUFBTWUsSUFBSSxDQUFDLENBQUNYLE9BQU8sOEJBQThCWSxJQUFJLENBQUNaLFVBQVVKLE1BQU1lLElBQUksQ0FBQyxDQUFDWCxPQUFPLHFDQUFxQ1ksSUFBSSxDQUFDWixRQUFRO1FBQ3JJLGlEQUFpRDtRQUNqRCxNQUFNYSxRQUFRLEVBQUU7UUFDaEIsTUFBTSxTQUFTRCxJQUFJLENBQUNoQixLQUFLLENBQUNBLE1BQU1rQixNQUFNLEdBQUcsRUFBRSxLQUFLLENBQUNsQixLQUFLLENBQUNBLE1BQU1rQixNQUFNLEdBQUcsRUFBRSxDQUFDQyxRQUFRLENBQUMsS0FBSztZQUNuRixNQUFNQyxPQUFPcEIsTUFBTXFCLEdBQUcsR0FBR0MsSUFBSTtZQUM3QkwsTUFBTU0sT0FBTyxDQUFDSDtRQUNsQjtRQUNBLE9BQU9IO0lBQ1g7SUFDQSxPQUFPLEVBQUU7QUFDYjtBQUNBLFNBQVNPLGVBQWVDLE9BQU87SUFDM0IsTUFBTXpCLFFBQVF5QixRQUFRbkIsS0FBSyxDQUFDO0lBQzVCLE1BQU1jLE9BQU9yQixRQUFRQztJQUNyQixNQUFNMEIsbUJBQW1CWixvQkFBb0JkO0lBQzdDLE9BQU87UUFDSG9CO1FBQ0FPLFFBQVEzQixNQUFNNEIsSUFBSSxDQUFDO1FBQ25CRjtJQUNKO0FBQ0o7QUFDQSxNQUFNckMsV0FBVyxTQUFTQSxTQUFTd0MsS0FBSzs7SUFDcEMsSUFBSSxFQUFFSixPQUFPLEVBQUUsR0FBR0k7SUFDbEIsTUFBTSxFQUFFVCxJQUFJLEVBQUVPLE1BQU0sRUFBRUQsZ0JBQWdCLEVBQUUsR0FBRzlCLE9BQU9rQyxPQUFPLENBQUMsSUFBSU4sZUFBZUMsVUFBVTtRQUNuRkE7S0FDSDtJQUNELE1BQU1NLFVBQVVuQyxPQUFPa0MsT0FBTyxDQUFDO1FBQzNCLE9BQU9wQyxPQUFPc0MsT0FBTyxDQUFDQyxVQUFVLENBQUNOLFFBQVE7WUFDckNPLE1BQU07WUFDTkMsYUFBYTtZQUNiQyxjQUFjO1FBQ2xCO0lBQ0osR0FBRztRQUNDVDtLQUNIO0lBQ0QsT0FBcUIsV0FBSCxHQUFJLElBQUdsQyxZQUFZNEMsSUFBSSxFQUFFLE9BQU87UUFDOUMsd0JBQXdCO1FBQ3hCQyxVQUFVO1lBQ05sQixRQUFzQixXQUFILEdBQUksSUFBRzNCLFlBQVk4QyxHQUFHLEVBQUV6QyxZQUFZMEMsVUFBVSxFQUFFO2dCQUMvREMsY0FBYztnQkFDZHJCLE1BQU1BLEtBQUtqQixRQUFRO2dCQUNuQlMsVUFBVVEsS0FBS1IsUUFBUTtZQUMzQixHQUFHUSxLQUFLakIsUUFBUTtZQUNoQixXQUFXLEdBQUksSUFBR1YsWUFBWTRDLElBQUksRUFBRSxPQUFPO2dCQUN2Q0MsVUFBVTtvQkFDTlAsUUFBUVcsR0FBRyxDQUFDLENBQUNDLE9BQU9DLFFBQXNCLFdBQUgsR0FBSSxJQUFHbkQsWUFBWThDLEdBQUcsRUFBRSxRQUFROzRCQUMvRE0sT0FBTztnQ0FDSEMsT0FBT0gsTUFBTUksRUFBRSxHQUFHLGlCQUFpQkosTUFBTUksRUFBRSxHQUFHLE1BQU1sQztnQ0FDcEQsR0FBRzhCLE1BQU1LLFVBQVUsS0FBSyxTQUFTO29DQUM3QkMsWUFBWTtnQ0FDaEIsSUFBSU4sTUFBTUssVUFBVSxLQUFLLFdBQVc7b0NBQ2hDRSxXQUFXO2dDQUNmLElBQUlyQyxTQUFTOzRCQUNqQjs0QkFDQXlCLFVBQXdCLFdBQUgsR0FBSSxJQUFHN0MsWUFBWThDLEdBQUcsRUFBRTFDLGVBQWVzRCxhQUFhLEVBQUU7Z0NBQ3ZFQyxNQUFNVCxNQUFNbEIsT0FBTzs0QkFDdkI7d0JBQ0osR0FBRyxvQkFBb0JtQjtvQkFDM0JsQixpQkFBaUJnQixHQUFHLENBQUMsQ0FBQ1csa0JBQWdDLFdBQUgsR0FBSSxJQUFHNUQsWUFBWThDLEdBQUcsRUFBRXpDLFlBQVkwQyxVQUFVLEVBQUU7NEJBQzNGQyxjQUFjOzRCQUNkckIsTUFBTWlDO3dCQUNWLEdBQUdBO2lCQUNWO1lBQ0w7U0FDSDtJQUNMO0FBQ0o7R0E3Q01oRTtLQUFBQTtBQStDTixJQUFJLENBQUMsT0FBT0osUUFBUStDLE9BQU8sS0FBSyxjQUFlLE9BQU8vQyxRQUFRK0MsT0FBTyxLQUFLLFlBQVkvQyxRQUFRK0MsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPL0MsUUFBUStDLE9BQU8sQ0FBQ3NCLFVBQVUsS0FBSyxhQUFhO0lBQ3JLdkUsT0FBT0MsY0FBYyxDQUFDQyxRQUFRK0MsT0FBTyxFQUFFLGNBQWM7UUFBRTlDLE9BQU87SUFBSztJQUNuRUgsT0FBT3dFLE1BQU0sQ0FBQ3RFLFFBQVErQyxPQUFPLEVBQUUvQztJQUMvQnVFLE9BQU92RSxPQUFPLEdBQUdBLFFBQVErQyxPQUFPO0FBQ2xDLEVBRUEsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9UZXJtaW5hbC9UZXJtaW5hbC5qcz8yNGEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGVybWluYWxcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFRlcm1pbmFsO1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbmNvbnN0IF9qc3hydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgX2Fuc2VyID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL2Fuc2VyXCIpKTtcbmNvbnN0IF9yZWFjdCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfaG90bGlua2VkdGV4dCA9IHJlcXVpcmUoXCIuLi9ob3QtbGlua2VkLXRleHRcIik7XG5jb25zdCBfRWRpdG9yTGluayA9IHJlcXVpcmUoXCIuL0VkaXRvckxpbmtcIik7XG5mdW5jdGlvbiBnZXRGaWxlKGxpbmVzKSB7XG4gICAgY29uc3QgY29udGVudEZpbGVOYW1lID0gbGluZXMuc2hpZnQoKTtcbiAgICBpZiAoIWNvbnRlbnRGaWxlTmFtZSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgW2ZpbGVOYW1lLCBsaW5lLCBjb2x1bW5dID0gY29udGVudEZpbGVOYW1lLnNwbGl0KFwiOlwiLCAzKTtcbiAgICBjb25zdCBwYXJzZWRMaW5lID0gTnVtYmVyKGxpbmUpO1xuICAgIGNvbnN0IHBhcnNlZENvbHVtbiA9IE51bWJlcihjb2x1bW4pO1xuICAgIGNvbnN0IGhhc0xvY2F0aW9uID0gIU51bWJlci5pc05hTihwYXJzZWRMaW5lKSAmJiAhTnVtYmVyLmlzTmFOKHBhcnNlZENvbHVtbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZU5hbWU6IGhhc0xvY2F0aW9uID8gZmlsZU5hbWUgOiBjb250ZW50RmlsZU5hbWUsXG4gICAgICAgIGxvY2F0aW9uOiBoYXNMb2NhdGlvbiA/IHtcbiAgICAgICAgICAgIGxpbmU6IHBhcnNlZExpbmUsXG4gICAgICAgICAgICBjb2x1bW46IHBhcnNlZENvbHVtblxuICAgICAgICB9IDogdW5kZWZpbmVkXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEltcG9ydFRyYWNlRmlsZXMobGluZXMpIHtcbiAgICBpZiAobGluZXMuc29tZSgobGluZSk9Pi9SZWFjdFNlcnZlckNvbXBvbmVudHNFcnJvcjovLnRlc3QobGluZSkpIHx8IGxpbmVzLnNvbWUoKGxpbmUpPT4vSW1wb3J0IHRyYWNlIGZvciByZXF1ZXN0ZWQgbW9kdWxlOi8udGVzdChsaW5lKSkpIHtcbiAgICAgICAgLy8gR3JhYiB0aGUgbGluZXMgYXQgdGhlIGVuZCBjb250YWluaW5nIHRoZSBmaWxlc1xuICAgICAgICBjb25zdCBmaWxlcyA9IFtdO1xuICAgICAgICB3aGlsZSgvLitcXC4uKy8udGVzdChsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSkgJiYgIWxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmluY2x1ZGVzKFwiOlwiKSl7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gbGluZXMucG9wKCkudHJpbSgpO1xuICAgICAgICAgICAgZmlsZXMudW5zaGlmdChmaWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZXM7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGdldEVkaXRvckxpbmtzKGNvbnRlbnQpIHtcbiAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoXCJcXG5cIik7XG4gICAgY29uc3QgZmlsZSA9IGdldEZpbGUobGluZXMpO1xuICAgIGNvbnN0IGltcG9ydFRyYWNlRmlsZXMgPSBnZXRJbXBvcnRUcmFjZUZpbGVzKGxpbmVzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaWxlLFxuICAgICAgICBzb3VyY2U6IGxpbmVzLmpvaW4oXCJcXG5cIiksXG4gICAgICAgIGltcG9ydFRyYWNlRmlsZXNcbiAgICB9O1xufVxuY29uc3QgVGVybWluYWwgPSBmdW5jdGlvbiBUZXJtaW5hbChwYXJhbSkge1xuICAgIGxldCB7IGNvbnRlbnQgfSA9IHBhcmFtO1xuICAgIGNvbnN0IHsgZmlsZSwgc291cmNlLCBpbXBvcnRUcmFjZUZpbGVzIH0gPSBfcmVhY3QudXNlTWVtbygoKT0+Z2V0RWRpdG9yTGlua3MoY29udGVudCksIFtcbiAgICAgICAgY29udGVudFxuICAgIF0pO1xuICAgIGNvbnN0IGRlY29kZWQgPSBfcmVhY3QudXNlTWVtbygoKT0+e1xuICAgICAgICByZXR1cm4gX2Fuc2VyLmRlZmF1bHQuYW5zaVRvSnNvbihzb3VyY2UsIHtcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICB1c2VfY2xhc3NlczogdHJ1ZSxcbiAgICAgICAgICAgIHJlbW92ZV9lbXB0eTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIHNvdXJjZVxuICAgIF0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3hzKShcImRpdlwiLCB7XG4gICAgICAgIFwiZGF0YS1uZXh0anMtdGVybWluYWxcIjogdHJ1ZSxcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIGZpbGUgJiYgLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfRWRpdG9yTGluay5FZGl0b3JMaW5rLCB7XG4gICAgICAgICAgICAgICAgaXNTb3VyY2VGaWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZpbGU6IGZpbGUuZmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IGZpbGUubG9jYXRpb25cbiAgICAgICAgICAgIH0sIGZpbGUuZmlsZU5hbWUpLFxuICAgICAgICAgICAgLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4cykoXCJwcmVcIiwge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgIGRlY29kZWQubWFwKChlbnRyeSwgaW5kZXgpPT4vKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwic3BhblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGVudHJ5LmZnID8gXCJ2YXIoLS1jb2xvci1cIiArIGVudHJ5LmZnICsgXCIpXCIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmVudHJ5LmRlY29yYXRpb24gPT09IFwiYm9sZFwiID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodDogODAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiBlbnRyeS5kZWNvcmF0aW9uID09PSBcIml0YWxpY1wiID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKF9ob3RsaW5rZWR0ZXh0LkhvdGxpbmtlZFRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZW50cnkuY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBcInRlcm1pbmFsLWVudHJ5LVwiICsgaW5kZXgpKSxcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0VHJhY2VGaWxlcy5tYXAoKGltcG9ydFRyYWNlRmlsZSk9Pi8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX0VkaXRvckxpbmsuRWRpdG9yTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU291cmNlRmlsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogaW1wb3J0VHJhY2VGaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBpbXBvcnRUcmFjZUZpbGUpKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIF1cbiAgICB9KTtcbn07XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRlcm1pbmFsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJUZXJtaW5hbCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX2pzeHJ1bnRpbWUiLCJfYW5zZXIiLCJfIiwiX3JlYWN0IiwiX2hvdGxpbmtlZHRleHQiLCJfRWRpdG9yTGluayIsImdldEZpbGUiLCJsaW5lcyIsImNvbnRlbnRGaWxlTmFtZSIsInNoaWZ0IiwiZmlsZU5hbWUiLCJsaW5lIiwiY29sdW1uIiwic3BsaXQiLCJwYXJzZWRMaW5lIiwiTnVtYmVyIiwicGFyc2VkQ29sdW1uIiwiaGFzTG9jYXRpb24iLCJpc05hTiIsImxvY2F0aW9uIiwidW5kZWZpbmVkIiwiZ2V0SW1wb3J0VHJhY2VGaWxlcyIsInNvbWUiLCJ0ZXN0IiwiZmlsZXMiLCJsZW5ndGgiLCJpbmNsdWRlcyIsImZpbGUiLCJwb3AiLCJ0cmltIiwidW5zaGlmdCIsImdldEVkaXRvckxpbmtzIiwiY29udGVudCIsImltcG9ydFRyYWNlRmlsZXMiLCJzb3VyY2UiLCJqb2luIiwicGFyYW0iLCJ1c2VNZW1vIiwiZGVjb2RlZCIsImRlZmF1bHQiLCJhbnNpVG9Kc29uIiwianNvbiIsInVzZV9jbGFzc2VzIiwicmVtb3ZlX2VtcHR5IiwianN4cyIsImNoaWxkcmVuIiwianN4IiwiRWRpdG9yTGluayIsImlzU291cmNlRmlsZSIsIm1hcCIsImVudHJ5IiwiaW5kZXgiLCJzdHlsZSIsImNvbG9yIiwiZmciLCJkZWNvcmF0aW9uIiwiZm9udFdlaWdodCIsImZvbnRTdHlsZSIsIkhvdGxpbmtlZFRleHQiLCJ0ZXh0IiwiaW1wb3J0VHJhY2VGaWxlIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/Terminal.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/index.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/index.js ***!
  \**********************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Terminal\", ({\n    enumerable: true,\n    get: function() {\n        return _Terminal.Terminal;\n    }\n}));\nconst _Terminal = __webpack_require__(/*! ./Terminal */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/Terminal.js\");\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9UZXJtaW5hbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsNENBQTJDO0lBQ3ZDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQyxVQUFVQyxRQUFRO0lBQzdCO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUQsWUFBWUUsbUJBQU9BLENBQUMsNklBQVk7QUFFdEMsSUFBSSxDQUFDLE9BQU9OLFFBQVFPLE9BQU8sS0FBSyxjQUFlLE9BQU9QLFFBQVFPLE9BQU8sS0FBSyxZQUFZUCxRQUFRTyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9QLFFBQVFPLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktWLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUU8sT0FBTyxFQUFFLGNBQWM7UUFBRU4sT0FBTztJQUFLO0lBQ25FSCxPQUFPVyxNQUFNLENBQUNULFFBQVFPLE9BQU8sRUFBRVA7SUFDL0JVLE9BQU9WLE9BQU8sR0FBR0EsUUFBUU8sT0FBTztBQUNsQyxFQUVBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvVGVybWluYWwvaW5kZXguanM/OTUyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRlcm1pbmFsXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfVGVybWluYWwuVGVybWluYWw7XG4gICAgfVxufSk7XG5jb25zdCBfVGVybWluYWwgPSByZXF1aXJlKFwiLi9UZXJtaW5hbFwiKTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIl9UZXJtaW5hbCIsIlRlcm1pbmFsIiwicmVxdWlyZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/styles.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/styles.js ***!
  \***********************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"styles\", ({\n    enumerable: true,\n    get: function() {\n        return styles;\n    }\n}));\nconst _tagged_template_literal_loose = __webpack_require__(/*! @swc/helpers/_/_tagged_template_literal_loose */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_tagged_template_literal_loose.js\");\nconst _nooptemplate = __webpack_require__(/*! ../../helpers/noop-template */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\");\nfunction _templateObject() {\n    const data = _tagged_template_literal_loose._([\n        \"\\n  [data-nextjs-terminal] {\\n    border-radius: var(--size-gap-half);\\n    background-color: var(--color-ansi-bg);\\n    color: var(--color-ansi-fg);\\n  }\\n  [data-nextjs-terminal]::selection,\\n  [data-nextjs-terminal] *::selection {\\n    background-color: var(--color-ansi-selection);\\n  }\\n  [data-nextjs-terminal] * {\\n    color: inherit;\\n    background-color: transparent;\\n    font-family: var(--font-stack-monospace);\\n  }\\n  [data-nextjs-terminal] > * {\\n    margin: 0;\\n    padding: calc(var(--size-gap) + var(--size-gap-half))\\n      calc(var(--size-gap-double) + var(--size-gap-half));\\n  }\\n\\n  [data-nextjs-terminal] pre {\\n    white-space: pre-wrap;\\n    word-break: break-word;\\n  }\\n\\n  [data-with-open-in-editor-link] svg {\\n    width: auto;\\n    height: var(--size-font-small);\\n    margin-left: var(--size-gap);\\n  }\\n  [data-with-open-in-editor-link] {\\n    cursor: pointer;\\n  }\\n  [data-with-open-in-editor-link]:hover {\\n    text-decoration: underline dotted;\\n  }\\n  [data-with-open-in-editor-link-source-file] {\\n    border-bottom: 1px solid var(--color-ansi-bright-black);\\n    display: flex;\\n    align-items: center;\\n    justify-content: space-between;\\n  }\\n  [data-with-open-in-editor-link-import-trace] {\\n    margin-left: var(--size-gap-double);\\n  }\\n  [data-nextjs-terminal] a {\\n    color: inherit;\\n  }\\n\"\n    ]);\n    _templateObject = function() {\n        return data;\n    };\n    return data;\n}\nconst styles = (0, _nooptemplate.noop)(_templateObject());\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=styles.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9UZXJtaW5hbC9zdHlsZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDBDQUF5QztJQUNyQ0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLGlDQUFpQ0MsbUJBQU9BLENBQUMsNElBQStDO0FBQzlGLE1BQU1DLGdCQUFnQkQsbUJBQU9BLENBQUMsdUpBQTZCO0FBQzNELFNBQVNFO0lBQ0wsTUFBTUMsT0FBT0osK0JBQStCSyxDQUFDLENBQUM7UUFDMUM7S0FDSDtJQUNERixrQkFBa0I7UUFDZCxPQUFPQztJQUNYO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLE1BQU1MLFNBQVMsQ0FBQyxHQUFHRyxjQUFjSSxJQUFJLEVBQUVIO0FBRXZDLElBQUksQ0FBQyxPQUFPUixRQUFRWSxPQUFPLEtBQUssY0FBZSxPQUFPWixRQUFRWSxPQUFPLEtBQUssWUFBWVosUUFBUVksT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPWixRQUFRWSxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLZixPQUFPQyxjQUFjLENBQUNDLFFBQVFZLE9BQU8sRUFBRSxjQUFjO1FBQUVYLE9BQU87SUFBSztJQUNuRUgsT0FBT2dCLE1BQU0sQ0FBQ2QsUUFBUVksT0FBTyxFQUFFWjtJQUMvQmUsT0FBT2YsT0FBTyxHQUFHQSxRQUFRWSxPQUFPO0FBQ2xDLEVBRUEsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9UZXJtaW5hbC9zdHlsZXMuanM/N2Q3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0eWxlc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH1cbn0pO1xuY29uc3QgX3RhZ2dlZF90ZW1wbGF0ZV9saXRlcmFsX2xvb3NlID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL190YWdnZWRfdGVtcGxhdGVfbGl0ZXJhbF9sb29zZVwiKTtcbmNvbnN0IF9ub29wdGVtcGxhdGUgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuZnVuY3Rpb24gX3RlbXBsYXRlT2JqZWN0KCkge1xuICAgIGNvbnN0IGRhdGEgPSBfdGFnZ2VkX3RlbXBsYXRlX2xpdGVyYWxfbG9vc2UuXyhbXG4gICAgICAgIFwiXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYmcpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdOjpzZWxlY3Rpb24sXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdICo6OnNlbGVjdGlvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktc2VsZWN0aW9uKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gKiB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gPiAqIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxcbiAgICAgIGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gcHJlIHtcXG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbiAgICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xcbiAgfVxcblxcbiAgW2RhdGEtd2l0aC1vcGVuLWluLWVkaXRvci1saW5rXSBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXApO1xcbiAgfVxcbiAgW2RhdGEtd2l0aC1vcGVuLWluLWVkaXRvci1saW5rXSB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gIH1cXG4gIFtkYXRhLXdpdGgtb3Blbi1pbi1lZGl0b3ItbGlua106aG92ZXIge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICB9XFxuICBbZGF0YS13aXRoLW9wZW4taW4tZWRpdG9yLWxpbmstc291cmNlLWZpbGVdIHtcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LWJsYWNrKTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgfVxcbiAgW2RhdGEtd2l0aC1vcGVuLWluLWVkaXRvci1saW5rLWltcG9ydC10cmFjZV0ge1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gYSB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgfVxcblwiXG4gICAgXSk7XG4gICAgX3RlbXBsYXRlT2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIGRhdGE7XG59XG5jb25zdCBzdHlsZXMgPSAoMCwgX25vb3B0ZW1wbGF0ZS5ub29wKShfdGVtcGxhdGVPYmplY3QoKSk7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic3R5bGVzIiwiX3RhZ2dlZF90ZW1wbGF0ZV9saXRlcmFsX2xvb3NlIiwicmVxdWlyZSIsIl9ub29wdGVtcGxhdGUiLCJfdGVtcGxhdGVPYmplY3QiLCJkYXRhIiwiXyIsIm5vb3AiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Terminal/styles.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/Toast.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/Toast.js ***!
  \*******************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Toast\", ({\n    enumerable: true,\n    get: function() {\n        return Toast;\n    }\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst Toast = function Toast(param) {\n    let { onClick, children, className } = param;\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"div\", {\n        \"data-nextjs-toast\": true,\n        onClick: onClick,\n        className: className,\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"div\", {\n            \"data-nextjs-toast-wrapper\": true,\n            children: children\n        })\n    });\n};\n_c = Toast;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=Toast.js.map\nvar _c;\n$RefreshReg$(_c, \"Toast\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9Ub2FzdC9Ub2FzdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgseUNBQXdDO0lBQ3BDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsNEJBQTRCQyxtQkFBT0EsQ0FBQyxrSUFBMEM7QUFDcEYsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMscUdBQW1CO0FBQy9DLE1BQU1FLFNBQVMsV0FBVyxHQUFHSCwwQkFBMEJJLENBQUMsQ0FBQ0gsbUJBQU9BLENBQUMsbUZBQU87QUFDeEUsTUFBTUYsUUFBUSxTQUFTQSxNQUFNTSxLQUFLO0lBQzlCLElBQUksRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUVDLFNBQVMsRUFBRSxHQUFHSDtJQUN2QyxPQUFxQixXQUFILEdBQUksSUFBR0gsWUFBWU8sR0FBRyxFQUFFLE9BQU87UUFDN0MscUJBQXFCO1FBQ3JCSCxTQUFTQTtRQUNURSxXQUFXQTtRQUNYRCxVQUF3QixXQUFILEdBQUksSUFBR0wsWUFBWU8sR0FBRyxFQUFFLE9BQU87WUFDaEQsNkJBQTZCO1lBQzdCRixVQUFVQTtRQUNkO0lBQ0o7QUFDSjtLQVhNUjtBQWFOLElBQUksQ0FBQyxPQUFPSixRQUFRZSxPQUFPLEtBQUssY0FBZSxPQUFPZixRQUFRZSxPQUFPLEtBQUssWUFBWWYsUUFBUWUsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPZixRQUFRZSxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLbEIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRZSxPQUFPLEVBQUUsY0FBYztRQUFFZCxPQUFPO0lBQUs7SUFDbkVILE9BQU9tQixNQUFNLENBQUNqQixRQUFRZSxPQUFPLEVBQUVmO0lBQy9Ca0IsT0FBT2xCLE9BQU8sR0FBR0EsUUFBUWUsT0FBTztBQUNsQyxFQUVBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvVG9hc3QvVG9hc3QuanM/ZGMzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRvYXN0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBUb2FzdDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbmNvbnN0IF9qc3hydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IFRvYXN0ID0gZnVuY3Rpb24gVG9hc3QocGFyYW0pIHtcbiAgICBsZXQgeyBvbkNsaWNrLCBjaGlsZHJlbiwgY2xhc3NOYW1lIH0gPSBwYXJhbTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShcImRpdlwiLCB7XG4gICAgICAgIFwiZGF0YS1uZXh0anMtdG9hc3RcIjogdHJ1ZSxcbiAgICAgICAgb25DbGljazogb25DbGljayxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwiZGl2XCIsIHtcbiAgICAgICAgICAgIFwiZGF0YS1uZXh0anMtdG9hc3Qtd3JhcHBlclwiOiB0cnVlLFxuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgIH0pXG4gICAgfSk7XG59O1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ub2FzdC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiVG9hc3QiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwicmVxdWlyZSIsIl9qc3hydW50aW1lIiwiX3JlYWN0IiwiXyIsInBhcmFtIiwib25DbGljayIsImNoaWxkcmVuIiwiY2xhc3NOYW1lIiwianN4IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/Toast.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/index.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/index.js ***!
  \*******************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    styles: function() {\n        return _styles.styles;\n    },\n    Toast: function() {\n        return _Toast.Toast;\n    }\n});\nconst _styles = __webpack_require__(/*! ./styles */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/styles.js\");\nconst _Toast = __webpack_require__(/*! ./Toast */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/Toast.js\");\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9Ub2FzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsUUFBUTtRQUNKLE9BQU9RLFFBQVFSLE1BQU07SUFDekI7SUFDQUMsT0FBTztRQUNILE9BQU9RLE9BQU9SLEtBQUs7SUFDdkI7QUFDSjtBQUNBLE1BQU1PLFVBQVVFLG1CQUFPQSxDQUFDLHNJQUFVO0FBQ2xDLE1BQU1ELFNBQVNDLG1CQUFPQSxDQUFDLG9JQUFTO0FBRWhDLElBQUksQ0FBQyxPQUFPYixRQUFRYyxPQUFPLEtBQUssY0FBZSxPQUFPZCxRQUFRYyxPQUFPLEtBQUssWUFBWWQsUUFBUWMsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPZCxRQUFRYyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLakIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRYyxPQUFPLEVBQUUsY0FBYztRQUFFYixPQUFPO0lBQUs7SUFDbkVILE9BQU9rQixNQUFNLENBQUNoQixRQUFRYyxPQUFPLEVBQUVkO0lBQy9CRSxPQUFPRixPQUFPLEdBQUdBLFFBQVFjLE9BQU87QUFDbEMsRUFFQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9jb21wb25lbnRzL1RvYXN0L2luZGV4LmpzP2QzYzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzdHlsZXM6IG51bGwsXG4gICAgVG9hc3Q6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgc3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdHlsZXMuc3R5bGVzO1xuICAgIH0sXG4gICAgVG9hc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX1RvYXN0LlRvYXN0O1xuICAgIH1cbn0pO1xuY29uc3QgX3N0eWxlcyA9IHJlcXVpcmUoXCIuL3N0eWxlc1wiKTtcbmNvbnN0IF9Ub2FzdCA9IHJlcXVpcmUoXCIuL1RvYXN0XCIpO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJzdHlsZXMiLCJUb2FzdCIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9zdHlsZXMiLCJfVG9hc3QiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/styles.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/styles.js ***!
  \********************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"styles\", ({\n    enumerable: true,\n    get: function() {\n        return styles;\n    }\n}));\nconst _tagged_template_literal_loose = __webpack_require__(/*! @swc/helpers/_/_tagged_template_literal_loose */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_tagged_template_literal_loose.js\");\nconst _nooptemplate = __webpack_require__(/*! ../../helpers/noop-template */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\");\nfunction _templateObject() {\n    const data = _tagged_template_literal_loose._([\n        \"\\n  [data-nextjs-toast] {\\n    position: fixed;\\n    bottom: var(--size-gap-double);\\n    left: var(--size-gap-double);\\n    max-width: 420px;\\n    z-index: 9000;\\n  }\\n\\n  @media (max-width: 440px) {\\n    [data-nextjs-toast] {\\n      max-width: 90vw;\\n      left: 5vw;\\n    }\\n  }\\n\\n  [data-nextjs-toast-wrapper] {\\n    padding: 16px;\\n    border-radius: var(--size-gap-half);\\n    font-weight: 500;\\n    color: var(--color-ansi-bright-white);\\n    background-color: var(--color-ansi-red);\\n    box-shadow: 0px var(--size-gap-double) var(--size-gap-quad)\\n      rgba(0, 0, 0, 0.25);\\n  }\\n\"\n    ]);\n    _templateObject = function() {\n        return data;\n    };\n    return data;\n}\nconst styles = (0, _nooptemplate.noop)(_templateObject());\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=styles.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9Ub2FzdC9zdHlsZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDBDQUF5QztJQUNyQ0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLGlDQUFpQ0MsbUJBQU9BLENBQUMsNElBQStDO0FBQzlGLE1BQU1DLGdCQUFnQkQsbUJBQU9BLENBQUMsdUpBQTZCO0FBQzNELFNBQVNFO0lBQ0wsTUFBTUMsT0FBT0osK0JBQStCSyxDQUFDLENBQUM7UUFDMUM7S0FDSDtJQUNERixrQkFBa0I7UUFDZCxPQUFPQztJQUNYO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLE1BQU1MLFNBQVMsQ0FBQyxHQUFHRyxjQUFjSSxJQUFJLEVBQUVIO0FBRXZDLElBQUksQ0FBQyxPQUFPUixRQUFRWSxPQUFPLEtBQUssY0FBZSxPQUFPWixRQUFRWSxPQUFPLEtBQUssWUFBWVosUUFBUVksT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPWixRQUFRWSxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLZixPQUFPQyxjQUFjLENBQUNDLFFBQVFZLE9BQU8sRUFBRSxjQUFjO1FBQUVYLE9BQU87SUFBSztJQUNuRUgsT0FBT2dCLE1BQU0sQ0FBQ2QsUUFBUVksT0FBTyxFQUFFWjtJQUMvQmUsT0FBT2YsT0FBTyxHQUFHQSxRQUFRWSxPQUFPO0FBQ2xDLEVBRUEsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9Ub2FzdC9zdHlsZXMuanM/N2ZjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0eWxlc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH1cbn0pO1xuY29uc3QgX3RhZ2dlZF90ZW1wbGF0ZV9saXRlcmFsX2xvb3NlID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL190YWdnZWRfdGVtcGxhdGVfbGl0ZXJhbF9sb29zZVwiKTtcbmNvbnN0IF9ub29wdGVtcGxhdGUgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuZnVuY3Rpb24gX3RlbXBsYXRlT2JqZWN0KCkge1xuICAgIGNvbnN0IGRhdGEgPSBfdGFnZ2VkX3RlbXBsYXRlX2xpdGVyYWxfbG9vc2UuXyhbXG4gICAgICAgIFwiXFxuICBbZGF0YS1uZXh0anMtdG9hc3RdIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICBib3R0b206IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICAgIGxlZnQ6IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICAgIG1heC13aWR0aDogNDIwcHg7XFxuICAgIHotaW5kZXg6IDkwMDA7XFxuICB9XFxuXFxuICBAbWVkaWEgKG1heC13aWR0aDogNDQwcHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLXRvYXN0XSB7XFxuICAgICAgbWF4LXdpZHRoOiA5MHZ3O1xcbiAgICAgIGxlZnQ6IDV2dztcXG4gICAgfVxcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLXRvYXN0LXdyYXBwZXJdIHtcXG4gICAgcGFkZGluZzogMTZweDtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWJyaWdodC13aGl0ZSk7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktcmVkKTtcXG4gICAgYm94LXNoYWRvdzogMHB4IHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgdmFyKC0tc2l6ZS1nYXAtcXVhZClcXG4gICAgICByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbiAgfVxcblwiXG4gICAgXSk7XG4gICAgX3RlbXBsYXRlT2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIGRhdGE7XG59XG5jb25zdCBzdHlsZXMgPSAoMCwgX25vb3B0ZW1wbGF0ZS5ub29wKShfdGVtcGxhdGVPYmplY3QoKSk7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic3R5bGVzIiwiX3RhZ2dlZF90ZW1wbGF0ZV9saXRlcmFsX2xvb3NlIiwicmVxdWlyZSIsIl9ub29wdGVtcGxhdGUiLCJfdGVtcGxhdGVPYmplY3QiLCJkYXRhIiwiXyIsIm5vb3AiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/Toast/styles.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/VersionStalenessInfo.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/VersionStalenessInfo.js ***!
  \*************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"VersionStalenessInfo\", ({\n    enumerable: true,\n    get: function() {\n        return VersionStalenessInfo;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nfunction VersionStalenessInfo(props) {\n    if (!props) return null;\n    const { staleness, installed, expected } = props;\n    let text = \"\";\n    let title = \"\";\n    let indicatorClass = \"\";\n    switch(staleness){\n        case \"fresh\":\n            text = \"Next.js is up to date\";\n            title = \"Latest available version is detected (\" + installed + \").\";\n            indicatorClass = \"fresh\";\n            break;\n        case \"stale-patch\":\n        case \"stale-minor\":\n            text = \"Next.js (\" + installed + \") out of date\";\n            title = \"There is a newer version (\" + expected + \") available, upgrade recommended! \";\n            indicatorClass = \"stale\";\n            break;\n        case \"stale-major\":\n            {\n                text = \"Next.js (\" + installed + \") is outdated\";\n                title = \"An outdated version detected (latest is \" + expected + \"), upgrade is highly recommended!\";\n                indicatorClass = \"outdated\";\n                break;\n            }\n        case \"stale-prerelease\":\n            {\n                text = \"Next.js (\" + installed + \") is outdated\";\n                title = \"There is a newer canary version (\" + expected + \") available, please upgrade! \";\n                indicatorClass = \"stale\";\n                break;\n            }\n        case \"newer-than-npm\":\n        case \"unknown\":\n            break;\n        default:\n            break;\n    }\n    if (!text) return null;\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"small\", {\n        className: \"nextjs-container-build-error-version-status\",\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(\"span\", {\n                className: indicatorClass\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(\"small\", {\n                className: \"nextjs-container-build-error-version-status\",\n                title: title,\n                children: text\n            }),\n            \" \",\n            staleness === \"fresh\" || staleness === \"unknown\" ? null : /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n                target: \"_blank\",\n                rel: \"noopener noreferrer\",\n                href: \"https://nextjs.org/docs/messages/version-staleness\",\n                children: \"(learn more)\"\n            })\n        ]\n    });\n}\n_c = VersionStalenessInfo;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=VersionStalenessInfo.js.map\nvar _c;\n$RefreshReg$(_c, \"VersionStalenessInfo\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9WZXJzaW9uU3RhbGVuZXNzSW5mby9WZXJzaW9uU3RhbGVuZXNzSW5mby5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsd0RBQXVEO0lBQ25ESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMscUdBQW1CO0FBQy9DLE1BQU1FLFNBQVMsV0FBVyxHQUFHSCx5QkFBeUJJLENBQUMsQ0FBQ0gsbUJBQU9BLENBQUMsbUZBQU87QUFDdkUsU0FBU0YscUJBQXFCTSxLQUFLO0lBQy9CLElBQUksQ0FBQ0EsT0FBTyxPQUFPO0lBQ25CLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVDLFFBQVEsRUFBRSxHQUFHSDtJQUMzQyxJQUFJSSxPQUFPO0lBQ1gsSUFBSUMsUUFBUTtJQUNaLElBQUlDLGlCQUFpQjtJQUNyQixPQUFPTDtRQUNILEtBQUs7WUFDREcsT0FBTztZQUNQQyxRQUFRLDJDQUEyQ0gsWUFBWTtZQUMvREksaUJBQWlCO1lBQ2pCO1FBQ0osS0FBSztRQUNMLEtBQUs7WUFDREYsT0FBTyxjQUFjRixZQUFZO1lBQ2pDRyxRQUFRLCtCQUErQkYsV0FBVztZQUNsREcsaUJBQWlCO1lBQ2pCO1FBQ0osS0FBSztZQUNEO2dCQUNJRixPQUFPLGNBQWNGLFlBQVk7Z0JBQ2pDRyxRQUFRLDZDQUE2Q0YsV0FBVztnQkFDaEVHLGlCQUFpQjtnQkFDakI7WUFDSjtRQUNKLEtBQUs7WUFDRDtnQkFDSUYsT0FBTyxjQUFjRixZQUFZO2dCQUNqQ0csUUFBUSxzQ0FBc0NGLFdBQVc7Z0JBQ3pERyxpQkFBaUI7Z0JBQ2pCO1lBQ0o7UUFDSixLQUFLO1FBQ0wsS0FBSztZQUNEO1FBQ0o7WUFDSTtJQUNSO0lBQ0EsSUFBSSxDQUFDRixNQUFNLE9BQU87SUFDbEIsT0FBcUIsV0FBSCxHQUFJLElBQUdQLFlBQVlVLElBQUksRUFBRSxTQUFTO1FBQ2hEQyxXQUFXO1FBQ1hDLFVBQVU7WUFDTixXQUFXLEdBQUksSUFBR1osWUFBWWEsR0FBRyxFQUFFLFFBQVE7Z0JBQ3ZDRixXQUFXRjtZQUNmO1lBQ0EsV0FBVyxHQUFJLElBQUdULFlBQVlhLEdBQUcsRUFBRSxTQUFTO2dCQUN4Q0YsV0FBVztnQkFDWEgsT0FBT0E7Z0JBQ1BJLFVBQVVMO1lBQ2Q7WUFDQTtZQUNBSCxjQUFjLFdBQVdBLGNBQWMsWUFBWSxPQUFxQixXQUFILEdBQUksSUFBR0osWUFBWWEsR0FBRyxFQUFFLEtBQUs7Z0JBQzlGQyxRQUFRO2dCQUNSQyxLQUFLO2dCQUNMQyxNQUFNO2dCQUNOSixVQUFVO1lBQ2Q7U0FDSDtJQUNMO0FBQ0o7S0EzRFNmO0FBNkRULElBQUksQ0FBQyxPQUFPSixRQUFRd0IsT0FBTyxLQUFLLGNBQWUsT0FBT3hCLFFBQVF3QixPQUFPLEtBQUssWUFBWXhCLFFBQVF3QixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU94QixRQUFRd0IsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySzNCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUXdCLE9BQU8sRUFBRSxjQUFjO1FBQUV2QixPQUFPO0lBQUs7SUFDbkVILE9BQU80QixNQUFNLENBQUMxQixRQUFRd0IsT0FBTyxFQUFFeEI7SUFDL0IyQixPQUFPM0IsT0FBTyxHQUFHQSxRQUFRd0IsT0FBTztBQUNsQyxFQUVBLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2NvbXBvbmVudHMvVmVyc2lvblN0YWxlbmVzc0luZm8vVmVyc2lvblN0YWxlbmVzc0luZm8uanM/YjdkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZlcnNpb25TdGFsZW5lc3NJbmZvXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBWZXJzaW9uU3RhbGVuZXNzSW5mbztcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfanN4cnVudGltZSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbmNvbnN0IF9yZWFjdCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIFZlcnNpb25TdGFsZW5lc3NJbmZvKHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgeyBzdGFsZW5lc3MsIGluc3RhbGxlZCwgZXhwZWN0ZWQgfSA9IHByb3BzO1xuICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICBsZXQgdGl0bGUgPSBcIlwiO1xuICAgIGxldCBpbmRpY2F0b3JDbGFzcyA9IFwiXCI7XG4gICAgc3dpdGNoKHN0YWxlbmVzcyl7XG4gICAgICAgIGNhc2UgXCJmcmVzaFwiOlxuICAgICAgICAgICAgdGV4dCA9IFwiTmV4dC5qcyBpcyB1cCB0byBkYXRlXCI7XG4gICAgICAgICAgICB0aXRsZSA9IFwiTGF0ZXN0IGF2YWlsYWJsZSB2ZXJzaW9uIGlzIGRldGVjdGVkIChcIiArIGluc3RhbGxlZCArIFwiKS5cIjtcbiAgICAgICAgICAgIGluZGljYXRvckNsYXNzID0gXCJmcmVzaFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdGFsZS1wYXRjaFwiOlxuICAgICAgICBjYXNlIFwic3RhbGUtbWlub3JcIjpcbiAgICAgICAgICAgIHRleHQgPSBcIk5leHQuanMgKFwiICsgaW5zdGFsbGVkICsgXCIpIG91dCBvZiBkYXRlXCI7XG4gICAgICAgICAgICB0aXRsZSA9IFwiVGhlcmUgaXMgYSBuZXdlciB2ZXJzaW9uIChcIiArIGV4cGVjdGVkICsgXCIpIGF2YWlsYWJsZSwgdXBncmFkZSByZWNvbW1lbmRlZCEgXCI7XG4gICAgICAgICAgICBpbmRpY2F0b3JDbGFzcyA9IFwic3RhbGVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3RhbGUtbWFqb3JcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gXCJOZXh0LmpzIChcIiArIGluc3RhbGxlZCArIFwiKSBpcyBvdXRkYXRlZFwiO1xuICAgICAgICAgICAgICAgIHRpdGxlID0gXCJBbiBvdXRkYXRlZCB2ZXJzaW9uIGRldGVjdGVkIChsYXRlc3QgaXMgXCIgKyBleHBlY3RlZCArIFwiKSwgdXBncmFkZSBpcyBoaWdobHkgcmVjb21tZW5kZWQhXCI7XG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yQ2xhc3MgPSBcIm91dGRhdGVkXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzdGFsZS1wcmVyZWxlYXNlXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IFwiTmV4dC5qcyAoXCIgKyBpbnN0YWxsZWQgKyBcIikgaXMgb3V0ZGF0ZWRcIjtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IFwiVGhlcmUgaXMgYSBuZXdlciBjYW5hcnkgdmVyc2lvbiAoXCIgKyBleHBlY3RlZCArIFwiKSBhdmFpbGFibGUsIHBsZWFzZSB1cGdyYWRlISBcIjtcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3JDbGFzcyA9IFwic3RhbGVcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm5ld2VyLXRoYW4tbnBtXCI6XG4gICAgICAgIGNhc2UgXCJ1bmtub3duXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIXRleHQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3hzKShcInNtYWxsXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcIm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItdmVyc2lvbi1zdGF0dXNcIixcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJzcGFuXCIsIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGluZGljYXRvckNsYXNzXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJzbWFsbFwiLCB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItdmVyc2lvbi1zdGF0dXNcIixcbiAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IHRleHRcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICBzdGFsZW5lc3MgPT09IFwiZnJlc2hcIiB8fCBzdGFsZW5lc3MgPT09IFwidW5rbm93blwiID8gbnVsbCA6IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJhXCIsIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICAgICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcbiAgICAgICAgICAgICAgICBocmVmOiBcImh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3ZlcnNpb24tc3RhbGVuZXNzXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiKGxlYXJuIG1vcmUpXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF1cbiAgICB9KTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmVyc2lvblN0YWxlbmVzc0luZm8uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIlZlcnNpb25TdGFsZW5lc3NJbmZvIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9qc3hydW50aW1lIiwiX3JlYWN0IiwiXyIsInByb3BzIiwic3RhbGVuZXNzIiwiaW5zdGFsbGVkIiwiZXhwZWN0ZWQiLCJ0ZXh0IiwidGl0bGUiLCJpbmRpY2F0b3JDbGFzcyIsImpzeHMiLCJjbGFzc05hbWUiLCJjaGlsZHJlbiIsImpzeCIsInRhcmdldCIsInJlbCIsImhyZWYiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/VersionStalenessInfo.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/index.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/index.js ***!
  \**********************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    styles: function() {\n        return _styles.styles;\n    },\n    VersionStalenessInfo: function() {\n        return _VersionStalenessInfo.VersionStalenessInfo;\n    }\n});\nconst _styles = __webpack_require__(/*! ./styles */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/styles.js\");\nconst _VersionStalenessInfo = __webpack_require__(/*! ./VersionStalenessInfo */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/VersionStalenessInfo.js\");\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9WZXJzaW9uU3RhbGVuZXNzSW5mby9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsUUFBUTtRQUNKLE9BQU9RLFFBQVFSLE1BQU07SUFDekI7SUFDQUMsc0JBQXNCO1FBQ2xCLE9BQU9RLHNCQUFzQlIsb0JBQW9CO0lBQ3JEO0FBQ0o7QUFDQSxNQUFNTyxVQUFVRSxtQkFBT0EsQ0FBQyxxSkFBVTtBQUNsQyxNQUFNRCx3QkFBd0JDLG1CQUFPQSxDQUFDLGlMQUF3QjtBQUU5RCxJQUFJLENBQUMsT0FBT2IsUUFBUWMsT0FBTyxLQUFLLGNBQWUsT0FBT2QsUUFBUWMsT0FBTyxLQUFLLFlBQVlkLFFBQVFjLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2QsUUFBUWMsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2pCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWMsT0FBTyxFQUFFLGNBQWM7UUFBRWIsT0FBTztJQUFLO0lBQ25FSCxPQUFPa0IsTUFBTSxDQUFDaEIsUUFBUWMsT0FBTyxFQUFFZDtJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFRYyxPQUFPO0FBQ2xDLEVBRUEsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9WZXJzaW9uU3RhbGVuZXNzSW5mby9pbmRleC5qcz8xZjNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc3R5bGVzOiBudWxsLFxuICAgIFZlcnNpb25TdGFsZW5lc3NJbmZvOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIHN0eWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc3R5bGVzLnN0eWxlcztcbiAgICB9LFxuICAgIFZlcnNpb25TdGFsZW5lc3NJbmZvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9WZXJzaW9uU3RhbGVuZXNzSW5mby5WZXJzaW9uU3RhbGVuZXNzSW5mbztcbiAgICB9XG59KTtcbmNvbnN0IF9zdHlsZXMgPSByZXF1aXJlKFwiLi9zdHlsZXNcIik7XG5jb25zdCBfVmVyc2lvblN0YWxlbmVzc0luZm8gPSByZXF1aXJlKFwiLi9WZXJzaW9uU3RhbGVuZXNzSW5mb1wiKTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwic3R5bGVzIiwiVmVyc2lvblN0YWxlbmVzc0luZm8iLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfc3R5bGVzIiwiX1ZlcnNpb25TdGFsZW5lc3NJbmZvIiwicmVxdWlyZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/styles.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/styles.js ***!
  \***********************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"styles\", ({\n    enumerable: true,\n    get: function() {\n        return styles;\n    }\n}));\nconst _tagged_template_literal_loose = __webpack_require__(/*! @swc/helpers/_/_tagged_template_literal_loose */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_tagged_template_literal_loose.js\");\nconst _nooptemplate = __webpack_require__(/*! ../../helpers/noop-template */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/noop-template.js\");\nfunction _templateObject() {\n    const data = _tagged_template_literal_loose._([\n        \"\\n  .nextjs-container-build-error-version-status {\\n    flex: 1;\\n    text-align: right;\\n  }\\n  .nextjs-container-build-error-version-status small {\\n    margin-left: var(--size-gap);\\n    font-size: var(--size-font-small);\\n  }\\n  .nextjs-container-build-error-version-status a {\\n    font-size: var(--size-font-small);\\n  }\\n  .nextjs-container-build-error-version-status span {\\n    display: inline-block;\\n    width: 10px;\\n    height: 10px;\\n    border-radius: 5px;\\n    background: var(--color-ansi-bright-black);\\n  }\\n  .nextjs-container-build-error-version-status span.fresh {\\n    background: var(--color-ansi-green);\\n  }\\n  .nextjs-container-build-error-version-status span.stale {\\n    background: var(--color-ansi-yellow);\\n  }\\n  .nextjs-container-build-error-version-status span.outdated {\\n    background: var(--color-ansi-red);\\n  }\\n\"\n    ]);\n    _templateObject = function() {\n        return data;\n    };\n    return data;\n}\nconst styles = (0, _nooptemplate.noop)(_templateObject());\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=styles.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9WZXJzaW9uU3RhbGVuZXNzSW5mby9zdHlsZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDBDQUF5QztJQUNyQ0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLGlDQUFpQ0MsbUJBQU9BLENBQUMsNElBQStDO0FBQzlGLE1BQU1DLGdCQUFnQkQsbUJBQU9BLENBQUMsdUpBQTZCO0FBQzNELFNBQVNFO0lBQ0wsTUFBTUMsT0FBT0osK0JBQStCSyxDQUFDLENBQUM7UUFDMUM7S0FDSDtJQUNERixrQkFBa0I7UUFDZCxPQUFPQztJQUNYO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLE1BQU1MLFNBQVMsQ0FBQyxHQUFHRyxjQUFjSSxJQUFJLEVBQUVIO0FBRXZDLElBQUksQ0FBQyxPQUFPUixRQUFRWSxPQUFPLEtBQUssY0FBZSxPQUFPWixRQUFRWSxPQUFPLEtBQUssWUFBWVosUUFBUVksT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPWixRQUFRWSxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLZixPQUFPQyxjQUFjLENBQUNDLFFBQVFZLE9BQU8sRUFBRSxjQUFjO1FBQUVYLE9BQU87SUFBSztJQUNuRUgsT0FBT2dCLE1BQU0sQ0FBQ2QsUUFBUVksT0FBTyxFQUFFWjtJQUMvQmUsT0FBT2YsT0FBTyxHQUFHQSxRQUFRWSxPQUFPO0FBQ2xDLEVBRUEsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9WZXJzaW9uU3RhbGVuZXNzSW5mby9zdHlsZXMuanM/MThmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0eWxlc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH1cbn0pO1xuY29uc3QgX3RhZ2dlZF90ZW1wbGF0ZV9saXRlcmFsX2xvb3NlID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL190YWdnZWRfdGVtcGxhdGVfbGl0ZXJhbF9sb29zZVwiKTtcbmNvbnN0IF9ub29wdGVtcGxhdGUgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuZnVuY3Rpb24gX3RlbXBsYXRlT2JqZWN0KCkge1xuICAgIGNvbnN0IGRhdGEgPSBfdGFnZ2VkX3RlbXBsYXRlX2xpdGVyYWxfbG9vc2UuXyhbXG4gICAgICAgIFwiXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci12ZXJzaW9uLXN0YXR1cyB7XFxuICAgIGZsZXg6IDE7XFxuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItdmVyc2lvbi1zdGF0dXMgc21hbGwge1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXApO1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci12ZXJzaW9uLXN0YXR1cyBhIHtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItdmVyc2lvbi1zdGF0dXMgc3BhbiB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgd2lkdGg6IDEwcHg7XFxuICAgIGhlaWdodDogMTBweDtcXG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jb2xvci1hbnNpLWJyaWdodC1ibGFjayk7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci12ZXJzaW9uLXN0YXR1cyBzcGFuLmZyZXNoIHtcXG4gICAgYmFja2dyb3VuZDogdmFyKC0tY29sb3ItYW5zaS1ncmVlbik7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci12ZXJzaW9uLXN0YXR1cyBzcGFuLnN0YWxlIHtcXG4gICAgYmFja2dyb3VuZDogdmFyKC0tY29sb3ItYW5zaS15ZWxsb3cpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItdmVyc2lvbi1zdGF0dXMgc3Bhbi5vdXRkYXRlZCB7XFxuICAgIGJhY2tncm91bmQ6IHZhcigtLWNvbG9yLWFuc2ktcmVkKTtcXG4gIH1cXG5cIlxuICAgIF0pO1xuICAgIF90ZW1wbGF0ZU9iamVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIHJldHVybiBkYXRhO1xufVxuY29uc3Qgc3R5bGVzID0gKDAsIF9ub29wdGVtcGxhdGUubm9vcCkoX3RlbXBsYXRlT2JqZWN0KCkpO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsInN0eWxlcyIsIl90YWdnZWRfdGVtcGxhdGVfbGl0ZXJhbF9sb29zZSIsInJlcXVpcmUiLCJfbm9vcHRlbXBsYXRlIiwiX3RlbXBsYXRlT2JqZWN0IiwiZGF0YSIsIl8iLCJub29wIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/VersionStalenessInfo/styles.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/hot-linked-text/get-words-and-whitespaces.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/hot-linked-text/get-words-and-whitespaces.js ***!
  \*************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// Returns true if the given character is a whitespace character, false otherwise.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getWordsAndWhitespaces\", ({\n    enumerable: true,\n    get: function() {\n        return getWordsAndWhitespaces;\n    }\n}));\nfunction isWhitespace(char) {\n    return char === \" \" || char === \"\\n\" || char === \"\t\" || char === \"\\r\";\n}\nfunction getWordsAndWhitespaces(text) {\n    const wordsAndWhitespaces = [];\n    let current = \"\";\n    let currentIsWhitespace = false;\n    for (const char of text){\n        if (current.length === 0) {\n            current += char;\n            currentIsWhitespace = isWhitespace(char);\n            continue;\n        }\n        const nextIsWhitespace = isWhitespace(char);\n        if (currentIsWhitespace === nextIsWhitespace) {\n            current += char;\n        } else {\n            wordsAndWhitespaces.push(current);\n            current = char;\n            currentIsWhitespace = nextIsWhitespace;\n        }\n    }\n    if (current.length > 0) {\n        wordsAndWhitespaces.push(current);\n    }\n    return wordsAndWhitespaces;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-words-and-whitespaces.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9ob3QtbGlua2VkLXRleHQvZ2V0LXdvcmRzLWFuZC13aGl0ZXNwYWNlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrRkFBa0Y7QUFDckU7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDBEQUF5RDtJQUNyREksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLFNBQVNDLGFBQWFDLElBQUk7SUFDdEIsT0FBT0EsU0FBUyxPQUFPQSxTQUFTLFFBQVFBLFNBQVMsT0FBT0EsU0FBUztBQUNyRTtBQUNBLFNBQVNGLHVCQUF1QkcsSUFBSTtJQUNoQyxNQUFNQyxzQkFBc0IsRUFBRTtJQUM5QixJQUFJQyxVQUFVO0lBQ2QsSUFBSUMsc0JBQXNCO0lBQzFCLEtBQUssTUFBTUosUUFBUUMsS0FBSztRQUNwQixJQUFJRSxRQUFRRSxNQUFNLEtBQUssR0FBRztZQUN0QkYsV0FBV0g7WUFDWEksc0JBQXNCTCxhQUFhQztZQUNuQztRQUNKO1FBQ0EsTUFBTU0sbUJBQW1CUCxhQUFhQztRQUN0QyxJQUFJSSx3QkFBd0JFLGtCQUFrQjtZQUMxQ0gsV0FBV0g7UUFDZixPQUFPO1lBQ0hFLG9CQUFvQkssSUFBSSxDQUFDSjtZQUN6QkEsVUFBVUg7WUFDVkksc0JBQXNCRTtRQUMxQjtJQUNKO0lBQ0EsSUFBSUgsUUFBUUUsTUFBTSxHQUFHLEdBQUc7UUFDcEJILG9CQUFvQkssSUFBSSxDQUFDSjtJQUM3QjtJQUNBLE9BQU9EO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT1IsUUFBUWMsT0FBTyxLQUFLLGNBQWUsT0FBT2QsUUFBUWMsT0FBTyxLQUFLLFlBQVlkLFFBQVFjLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2QsUUFBUWMsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2pCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWMsT0FBTyxFQUFFLGNBQWM7UUFBRWIsT0FBTztJQUFLO0lBQ25FSCxPQUFPa0IsTUFBTSxDQUFDaEIsUUFBUWMsT0FBTyxFQUFFZDtJQUMvQmlCLE9BQU9qQixPQUFPLEdBQUdBLFFBQVFjLE9BQU87QUFDbEMsRUFFQSxxREFBcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9pbnRlcm5hbC9jb21wb25lbnRzL2hvdC1saW5rZWQtdGV4dC9nZXQtd29yZHMtYW5kLXdoaXRlc3BhY2VzLmpzPzI0NmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBjaGFyYWN0ZXIgaXMgYSB3aGl0ZXNwYWNlIGNoYXJhY3RlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRXb3Jkc0FuZFdoaXRlc3BhY2VzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRXb3Jkc0FuZFdoaXRlc3BhY2VzO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNoYXIpIHtcbiAgICByZXR1cm4gY2hhciA9PT0gXCIgXCIgfHwgY2hhciA9PT0gXCJcXG5cIiB8fCBjaGFyID09PSBcIlx0XCIgfHwgY2hhciA9PT0gXCJcXHJcIjtcbn1cbmZ1bmN0aW9uIGdldFdvcmRzQW5kV2hpdGVzcGFjZXModGV4dCkge1xuICAgIGNvbnN0IHdvcmRzQW5kV2hpdGVzcGFjZXMgPSBbXTtcbiAgICBsZXQgY3VycmVudCA9IFwiXCI7XG4gICAgbGV0IGN1cnJlbnRJc1doaXRlc3BhY2UgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGNoYXIgb2YgdGV4dCl7XG4gICAgICAgIGlmIChjdXJyZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY3VycmVudCArPSBjaGFyO1xuICAgICAgICAgICAgY3VycmVudElzV2hpdGVzcGFjZSA9IGlzV2hpdGVzcGFjZShjaGFyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRJc1doaXRlc3BhY2UgPSBpc1doaXRlc3BhY2UoY2hhcik7XG4gICAgICAgIGlmIChjdXJyZW50SXNXaGl0ZXNwYWNlID09PSBuZXh0SXNXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICBjdXJyZW50ICs9IGNoYXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3b3Jkc0FuZFdoaXRlc3BhY2VzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICBjdXJyZW50ID0gY2hhcjtcbiAgICAgICAgICAgIGN1cnJlbnRJc1doaXRlc3BhY2UgPSBuZXh0SXNXaGl0ZXNwYWNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgd29yZHNBbmRXaGl0ZXNwYWNlcy5wdXNoKGN1cnJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gd29yZHNBbmRXaGl0ZXNwYWNlcztcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXdvcmRzLWFuZC13aGl0ZXNwYWNlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZ2V0V29yZHNBbmRXaGl0ZXNwYWNlcyIsImlzV2hpdGVzcGFjZSIsImNoYXIiLCJ0ZXh0Iiwid29yZHNBbmRXaGl0ZXNwYWNlcyIsImN1cnJlbnQiLCJjdXJyZW50SXNXaGl0ZXNwYWNlIiwibGVuZ3RoIiwibmV4dElzV2hpdGVzcGFjZSIsInB1c2giLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/hot-linked-text/get-words-and-whitespaces.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/hot-linked-text/index.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/internal/components/hot-linked-text/index.js ***!
  \*****************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"HotlinkedText\", ({\n    enumerable: true,\n    get: function() {\n        return HotlinkedText;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _getwordsandwhitespaces = __webpack_require__(/*! ./get-words-and-whitespaces */ \"(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/hot-linked-text/get-words-and-whitespaces.js\");\nconst linkRegex = /https?:\\/\\/[^\\s/$.?#].[^\\s\"]*/i;\nconst HotlinkedText = function HotlinkedText(props) {\n    const { text } = props;\n    const wordsAndWhitespaces = (0, _getwordsandwhitespaces.getWordsAndWhitespaces)(text);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: linkRegex.test(text) ? wordsAndWhitespaces.map((word, index)=>{\n            if (linkRegex.test(word)) {\n                return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.default.Fragment, {\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n                        href: word,\n                        children: word\n                    })\n                }, \"link-\" + index);\n            }\n            return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.default.Fragment, {\n                children: word\n            }, \"text-\" + index);\n        }) : text\n    });\n};\n_c = HotlinkedText;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\nvar _c;\n$RefreshReg$(_c, \"HotlinkedText\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9ob3QtbGlua2VkLXRleHQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGlEQUFnRDtJQUM1Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsZ0lBQXlDO0FBQ2xGLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLHFHQUFtQjtBQUMvQyxNQUFNRSxTQUFTLFdBQVcsR0FBR0gseUJBQXlCSSxDQUFDLENBQUNILG1CQUFPQSxDQUFDLG1GQUFPO0FBQ3ZFLE1BQU1JLDBCQUEwQkosbUJBQU9BLENBQUMsc0xBQTZCO0FBQ3JFLE1BQU1LLFlBQVk7QUFDbEIsTUFBTVAsZ0JBQWdCLFNBQVNBLGNBQWNRLEtBQUs7SUFDOUMsTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBR0Q7SUFDakIsTUFBTUUsc0JBQXNCLENBQUMsR0FBR0osd0JBQXdCSyxzQkFBc0IsRUFBRUY7SUFDaEYsT0FBcUIsV0FBSCxHQUFJLElBQUdOLFlBQVlTLEdBQUcsRUFBRVQsWUFBWVUsUUFBUSxFQUFFO1FBQzVEQyxVQUFVUCxVQUFVUSxJQUFJLENBQUNOLFFBQVFDLG9CQUFvQk0sR0FBRyxDQUFDLENBQUNDLE1BQU1DO1lBQzVELElBQUlYLFVBQVVRLElBQUksQ0FBQ0UsT0FBTztnQkFDdEIsT0FBcUIsV0FBSCxHQUFJLElBQUdkLFlBQVlTLEdBQUcsRUFBRVIsT0FBT2UsT0FBTyxDQUFDTixRQUFRLEVBQUU7b0JBQy9EQyxVQUF3QixXQUFILEdBQUksSUFBR1gsWUFBWVMsR0FBRyxFQUFFLEtBQUs7d0JBQzlDUSxNQUFNSDt3QkFDTkgsVUFBVUc7b0JBQ2Q7Z0JBQ0osR0FBRyxVQUFVQztZQUNqQjtZQUNBLE9BQXFCLFdBQUgsR0FBSSxJQUFHZixZQUFZUyxHQUFHLEVBQUVSLE9BQU9lLE9BQU8sQ0FBQ04sUUFBUSxFQUFFO2dCQUMvREMsVUFBVUc7WUFDZCxHQUFHLFVBQVVDO1FBQ2pCLEtBQUtUO0lBQ1Q7QUFDSjtLQWxCTVQ7QUFvQk4sSUFBSSxDQUFDLE9BQU9KLFFBQVF1QixPQUFPLEtBQUssY0FBZSxPQUFPdkIsUUFBUXVCLE9BQU8sS0FBSyxZQUFZdkIsUUFBUXVCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT3ZCLFFBQVF1QixPQUFPLENBQUNFLFVBQVUsS0FBSyxhQUFhO0lBQ3JLM0IsT0FBT0MsY0FBYyxDQUFDQyxRQUFRdUIsT0FBTyxFQUFFLGNBQWM7UUFBRXRCLE9BQU87SUFBSztJQUNuRUgsT0FBTzRCLE1BQU0sQ0FBQzFCLFFBQVF1QixPQUFPLEVBQUV2QjtJQUMvQjJCLE9BQU8zQixPQUFPLEdBQUdBLFFBQVF1QixPQUFPO0FBQ2xDLEVBRUEsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvaW50ZXJuYWwvY29tcG9uZW50cy9ob3QtbGlua2VkLXRleHQvaW5kZXguanM/OTVhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkhvdGxpbmtlZFRleHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEhvdGxpbmtlZFRleHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX2pzeHJ1bnRpbWUgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfZ2V0d29yZHNhbmR3aGl0ZXNwYWNlcyA9IHJlcXVpcmUoXCIuL2dldC13b3Jkcy1hbmQtd2hpdGVzcGFjZXNcIik7XG5jb25zdCBsaW5rUmVnZXggPSAvaHR0cHM/OlxcL1xcL1teXFxzLyQuPyNdLlteXFxzXCJdKi9pO1xuY29uc3QgSG90bGlua2VkVGV4dCA9IGZ1bmN0aW9uIEhvdGxpbmtlZFRleHQocHJvcHMpIHtcbiAgICBjb25zdCB7IHRleHQgfSA9IHByb3BzO1xuICAgIGNvbnN0IHdvcmRzQW5kV2hpdGVzcGFjZXMgPSAoMCwgX2dldHdvcmRzYW5kd2hpdGVzcGFjZXMuZ2V0V29yZHNBbmRXaGl0ZXNwYWNlcykodGV4dCk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX2pzeHJ1bnRpbWUuRnJhZ21lbnQsIHtcbiAgICAgICAgY2hpbGRyZW46IGxpbmtSZWdleC50ZXN0KHRleHQpID8gd29yZHNBbmRXaGl0ZXNwYWNlcy5tYXAoKHdvcmQsIGluZGV4KT0+e1xuICAgICAgICAgICAgaWYgKGxpbmtSZWdleC50ZXN0KHdvcmQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJhXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IHdvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogd29yZFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0sIFwibGluay1cIiArIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IHdvcmRcbiAgICAgICAgICAgIH0sIFwidGV4dC1cIiArIGluZGV4KTtcbiAgICAgICAgfSkgOiB0ZXh0XG4gICAgfSk7XG59O1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiSG90bGlua2VkVGV4dCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfanN4cnVudGltZSIsIl9yZWFjdCIsIl8iLCJfZ2V0d29yZHNhbmR3aGl0ZXNwYWNlcyIsImxpbmtSZWdleCIsInByb3BzIiwidGV4dCIsIndvcmRzQW5kV2hpdGVzcGFjZXMiLCJnZXRXb3Jkc0FuZFdoaXRlc3BhY2VzIiwianN4IiwiRnJhZ21lbnQiLCJjaGlsZHJlbiIsInRlc3QiLCJtYXAiLCJ3b3JkIiwiaW5kZXgiLCJkZWZhdWx0IiwiaHJlZiIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/components/hot-linked-text/index.js\n"));

/***/ })

}]);