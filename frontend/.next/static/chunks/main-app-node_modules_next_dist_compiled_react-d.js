"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["main-app-node_modules_next_dist_compiled_react-d"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/client.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/client.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar m = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\nif (false) {} else {\n    var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    exports.createRoot = function(c, o) {\n        i.usingClientEntryPoint = true;\n        try {\n            return m.createRoot(c, o);\n        } finally{\n            i.usingClientEntryPoint = false;\n        }\n    };\n    exports.hydrateRoot = function(c, h, o) {\n        i.usingClientEntryPoint = true;\n        try {\n            return m.hydrateRoot(c, h, o);\n        } finally{\n            i.usingClientEntryPoint = false;\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLElBQUlDLG1CQUFPQSxDQUFDO0FBQ2hCLElBQUlDLEtBQXlCLEVBQWMsRUFHMUMsTUFBTTtJQUNMLElBQUlJLElBQUlOLEVBQUVPLGtEQUFrRDtJQUM1REosa0JBQWtCLEdBQUcsU0FBVUssQ0FBQyxFQUFFQyxDQUFDO1FBQ2pDSCxFQUFFSSxxQkFBcUIsR0FBRztRQUMxQixJQUFJO1lBQ0YsT0FBT1YsRUFBRUksVUFBVSxDQUFDSSxHQUFHQztRQUN6QixTQUFVO1lBQ1JILEVBQUVJLHFCQUFxQixHQUFHO1FBQzVCO0lBQ0Y7SUFDQVAsbUJBQW1CLEdBQUcsU0FBVUssQ0FBQyxFQUFFRyxDQUFDLEVBQUVGLENBQUM7UUFDckNILEVBQUVJLHFCQUFxQixHQUFHO1FBQzFCLElBQUk7WUFDRixPQUFPVixFQUFFSyxXQUFXLENBQUNHLEdBQUdHLEdBQUdGO1FBQzdCLFNBQVU7WUFDUkgsRUFBRUkscUJBQXFCLEdBQUc7UUFDNUI7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL2NsaWVudC5qcz8wY2FjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIG0gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGV4cG9ydHMuY3JlYXRlUm9vdCA9IG0uY3JlYXRlUm9vdDtcbiAgZXhwb3J0cy5oeWRyYXRlUm9vdCA9IG0uaHlkcmF0ZVJvb3Q7XG59IGVsc2Uge1xuICB2YXIgaSA9IG0uX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG4gIGV4cG9ydHMuY3JlYXRlUm9vdCA9IGZ1bmN0aW9uIChjLCBvKSB7XG4gICAgaS51c2luZ0NsaWVudEVudHJ5UG9pbnQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbS5jcmVhdGVSb290KGMsIG8pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpLnVzaW5nQ2xpZW50RW50cnlQb2ludCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgZXhwb3J0cy5oeWRyYXRlUm9vdCA9IGZ1bmN0aW9uIChjLCBoLCBvKSB7XG4gICAgaS51c2luZ0NsaWVudEVudHJ5UG9pbnQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbS5oeWRyYXRlUm9vdChjLCBoLCBvKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaS51c2luZ0NsaWVudEVudHJ5UG9pbnQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG59XG4iXSwibmFtZXMiOlsibSIsInJlcXVpcmUiLCJwcm9jZXNzIiwiZXhwb3J0cyIsImNyZWF0ZVJvb3QiLCJoeWRyYXRlUm9vdCIsImkiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsImMiLCJvIiwidXNpbmdDbGllbnRFbnRyeVBvaW50IiwiaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/client.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-dom/index.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nfunction checkDCE() {\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== \"function\") {\n        return;\n    }\n    if (true) {\n        // This branch is unreachable because this function is only called\n        // in production, but the condition is true only in development.\n        // Therefore if the branch is still here, dead code elimination wasn't\n        // properly applied.\n        // Don't change the message. React DevTools relies on it. Also make sure\n        // this message doesn't occur elsewhere in this function, or it will cause\n        // a false positive.\n        throw new Error(\"^_^\");\n    }\n    try {\n        // Verify that the code above has been dead code eliminated (DCE'd).\n        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n    } catch (err) {\n        // DevTools shouldn't crash React, no matter what.\n        // We should still report in case we break this code.\n        console.error(err);\n    }\n}\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/cjs/react-dom.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtZG9tL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsU0FBU0E7SUFDUCx5Q0FBeUMsR0FDekMsSUFDRSxPQUFPQyxtQ0FBbUMsZUFDMUMsT0FBT0EsK0JBQStCRCxRQUFRLEtBQUssWUFDbkQ7UUFDQTtJQUNGO0lBQ0EsSUFBSUUsSUFBeUIsRUFBYztRQUN6QyxrRUFBa0U7UUFDbEUsZ0VBQWdFO1FBQ2hFLHNFQUFzRTtRQUN0RSxvQkFBb0I7UUFDcEIsd0VBQXdFO1FBQ3hFLDBFQUEwRTtRQUMxRSxvQkFBb0I7UUFDcEIsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBQ0EsSUFBSTtRQUNGLG9FQUFvRTtRQUNwRUYsK0JBQStCRCxRQUFRLENBQUNBO0lBQzFDLEVBQUUsT0FBT0ksS0FBSztRQUNaLGtEQUFrRDtRQUNsRCxxREFBcUQ7UUFDckRDLFFBQVFDLEtBQUssQ0FBQ0Y7SUFDaEI7QUFDRjtBQUVBLElBQUlGLEtBQXlCLEVBQWMsRUFLMUMsTUFBTTtJQUNMSywwS0FBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1kb20vaW5kZXguanM/MDdiMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmIChcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsiY2hlY2tEQ0UiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJwcm9jZXNzIiwiRXJyb3IiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * @license React\n * react-refresh-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        // ATTENTION\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map; // We never remove these associations.\n        // It's OK to reference families, but use WeakMap/Set for types.\n        var allFamiliesByID = new Map();\n        var allFamiliesByType = new PossiblyWeakMap();\n        var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families\n        // that have actually been edited here. This keeps checks fast.\n        // $FlowIssue\n        var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.\n        // It is an array of [Family, NextType] tuples.\n        var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.\n        var helpersByRendererID = new Map();\n        var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.\n        var mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.\n        var failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.\n        // It needs to be weak because we do this even for roots that failed to mount.\n        // If there is no WeakMap, we won't attempt to do retrying.\n        // $FlowIssue\n        var rootElements = typeof WeakMap === \"function\" ? new WeakMap() : null;\n        var isPerformingRefresh = false;\n        function computeFullKey(signature) {\n            if (signature.fullKey !== null) {\n                return signature.fullKey;\n            }\n            var fullKey = signature.ownKey;\n            var hooks;\n            try {\n                hooks = signature.getCustomHooks();\n            } catch (err) {\n                // This can happen in an edge case, e.g. if expression like Foo.useSomething\n                // depends on Foo which is lazily initialized during rendering.\n                // In that case just assume we'll have to remount.\n                signature.forceReset = true;\n                signature.fullKey = fullKey;\n                return fullKey;\n            }\n            for(var i = 0; i < hooks.length; i++){\n                var hook = hooks[i];\n                if (typeof hook !== \"function\") {\n                    // Something's wrong. Assume we need to remount.\n                    signature.forceReset = true;\n                    signature.fullKey = fullKey;\n                    return fullKey;\n                }\n                var nestedHookSignature = allSignaturesByType.get(hook);\n                if (nestedHookSignature === undefined) {\n                    continue;\n                }\n                var nestedHookKey = computeFullKey(nestedHookSignature);\n                if (nestedHookSignature.forceReset) {\n                    signature.forceReset = true;\n                }\n                fullKey += \"\\n---\\n\" + nestedHookKey;\n            }\n            signature.fullKey = fullKey;\n            return fullKey;\n        }\n        function haveEqualSignatures(prevType, nextType) {\n            var prevSignature = allSignaturesByType.get(prevType);\n            var nextSignature = allSignaturesByType.get(nextType);\n            if (prevSignature === undefined && nextSignature === undefined) {\n                return true;\n            }\n            if (prevSignature === undefined || nextSignature === undefined) {\n                return false;\n            }\n            if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\n                return false;\n            }\n            if (nextSignature.forceReset) {\n                return false;\n            }\n            return true;\n        }\n        function isReactClass(type) {\n            return type.prototype && type.prototype.isReactComponent;\n        }\n        function canPreserveStateBetween(prevType, nextType) {\n            if (isReactClass(prevType) || isReactClass(nextType)) {\n                return false;\n            }\n            if (haveEqualSignatures(prevType, nextType)) {\n                return true;\n            }\n            return false;\n        }\n        function resolveFamily(type) {\n            // Only check updated types to keep lookups fast.\n            return updatedFamiliesByType.get(type);\n        } // If we didn't care about IE11, we could use new Map/Set(iterable).\n        function cloneMap(map) {\n            var clone = new Map();\n            map.forEach(function(value, key) {\n                clone.set(key, value);\n            });\n            return clone;\n        }\n        function cloneSet(set) {\n            var clone = new Set();\n            set.forEach(function(value) {\n                clone.add(value);\n            });\n            return clone;\n        } // This is a safety mechanism to protect against rogue getters and Proxies.\n        function getProperty(object, property) {\n            try {\n                return object[property];\n            } catch (err) {\n                // Intentionally ignore.\n                return undefined;\n            }\n        }\n        function performReactRefresh() {\n            if (pendingUpdates.length === 0) {\n                return null;\n            }\n            if (isPerformingRefresh) {\n                return null;\n            }\n            isPerformingRefresh = true;\n            try {\n                var staleFamilies = new Set();\n                var updatedFamilies = new Set();\n                var updates = pendingUpdates;\n                pendingUpdates = [];\n                updates.forEach(function(_ref) {\n                    var family = _ref[0], nextType = _ref[1];\n                    // Now that we got a real edit, we can create associations\n                    // that will be read by the React reconciler.\n                    var prevType = family.current;\n                    updatedFamiliesByType.set(prevType, family);\n                    updatedFamiliesByType.set(nextType, family);\n                    family.current = nextType; // Determine whether this should be a re-render or a re-mount.\n                    if (canPreserveStateBetween(prevType, nextType)) {\n                        updatedFamilies.add(family);\n                    } else {\n                        staleFamilies.add(family);\n                    }\n                }); // TODO: rename these fields to something more meaningful.\n                var update = {\n                    updatedFamilies: updatedFamilies,\n                    // Families that will re-render preserving state\n                    staleFamilies: staleFamilies // Families that will be remounted\n                };\n                helpersByRendererID.forEach(function(helpers) {\n                    // Even if there are no roots, set the handler on first update.\n                    // This ensures that if *new* roots are mounted, they'll use the resolve handler.\n                    helpers.setRefreshHandler(resolveFamily);\n                });\n                var didError = false;\n                var firstError = null; // We snapshot maps and sets that are mutated during commits.\n                // If we don't do this, there is a risk they will be mutated while\n                // we iterate over them. For example, trying to recover a failed root\n                // may cause another root to be added to the failed list -- an infinite loop.\n                var failedRootsSnapshot = cloneSet(failedRoots);\n                var mountedRootsSnapshot = cloneSet(mountedRoots);\n                var helpersByRootSnapshot = cloneMap(helpersByRoot);\n                failedRootsSnapshot.forEach(function(root) {\n                    var helpers = helpersByRootSnapshot.get(root);\n                    if (helpers === undefined) {\n                        throw new Error(\"Could not find helpers for a root. This is a bug in React Refresh.\");\n                    }\n                    if (!failedRoots.has(root)) {}\n                    if (rootElements === null) {\n                        return;\n                    }\n                    if (!rootElements.has(root)) {\n                        return;\n                    }\n                    var element = rootElements.get(root);\n                    try {\n                        helpers.scheduleRoot(root, element);\n                    } catch (err) {\n                        if (!didError) {\n                            didError = true;\n                            firstError = err;\n                        } // Keep trying other roots.\n                    }\n                });\n                mountedRootsSnapshot.forEach(function(root) {\n                    var helpers = helpersByRootSnapshot.get(root);\n                    if (helpers === undefined) {\n                        throw new Error(\"Could not find helpers for a root. This is a bug in React Refresh.\");\n                    }\n                    if (!mountedRoots.has(root)) {}\n                    try {\n                        helpers.scheduleRefresh(root, update);\n                    } catch (err) {\n                        if (!didError) {\n                            didError = true;\n                            firstError = err;\n                        } // Keep trying other roots.\n                    }\n                });\n                if (didError) {\n                    throw firstError;\n                }\n                return update;\n            } finally{\n                isPerformingRefresh = false;\n            }\n        }\n        function register(type, id) {\n            {\n                if (type === null) {\n                    return;\n                }\n                if (typeof type !== \"function\" && typeof type !== \"object\") {\n                    return;\n                } // This can happen in an edge case, e.g. if we register\n                // return value of a HOC but it returns a cached component.\n                // Ignore anything but the first registration for each type.\n                if (allFamiliesByType.has(type)) {\n                    return;\n                } // Create family or remember to update it.\n                // None of this bookkeeping affects reconciliation\n                // until the first performReactRefresh() call above.\n                var family = allFamiliesByID.get(id);\n                if (family === undefined) {\n                    family = {\n                        current: type\n                    };\n                    allFamiliesByID.set(id, family);\n                } else {\n                    pendingUpdates.push([\n                        family,\n                        type\n                    ]);\n                }\n                allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.\n                if (typeof type === \"object\" && type !== null) {\n                    switch(getProperty(type, \"$$typeof\")){\n                        case REACT_FORWARD_REF_TYPE:\n                            register(type.render, id + \"$render\");\n                            break;\n                        case REACT_MEMO_TYPE:\n                            register(type.type, id + \"$type\");\n                            break;\n                    }\n                }\n            }\n        }\n        function setSignature(type, key) {\n            var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n            var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;\n            {\n                if (!allSignaturesByType.has(type)) {\n                    allSignaturesByType.set(type, {\n                        forceReset: forceReset,\n                        ownKey: key,\n                        fullKey: null,\n                        getCustomHooks: getCustomHooks || function() {\n                            return [];\n                        }\n                    });\n                } // Visit inner types because we might not have signed them.\n                if (typeof type === \"object\" && type !== null) {\n                    switch(getProperty(type, \"$$typeof\")){\n                        case REACT_FORWARD_REF_TYPE:\n                            setSignature(type.render, key, forceReset, getCustomHooks);\n                            break;\n                        case REACT_MEMO_TYPE:\n                            setSignature(type.type, key, forceReset, getCustomHooks);\n                            break;\n                    }\n                }\n            }\n        } // This is lazily called during first render for a type.\n        // It captures Hook list at that time so inline requires don't break comparisons.\n        function collectCustomHooksForSignature(type) {\n            {\n                var signature = allSignaturesByType.get(type);\n                if (signature !== undefined) {\n                    computeFullKey(signature);\n                }\n            }\n        }\n        function getFamilyByID(id) {\n            {\n                return allFamiliesByID.get(id);\n            }\n        }\n        function getFamilyByType(type) {\n            {\n                return allFamiliesByType.get(type);\n            }\n        }\n        function findAffectedHostInstances(families) {\n            {\n                var affectedInstances = new Set();\n                mountedRoots.forEach(function(root) {\n                    var helpers = helpersByRoot.get(root);\n                    if (helpers === undefined) {\n                        throw new Error(\"Could not find helpers for a root. This is a bug in React Refresh.\");\n                    }\n                    var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);\n                    instancesForRoot.forEach(function(inst) {\n                        affectedInstances.add(inst);\n                    });\n                });\n                return affectedInstances;\n            }\n        }\n        function injectIntoGlobalHook(globalObject) {\n            {\n                // For React Native, the global hook will be set up by require('react-devtools-core').\n                // That code will run before us. So we need to monkeypatch functions on existing hook.\n                // For React Web, the global hook will be set up by the extension.\n                // This will also run before us.\n                var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n                if (hook === undefined) {\n                    // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.\n                    // Note that in this case it's important that renderer code runs *after* this method call.\n                    // Otherwise, the renderer will think that there is no global hook, and won't do the injection.\n                    var nextID = 0;\n                    globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n                        renderers: new Map(),\n                        supportsFiber: true,\n                        inject: function(injected) {\n                            return nextID++;\n                        },\n                        onScheduleFiberRoot: function(id, root, children) {},\n                        onCommitFiberRoot: function(id, root, maybePriorityLevel, didError) {},\n                        onCommitFiberUnmount: function() {}\n                    };\n                }\n                if (hook.isDisabled) {\n                    // This isn't a real property on the hook, but it can be set to opt out\n                    // of DevTools integration and associated warnings and logs.\n                    // Using console['warn'] to evade Babel and ESLint\n                    console[\"warn\"](\"Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). \" + \"Fast Refresh is not compatible with this shim and will be disabled.\");\n                    return;\n                } // Here, we just want to get a reference to scheduleRefresh.\n                var oldInject = hook.inject;\n                hook.inject = function(injected) {\n                    var id = oldInject.apply(this, arguments);\n                    if (typeof injected.scheduleRefresh === \"function\" && typeof injected.setRefreshHandler === \"function\") {\n                        // This version supports React Refresh.\n                        helpersByRendererID.set(id, injected);\n                    }\n                    return id;\n                }; // Do the same for any already injected roots.\n                // This is useful if ReactDOM has already been initialized.\n                // https://github.com/facebook/react/issues/17626\n                hook.renderers.forEach(function(injected, id) {\n                    if (typeof injected.scheduleRefresh === \"function\" && typeof injected.setRefreshHandler === \"function\") {\n                        // This version supports React Refresh.\n                        helpersByRendererID.set(id, injected);\n                    }\n                }); // We also want to track currently mounted roots.\n                var oldOnCommitFiberRoot = hook.onCommitFiberRoot;\n                var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function() {};\n                hook.onScheduleFiberRoot = function(id, root, children) {\n                    if (!isPerformingRefresh) {\n                        // If it was intentionally scheduled, don't attempt to restore.\n                        // This includes intentionally scheduled unmounts.\n                        failedRoots.delete(root);\n                        if (rootElements !== null) {\n                            rootElements.set(root, children);\n                        }\n                    }\n                    return oldOnScheduleFiberRoot.apply(this, arguments);\n                };\n                hook.onCommitFiberRoot = function(id, root, maybePriorityLevel, didError) {\n                    var helpers = helpersByRendererID.get(id);\n                    if (helpers !== undefined) {\n                        helpersByRoot.set(root, helpers);\n                        var current = root.current;\n                        var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.\n                        // This logic is copy-pasted from similar logic in the DevTools backend.\n                        // If this breaks with some refactoring, you'll want to update DevTools too.\n                        if (alternate !== null) {\n                            var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && mountedRoots.has(root);\n                            var isMounted = current.memoizedState != null && current.memoizedState.element != null;\n                            if (!wasMounted && isMounted) {\n                                // Mount a new root.\n                                mountedRoots.add(root);\n                                failedRoots.delete(root);\n                            } else if (wasMounted && isMounted) ;\n                            else if (wasMounted && !isMounted) {\n                                // Unmount an existing root.\n                                mountedRoots.delete(root);\n                                if (didError) {\n                                    // We'll remount it on future edits.\n                                    failedRoots.add(root);\n                                } else {\n                                    helpersByRoot.delete(root);\n                                }\n                            } else if (!wasMounted && !isMounted) {\n                                if (didError) {\n                                    // We'll remount it on future edits.\n                                    failedRoots.add(root);\n                                }\n                            }\n                        } else {\n                            // Mount a new root.\n                            mountedRoots.add(root);\n                        }\n                    } // Always call the decorated DevTools hook.\n                    return oldOnCommitFiberRoot.apply(this, arguments);\n                };\n            }\n        }\n        function hasUnrecoverableErrors() {\n            // TODO: delete this after removing dependency in RN.\n            return false;\n        } // Exposed for testing.\n        function _getMountedRootCount() {\n            {\n                return mountedRoots.size;\n            }\n        } // This is a wrapper over more primitive functions for setting signature.\n        // Signatures let us decide whether the Hook order has changed on refresh.\n        //\n        // This function is intended to be used as a transform target, e.g.:\n        // var _s = createSignatureFunctionForTransform()\n        //\n        // function Hello() {\n        //   const [foo, setFoo] = useState(0);\n        //   const value = useCustomHook();\n        //   _s(); /* Call without arguments triggers collecting the custom Hook list.\n        //          * This doesn't happen during the module evaluation because we\n        //          * don't want to change the module order with inline requires.\n        //          * Next calls are noops. */\n        //   return <h1>Hi</h1>;\n        // }\n        //\n        // /* Call with arguments attaches the signature to the type: */\n        // _s(\n        //   Hello,\n        //   'useState{[foo, setFoo]}(0)',\n        //   () => [useCustomHook], /* Lazy to avoid triggering inline requires */\n        // );\n        function createSignatureFunctionForTransform() {\n            {\n                var savedType;\n                var hasCustomHooks;\n                var didCollectHooks = false;\n                return function(type, key, forceReset, getCustomHooks) {\n                    if (typeof key === \"string\") {\n                        // We're in the initial phase that associates signatures\n                        // with the functions. Note this may be called multiple times\n                        // in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).\n                        if (!savedType) {\n                            // We're in the innermost call, so this is the actual type.\n                            savedType = type;\n                            hasCustomHooks = typeof getCustomHooks === \"function\";\n                        } // Set the signature for all types (even wrappers!) in case\n                        // they have no signatures of their own. This is to prevent\n                        // problems like https://github.com/facebook/react/issues/20417.\n                        if (type != null && (typeof type === \"function\" || typeof type === \"object\")) {\n                            setSignature(type, key, forceReset, getCustomHooks);\n                        }\n                        return type;\n                    } else {\n                        // We're in the _s() call without arguments, which means\n                        // this is the time to collect custom Hook signatures.\n                        // Only do this once. This path is hot and runs *inside* every render!\n                        if (!didCollectHooks && hasCustomHooks) {\n                            didCollectHooks = true;\n                            collectCustomHooksForSignature(savedType);\n                        }\n                    }\n                };\n            }\n        }\n        function isLikelyComponentType(type) {\n            {\n                switch(typeof type){\n                    case \"function\":\n                        {\n                            // First, deal with classes.\n                            if (type.prototype != null) {\n                                if (type.prototype.isReactComponent) {\n                                    // React class.\n                                    return true;\n                                }\n                                var ownNames = Object.getOwnPropertyNames(type.prototype);\n                                if (ownNames.length > 1 || ownNames[0] !== \"constructor\") {\n                                    // This looks like a class.\n                                    return false;\n                                } // eslint-disable-next-line no-proto\n                                if (type.prototype.__proto__ !== Object.prototype) {\n                                    // It has a superclass.\n                                    return false;\n                                } // Pass through.\n                            // This looks like a regular function with empty prototype.\n                            } // For plain functions and arrows, use name as a heuristic.\n                            var name = type.name || type.displayName;\n                            return typeof name === \"string\" && /^[A-Z]/.test(name);\n                        }\n                    case \"object\":\n                        {\n                            if (type != null) {\n                                switch(getProperty(type, \"$$typeof\")){\n                                    case REACT_FORWARD_REF_TYPE:\n                                    case REACT_MEMO_TYPE:\n                                        // Definitely React components.\n                                        return true;\n                                    default:\n                                        return false;\n                                }\n                            }\n                            return false;\n                        }\n                    default:\n                        {\n                            return false;\n                        }\n                }\n            }\n        }\n        exports._getMountedRootCount = _getMountedRootCount;\n        exports.collectCustomHooksForSignature = collectCustomHooksForSignature;\n        exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;\n        exports.findAffectedHostInstances = findAffectedHostInstances;\n        exports.getFamilyByID = getFamilyByID;\n        exports.getFamilyByType = getFamilyByType;\n        exports.hasUnrecoverableErrors = hasUnrecoverableErrors;\n        exports.injectIntoGlobalHook = injectIntoGlobalHook;\n        exports.isLikelyComponentType = isLikelyComponentType;\n        exports.performReactRefresh = performReactRefresh;\n        exports.register = register;\n        exports.setSignature = setSignature;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtcmVmcmVzaC9janMvcmVhY3QtcmVmcmVzaC1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDLEdBRUQ7QUFFQSxJQUFJQSxJQUFxQyxFQUFFO0lBQ3hDO1FBQ0g7UUFFQSxZQUFZO1FBQ1osSUFBSUMseUJBQXlCQyxPQUFPQyxHQUFHLENBQUM7UUFDeEMsSUFBSUMsa0JBQWtCRixPQUFPQyxHQUFHLENBQUM7UUFFakMsSUFBSUUsa0JBQWtCLE9BQU9DLFlBQVksYUFBYUEsVUFBVUMsS0FBSyxzQ0FBc0M7UUFDM0csZ0VBQWdFO1FBRWhFLElBQUlDLGtCQUFrQixJQUFJRDtRQUMxQixJQUFJRSxvQkFBb0IsSUFBSUo7UUFDNUIsSUFBSUssc0JBQXNCLElBQUlMLG1CQUFtQix5REFBeUQ7UUFDMUcsK0RBQStEO1FBQy9ELGFBQWE7UUFFYixJQUFJTSx3QkFBd0IsSUFBSU4sbUJBQW1CLHVEQUF1RDtRQUMxRywrQ0FBK0M7UUFFL0MsSUFBSU8saUJBQWlCLEVBQUUsRUFBRSw2REFBNkQ7UUFFdEYsSUFBSUMsc0JBQXNCLElBQUlOO1FBQzlCLElBQUlPLGdCQUFnQixJQUFJUCxPQUFPLDZEQUE2RDtRQUU1RixJQUFJUSxlQUFlLElBQUlDLE9BQU8sdUVBQXVFO1FBRXJHLElBQUlDLGNBQWMsSUFBSUQsT0FBTywwRkFBMEY7UUFDdkgsOEVBQThFO1FBQzlFLDJEQUEyRDtRQUMzRCxhQUFhO1FBRWIsSUFBSUUsZUFDSixPQUFPWixZQUFZLGFBQWEsSUFBSUEsWUFBWTtRQUNoRCxJQUFJYSxzQkFBc0I7UUFFMUIsU0FBU0MsZUFBZUMsU0FBUztZQUMvQixJQUFJQSxVQUFVQyxPQUFPLEtBQUssTUFBTTtnQkFDOUIsT0FBT0QsVUFBVUMsT0FBTztZQUMxQjtZQUVBLElBQUlBLFVBQVVELFVBQVVFLE1BQU07WUFDOUIsSUFB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UjtRQUNoQ1EsMkJBQTJCLEdBQUczRTtRQUM5QjJFLGdCQUFnQixHQUFHdEQ7UUFDbkJzRCxvQkFBb0IsR0FBR2xEO0lBQ3JCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1yZWZyZXNoL2Nqcy9yZWFjdC1yZWZyZXNoLXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/N2U4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1yZWZyZXNoLXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBBVFRFTlRJT05cbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG5cbnZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7IC8vIFdlIG5ldmVyIHJlbW92ZSB0aGVzZSBhc3NvY2lhdGlvbnMuXG4vLyBJdCdzIE9LIHRvIHJlZmVyZW5jZSBmYW1pbGllcywgYnV0IHVzZSBXZWFrTWFwL1NldCBmb3IgdHlwZXMuXG5cbnZhciBhbGxGYW1pbGllc0J5SUQgPSBuZXcgTWFwKCk7XG52YXIgYWxsRmFtaWxpZXNCeVR5cGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG52YXIgYWxsU2lnbmF0dXJlc0J5VHlwZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTsgLy8gVGhpcyBXZWFrTWFwIGlzIHJlYWQgYnkgUmVhY3QsIHNvIHdlIG9ubHkgcHV0IGZhbWlsaWVzXG4vLyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBlZGl0ZWQgaGVyZS4gVGhpcyBrZWVwcyBjaGVja3MgZmFzdC5cbi8vICRGbG93SXNzdWVcblxudmFyIHVwZGF0ZWRGYW1pbGllc0J5VHlwZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTsgLy8gVGhpcyBpcyBjbGVhcmVkIG9uIGV2ZXJ5IHBlcmZvcm1SZWFjdFJlZnJlc2goKSBjYWxsLlxuLy8gSXQgaXMgYW4gYXJyYXkgb2YgW0ZhbWlseSwgTmV4dFR5cGVdIHR1cGxlcy5cblxudmFyIHBlbmRpbmdVcGRhdGVzID0gW107IC8vIFRoaXMgaXMgaW5qZWN0ZWQgYnkgdGhlIHJlbmRlcmVyIHZpYSBEZXZUb29scyBnbG9iYWwgaG9vay5cblxudmFyIGhlbHBlcnNCeVJlbmRlcmVySUQgPSBuZXcgTWFwKCk7XG52YXIgaGVscGVyc0J5Um9vdCA9IG5ldyBNYXAoKTsgLy8gV2Uga2VlcCB0cmFjayBvZiBtb3VudGVkIHJvb3RzIHNvIHdlIGNhbiBzY2hlZHVsZSB1cGRhdGVzLlxuXG52YXIgbW91bnRlZFJvb3RzID0gbmV3IFNldCgpOyAvLyBJZiBhIHJvb3QgY2FwdHVyZXMgYW4gZXJyb3IsIHdlIHJlbWVtYmVyIGl0IHNvIHdlIGNhbiByZXRyeSBvbiBlZGl0LlxuXG52YXIgZmFpbGVkUm9vdHMgPSBuZXcgU2V0KCk7IC8vIEluIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgV2Vha01hcCwgd2UgYWxzbyByZW1lbWJlciB0aGUgbGFzdCBlbGVtZW50IGZvciBldmVyeSByb290LlxuLy8gSXQgbmVlZHMgdG8gYmUgd2VhayBiZWNhdXNlIHdlIGRvIHRoaXMgZXZlbiBmb3Igcm9vdHMgdGhhdCBmYWlsZWQgdG8gbW91bnQuXG4vLyBJZiB0aGVyZSBpcyBubyBXZWFrTWFwLCB3ZSB3b24ndCBhdHRlbXB0IHRvIGRvIHJldHJ5aW5nLlxuLy8gJEZsb3dJc3N1ZVxuXG52YXIgcm9vdEVsZW1lbnRzID0gLy8gJEZsb3dJc3N1ZVxudHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBuZXcgV2Vha01hcCgpIDogbnVsbDtcbnZhciBpc1BlcmZvcm1pbmdSZWZyZXNoID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNvbXB1dGVGdWxsS2V5KHNpZ25hdHVyZSkge1xuICBpZiAoc2lnbmF0dXJlLmZ1bGxLZXkgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc2lnbmF0dXJlLmZ1bGxLZXk7XG4gIH1cblxuICB2YXIgZnVsbEtleSA9IHNpZ25hdHVyZS5vd25LZXk7XG4gIHZhciBob29rcztcblxuICB0cnkge1xuICAgIGhvb2tzID0gc2lnbmF0dXJlLmdldEN1c3RvbUhvb2tzKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpbiBhbiBlZGdlIGNhc2UsIGUuZy4gaWYgZXhwcmVzc2lvbiBsaWtlIEZvby51c2VTb21ldGhpbmdcbiAgICAvLyBkZXBlbmRzIG9uIEZvbyB3aGljaCBpcyBsYXppbHkgaW5pdGlhbGl6ZWQgZHVyaW5nIHJlbmRlcmluZy5cbiAgICAvLyBJbiB0aGF0IGNhc2UganVzdCBhc3N1bWUgd2UnbGwgaGF2ZSB0byByZW1vdW50LlxuICAgIHNpZ25hdHVyZS5mb3JjZVJlc2V0ID0gdHJ1ZTtcbiAgICBzaWduYXR1cmUuZnVsbEtleSA9IGZ1bGxLZXk7XG4gICAgcmV0dXJuIGZ1bGxLZXk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGhvb2sgPSBob29rc1tpXTtcblxuICAgIGlmICh0eXBlb2YgaG9vayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gU29tZXRoaW5nJ3Mgd3JvbmcuIEFzc3VtZSB3ZSBuZWVkIHRvIHJlbW91bnQuXG4gICAgICBzaWduYXR1cmUuZm9yY2VSZXNldCA9IHRydWU7XG4gICAgICBzaWduYXR1cmUuZnVsbEtleSA9IGZ1bGxLZXk7XG4gICAgICByZXR1cm4gZnVsbEtleTtcbiAgICB9XG5cbiAgICB2YXIgbmVzdGVkSG9va1NpZ25hdHVyZSA9IGFsbFNpZ25hdHVyZXNCeVR5cGUuZ2V0KGhvb2spO1xuXG4gICAgaWYgKG5lc3RlZEhvb2tTaWduYXR1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gTm8gc2lnbmF0dXJlIG1lYW5zIEhvb2sgd2Fzbid0IGluIHRoZSBzb3VyY2UgY29kZSwgZS5nLiBpbiBhIGxpYnJhcnkuXG4gICAgICAvLyBXZSdsbCBza2lwIGl0IGJlY2F1c2Ugd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBjaGFuZ2UgZHVyaW5nIHRoaXMgc2Vzc2lvbi5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBuZXN0ZWRIb29rS2V5ID0gY29tcHV0ZUZ1bGxLZXkobmVzdGVkSG9va1NpZ25hdHVyZSk7XG5cbiAgICBpZiAobmVzdGVkSG9va1NpZ25hdHVyZS5mb3JjZVJlc2V0KSB7XG4gICAgICBzaWduYXR1cmUuZm9yY2VSZXNldCA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVsbEtleSArPSAnXFxuLS0tXFxuJyArIG5lc3RlZEhvb2tLZXk7XG4gIH1cblxuICBzaWduYXR1cmUuZnVsbEtleSA9IGZ1bGxLZXk7XG4gIHJldHVybiBmdWxsS2V5O1xufVxuXG5mdW5jdGlvbiBoYXZlRXF1YWxTaWduYXR1cmVzKHByZXZUeXBlLCBuZXh0VHlwZSkge1xuICB2YXIgcHJldlNpZ25hdHVyZSA9IGFsbFNpZ25hdHVyZXNCeVR5cGUuZ2V0KHByZXZUeXBlKTtcbiAgdmFyIG5leHRTaWduYXR1cmUgPSBhbGxTaWduYXR1cmVzQnlUeXBlLmdldChuZXh0VHlwZSk7XG5cbiAgaWYgKHByZXZTaWduYXR1cmUgPT09IHVuZGVmaW5lZCAmJiBuZXh0U2lnbmF0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcmV2U2lnbmF0dXJlID09PSB1bmRlZmluZWQgfHwgbmV4dFNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGNvbXB1dGVGdWxsS2V5KHByZXZTaWduYXR1cmUpICE9PSBjb21wdXRlRnVsbEtleShuZXh0U2lnbmF0dXJlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChuZXh0U2lnbmF0dXJlLmZvcmNlUmVzZXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNSZWFjdENsYXNzKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7XG59XG5cbmZ1bmN0aW9uIGNhblByZXNlcnZlU3RhdGVCZXR3ZWVuKHByZXZUeXBlLCBuZXh0VHlwZSkge1xuICBpZiAoaXNSZWFjdENsYXNzKHByZXZUeXBlKSB8fCBpc1JlYWN0Q2xhc3MobmV4dFR5cGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGhhdmVFcXVhbFNpZ25hdHVyZXMocHJldlR5cGUsIG5leHRUeXBlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRmFtaWx5KHR5cGUpIHtcbiAgLy8gT25seSBjaGVjayB1cGRhdGVkIHR5cGVzIHRvIGtlZXAgbG9va3VwcyBmYXN0LlxuICByZXR1cm4gdXBkYXRlZEZhbWlsaWVzQnlUeXBlLmdldCh0eXBlKTtcbn0gLy8gSWYgd2UgZGlkbid0IGNhcmUgYWJvdXQgSUUxMSwgd2UgY291bGQgdXNlIG5ldyBNYXAvU2V0KGl0ZXJhYmxlKS5cblxuXG5mdW5jdGlvbiBjbG9uZU1hcChtYXApIHtcbiAgdmFyIGNsb25lID0gbmV3IE1hcCgpO1xuICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIGNsb25lLnNldChrZXksIHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBjbG9uZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVTZXQoc2V0KSB7XG4gIHZhciBjbG9uZSA9IG5ldyBTZXQoKTtcbiAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgY2xvbmUuYWRkKHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBjbG9uZTtcbn0gLy8gVGhpcyBpcyBhIHNhZmV0eSBtZWNoYW5pc20gdG8gcHJvdGVjdCBhZ2FpbnN0IHJvZ3VlIGdldHRlcnMgYW5kIFByb3hpZXMuXG5cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB0cnkge1xuICAgIHJldHVybiBvYmplY3RbcHJvcGVydHldO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJbnRlbnRpb25hbGx5IGlnbm9yZS5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1SZWFjdFJlZnJlc2goKSB7XG5cbiAgaWYgKHBlbmRpbmdVcGRhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGlzUGVyZm9ybWluZ1JlZnJlc2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlzUGVyZm9ybWluZ1JlZnJlc2ggPSB0cnVlO1xuXG4gIHRyeSB7XG4gICAgdmFyIHN0YWxlRmFtaWxpZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHVwZGF0ZWRGYW1pbGllcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgdXBkYXRlcyA9IHBlbmRpbmdVcGRhdGVzO1xuICAgIHBlbmRpbmdVcGRhdGVzID0gW107XG4gICAgdXBkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgZmFtaWx5ID0gX3JlZlswXSxcbiAgICAgICAgICBuZXh0VHlwZSA9IF9yZWZbMV07XG4gICAgICAvLyBOb3cgdGhhdCB3ZSBnb3QgYSByZWFsIGVkaXQsIHdlIGNhbiBjcmVhdGUgYXNzb2NpYXRpb25zXG4gICAgICAvLyB0aGF0IHdpbGwgYmUgcmVhZCBieSB0aGUgUmVhY3QgcmVjb25jaWxlci5cbiAgICAgIHZhciBwcmV2VHlwZSA9IGZhbWlseS5jdXJyZW50O1xuICAgICAgdXBkYXRlZEZhbWlsaWVzQnlUeXBlLnNldChwcmV2VHlwZSwgZmFtaWx5KTtcbiAgICAgIHVwZGF0ZWRGYW1pbGllc0J5VHlwZS5zZXQobmV4dFR5cGUsIGZhbWlseSk7XG4gICAgICBmYW1pbHkuY3VycmVudCA9IG5leHRUeXBlOyAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGlzIHNob3VsZCBiZSBhIHJlLXJlbmRlciBvciBhIHJlLW1vdW50LlxuXG4gICAgICBpZiAoY2FuUHJlc2VydmVTdGF0ZUJldHdlZW4ocHJldlR5cGUsIG5leHRUeXBlKSkge1xuICAgICAgICB1cGRhdGVkRmFtaWxpZXMuYWRkKGZhbWlseSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFsZUZhbWlsaWVzLmFkZChmYW1pbHkpO1xuICAgICAgfVxuICAgIH0pOyAvLyBUT0RPOiByZW5hbWUgdGhlc2UgZmllbGRzIHRvIHNvbWV0aGluZyBtb3JlIG1lYW5pbmdmdWwuXG5cbiAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgdXBkYXRlZEZhbWlsaWVzOiB1cGRhdGVkRmFtaWxpZXMsXG4gICAgICAvLyBGYW1pbGllcyB0aGF0IHdpbGwgcmUtcmVuZGVyIHByZXNlcnZpbmcgc3RhdGVcbiAgICAgIHN0YWxlRmFtaWxpZXM6IHN0YWxlRmFtaWxpZXMgLy8gRmFtaWxpZXMgdGhhdCB3aWxsIGJlIHJlbW91bnRlZFxuXG4gICAgfTtcbiAgICBoZWxwZXJzQnlSZW5kZXJlcklELmZvckVhY2goZnVuY3Rpb24gKGhlbHBlcnMpIHtcbiAgICAgIC8vIEV2ZW4gaWYgdGhlcmUgYXJlIG5vIHJvb3RzLCBzZXQgdGhlIGhhbmRsZXIgb24gZmlyc3QgdXBkYXRlLlxuICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgaWYgKm5ldyogcm9vdHMgYXJlIG1vdW50ZWQsIHRoZXknbGwgdXNlIHRoZSByZXNvbHZlIGhhbmRsZXIuXG4gICAgICBoZWxwZXJzLnNldFJlZnJlc2hIYW5kbGVyKHJlc29sdmVGYW1pbHkpO1xuICAgIH0pO1xuICAgIHZhciBkaWRFcnJvciA9IGZhbHNlO1xuICAgIHZhciBmaXJzdEVycm9yID0gbnVsbDsgLy8gV2Ugc25hcHNob3QgbWFwcyBhbmQgc2V0cyB0aGF0IGFyZSBtdXRhdGVkIGR1cmluZyBjb21taXRzLlxuICAgIC8vIElmIHdlIGRvbid0IGRvIHRoaXMsIHRoZXJlIGlzIGEgcmlzayB0aGV5IHdpbGwgYmUgbXV0YXRlZCB3aGlsZVxuICAgIC8vIHdlIGl0ZXJhdGUgb3ZlciB0aGVtLiBGb3IgZXhhbXBsZSwgdHJ5aW5nIHRvIHJlY292ZXIgYSBmYWlsZWQgcm9vdFxuICAgIC8vIG1heSBjYXVzZSBhbm90aGVyIHJvb3QgdG8gYmUgYWRkZWQgdG8gdGhlIGZhaWxlZCBsaXN0IC0tIGFuIGluZmluaXRlIGxvb3AuXG5cbiAgICB2YXIgZmFpbGVkUm9vdHNTbmFwc2hvdCA9IGNsb25lU2V0KGZhaWxlZFJvb3RzKTtcbiAgICB2YXIgbW91bnRlZFJvb3RzU25hcHNob3QgPSBjbG9uZVNldChtb3VudGVkUm9vdHMpO1xuICAgIHZhciBoZWxwZXJzQnlSb290U25hcHNob3QgPSBjbG9uZU1hcChoZWxwZXJzQnlSb290KTtcbiAgICBmYWlsZWRSb290c1NuYXBzaG90LmZvckVhY2goZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIHZhciBoZWxwZXJzID0gaGVscGVyc0J5Um9vdFNuYXBzaG90LmdldChyb290KTtcblxuICAgICAgaWYgKGhlbHBlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGhlbHBlcnMgZm9yIGEgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCBSZWZyZXNoLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZhaWxlZFJvb3RzLmhhcyhyb290KSkgey8vIE5vIGxvbmdlciBmYWlsZWQuXG4gICAgICB9XG5cbiAgICAgIGlmIChyb290RWxlbWVudHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJvb3RFbGVtZW50cy5oYXMocm9vdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IHJvb3RFbGVtZW50cy5nZXQocm9vdCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGhlbHBlcnMuc2NoZWR1bGVSb290KHJvb3QsIGVsZW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghZGlkRXJyb3IpIHtcbiAgICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgZmlyc3RFcnJvciA9IGVycjtcbiAgICAgICAgfSAvLyBLZWVwIHRyeWluZyBvdGhlciByb290cy5cblxuICAgICAgfVxuICAgIH0pO1xuICAgIG1vdW50ZWRSb290c1NuYXBzaG90LmZvckVhY2goZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIHZhciBoZWxwZXJzID0gaGVscGVyc0J5Um9vdFNuYXBzaG90LmdldChyb290KTtcblxuICAgICAgaWYgKGhlbHBlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGhlbHBlcnMgZm9yIGEgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCBSZWZyZXNoLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW1vdW50ZWRSb290cy5oYXMocm9vdCkpIHsvLyBObyBsb25nZXIgbW91bnRlZC5cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgaGVscGVycy5zY2hlZHVsZVJlZnJlc2gocm9vdCwgdXBkYXRlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIWRpZEVycm9yKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGZpcnN0RXJyb3IgPSBlcnI7XG4gICAgICAgIH0gLy8gS2VlcCB0cnlpbmcgb3RoZXIgcm9vdHMuXG5cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgdGhyb3cgZmlyc3RFcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlO1xuICB9IGZpbmFsbHkge1xuICAgIGlzUGVyZm9ybWluZ1JlZnJlc2ggPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXIodHlwZSwgaWQpIHtcbiAge1xuICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVGhpcyBjYW4gaGFwcGVuIGluIGFuIGVkZ2UgY2FzZSwgZS5nLiBpZiB3ZSByZWdpc3RlclxuICAgIC8vIHJldHVybiB2YWx1ZSBvZiBhIEhPQyBidXQgaXQgcmV0dXJucyBhIGNhY2hlZCBjb21wb25lbnQuXG4gICAgLy8gSWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3QgcmVnaXN0cmF0aW9uIGZvciBlYWNoIHR5cGUuXG5cblxuICAgIGlmIChhbGxGYW1pbGllc0J5VHlwZS5oYXModHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENyZWF0ZSBmYW1pbHkgb3IgcmVtZW1iZXIgdG8gdXBkYXRlIGl0LlxuICAgIC8vIE5vbmUgb2YgdGhpcyBib29ra2VlcGluZyBhZmZlY3RzIHJlY29uY2lsaWF0aW9uXG4gICAgLy8gdW50aWwgdGhlIGZpcnN0IHBlcmZvcm1SZWFjdFJlZnJlc2goKSBjYWxsIGFib3ZlLlxuXG5cbiAgICB2YXIgZmFtaWx5ID0gYWxsRmFtaWxpZXNCeUlELmdldChpZCk7XG5cbiAgICBpZiAoZmFtaWx5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZhbWlseSA9IHtcbiAgICAgICAgY3VycmVudDogdHlwZVxuICAgICAgfTtcbiAgICAgIGFsbEZhbWlsaWVzQnlJRC5zZXQoaWQsIGZhbWlseSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdVcGRhdGVzLnB1c2goW2ZhbWlseSwgdHlwZV0pO1xuICAgIH1cblxuICAgIGFsbEZhbWlsaWVzQnlUeXBlLnNldCh0eXBlLCBmYW1pbHkpOyAvLyBWaXNpdCBpbm5lciB0eXBlcyBiZWNhdXNlIHdlIG1pZ2h0IG5vdCBoYXZlIHJlZ2lzdGVyZWQgdGhlbS5cblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChnZXRQcm9wZXJ0eSh0eXBlLCAnJCR0eXBlb2YnKSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgcmVnaXN0ZXIodHlwZS5yZW5kZXIsIGlkICsgJyRyZW5kZXInKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICByZWdpc3Rlcih0eXBlLnR5cGUsIGlkICsgJyR0eXBlJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRTaWduYXR1cmUodHlwZSwga2V5KSB7XG4gIHZhciBmb3JjZVJlc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgdmFyIGdldEN1c3RvbUhvb2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG5cbiAge1xuICAgIGlmICghYWxsU2lnbmF0dXJlc0J5VHlwZS5oYXModHlwZSkpIHtcbiAgICAgIGFsbFNpZ25hdHVyZXNCeVR5cGUuc2V0KHR5cGUsIHtcbiAgICAgICAgZm9yY2VSZXNldDogZm9yY2VSZXNldCxcbiAgICAgICAgb3duS2V5OiBrZXksXG4gICAgICAgIGZ1bGxLZXk6IG51bGwsXG4gICAgICAgIGdldEN1c3RvbUhvb2tzOiBnZXRDdXN0b21Ib29rcyB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IC8vIFZpc2l0IGlubmVyIHR5cGVzIGJlY2F1c2Ugd2UgbWlnaHQgbm90IGhhdmUgc2lnbmVkIHRoZW0uXG5cblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChnZXRQcm9wZXJ0eSh0eXBlLCAnJCR0eXBlb2YnKSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgc2V0U2lnbmF0dXJlKHR5cGUucmVuZGVyLCBrZXksIGZvcmNlUmVzZXQsIGdldEN1c3RvbUhvb2tzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICBzZXRTaWduYXR1cmUodHlwZS50eXBlLCBrZXksIGZvcmNlUmVzZXQsIGdldEN1c3RvbUhvb2tzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gLy8gVGhpcyBpcyBsYXppbHkgY2FsbGVkIGR1cmluZyBmaXJzdCByZW5kZXIgZm9yIGEgdHlwZS5cbi8vIEl0IGNhcHR1cmVzIEhvb2sgbGlzdCBhdCB0aGF0IHRpbWUgc28gaW5saW5lIHJlcXVpcmVzIGRvbid0IGJyZWFrIGNvbXBhcmlzb25zLlxuXG5mdW5jdGlvbiBjb2xsZWN0Q3VzdG9tSG9va3NGb3JTaWduYXR1cmUodHlwZSkge1xuICB7XG4gICAgdmFyIHNpZ25hdHVyZSA9IGFsbFNpZ25hdHVyZXNCeVR5cGUuZ2V0KHR5cGUpO1xuXG4gICAgaWYgKHNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb21wdXRlRnVsbEtleShzaWduYXR1cmUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0RmFtaWx5QnlJRChpZCkge1xuICB7XG4gICAgcmV0dXJuIGFsbEZhbWlsaWVzQnlJRC5nZXQoaWQpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRGYW1pbHlCeVR5cGUodHlwZSkge1xuICB7XG4gICAgcmV0dXJuIGFsbEZhbWlsaWVzQnlUeXBlLmdldCh0eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gZmluZEFmZmVjdGVkSG9zdEluc3RhbmNlcyhmYW1pbGllcykge1xuICB7XG4gICAgdmFyIGFmZmVjdGVkSW5zdGFuY2VzID0gbmV3IFNldCgpO1xuICAgIG1vdW50ZWRSb290cy5mb3JFYWNoKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICB2YXIgaGVscGVycyA9IGhlbHBlcnNCeVJvb3QuZ2V0KHJvb3QpO1xuXG4gICAgICBpZiAoaGVscGVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgaGVscGVycyBmb3IgYSByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0IFJlZnJlc2guJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnN0YW5jZXNGb3JSb290ID0gaGVscGVycy5maW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2gocm9vdCwgZmFtaWxpZXMpO1xuICAgICAgaW5zdGFuY2VzRm9yUm9vdC5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzLmFkZChpbnN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBhZmZlY3RlZEluc3RhbmNlcztcbiAgfVxufVxuZnVuY3Rpb24gaW5qZWN0SW50b0dsb2JhbEhvb2soZ2xvYmFsT2JqZWN0KSB7XG4gIHtcbiAgICAvLyBGb3IgUmVhY3QgTmF0aXZlLCB0aGUgZ2xvYmFsIGhvb2sgd2lsbCBiZSBzZXQgdXAgYnkgcmVxdWlyZSgncmVhY3QtZGV2dG9vbHMtY29yZScpLlxuICAgIC8vIFRoYXQgY29kZSB3aWxsIHJ1biBiZWZvcmUgdXMuIFNvIHdlIG5lZWQgdG8gbW9ua2V5cGF0Y2ggZnVuY3Rpb25zIG9uIGV4aXN0aW5nIGhvb2suXG4gICAgLy8gRm9yIFJlYWN0IFdlYiwgdGhlIGdsb2JhbCBob29rIHdpbGwgYmUgc2V0IHVwIGJ5IHRoZSBleHRlbnNpb24uXG4gICAgLy8gVGhpcyB3aWxsIGFsc28gcnVuIGJlZm9yZSB1cy5cbiAgICB2YXIgaG9vayA9IGdsb2JhbE9iamVjdC5fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgICBpZiAoaG9vayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBIb3dldmVyLCBpZiB0aGVyZSBpcyBubyBEZXZUb29scyBleHRlbnNpb24sIHdlJ2xsIG5lZWQgdG8gc2V0IHVwIHRoZSBnbG9iYWwgaG9vayBvdXJzZWx2ZXMuXG4gICAgICAvLyBOb3RlIHRoYXQgaW4gdGhpcyBjYXNlIGl0J3MgaW1wb3J0YW50IHRoYXQgcmVuZGVyZXIgY29kZSBydW5zICphZnRlciogdGhpcyBtZXRob2QgY2FsbC5cbiAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHJlbmRlcmVyIHdpbGwgdGhpbmsgdGhhdCB0aGVyZSBpcyBubyBnbG9iYWwgaG9vaywgYW5kIHdvbid0IGRvIHRoZSBpbmplY3Rpb24uXG4gICAgICB2YXIgbmV4dElEID0gMDtcbiAgICAgIGdsb2JhbE9iamVjdC5fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPSBob29rID0ge1xuICAgICAgICByZW5kZXJlcnM6IG5ldyBNYXAoKSxcbiAgICAgICAgc3VwcG9ydHNGaWJlcjogdHJ1ZSxcbiAgICAgICAgaW5qZWN0OiBmdW5jdGlvbiAoaW5qZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dElEKys7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU2NoZWR1bGVGaWJlclJvb3Q6IGZ1bmN0aW9uIChpZCwgcm9vdCwgY2hpbGRyZW4pIHt9LFxuICAgICAgICBvbkNvbW1pdEZpYmVyUm9vdDogZnVuY3Rpb24gKGlkLCByb290LCBtYXliZVByaW9yaXR5TGV2ZWwsIGRpZEVycm9yKSB7fSxcbiAgICAgICAgb25Db21taXRGaWJlclVubW91bnQ6IGZ1bmN0aW9uICgpIHt9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChob29rLmlzRGlzYWJsZWQpIHtcbiAgICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgICAvLyBvZiBEZXZUb29scyBpbnRlZ3JhdGlvbiBhbmQgYXNzb2NpYXRlZCB3YXJuaW5ncyBhbmQgbG9ncy5cbiAgICAgIC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1NvbWV0aGluZyBoYXMgc2hpbW1lZCB0aGUgUmVhY3QgRGV2VG9vbHMgZ2xvYmFsIGhvb2sgKF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXykuICcgKyAnRmFzdCBSZWZyZXNoIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhpcyBzaGltIGFuZCB3aWxsIGJlIGRpc2FibGVkLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSGVyZSwgd2UganVzdCB3YW50IHRvIGdldCBhIHJlZmVyZW5jZSB0byBzY2hlZHVsZVJlZnJlc2guXG5cblxuICAgIHZhciBvbGRJbmplY3QgPSBob29rLmluamVjdDtcblxuICAgIGhvb2suaW5qZWN0ID0gZnVuY3Rpb24gKGluamVjdGVkKSB7XG4gICAgICB2YXIgaWQgPSBvbGRJbmplY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgaWYgKHR5cGVvZiBpbmplY3RlZC5zY2hlZHVsZVJlZnJlc2ggPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluamVjdGVkLnNldFJlZnJlc2hIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRoaXMgdmVyc2lvbiBzdXBwb3J0cyBSZWFjdCBSZWZyZXNoLlxuICAgICAgICBoZWxwZXJzQnlSZW5kZXJlcklELnNldChpZCwgaW5qZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaWQ7XG4gICAgfTsgLy8gRG8gdGhlIHNhbWUgZm9yIGFueSBhbHJlYWR5IGluamVjdGVkIHJvb3RzLlxuICAgIC8vIFRoaXMgaXMgdXNlZnVsIGlmIFJlYWN0RE9NIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNzYyNlxuXG5cbiAgICBob29rLnJlbmRlcmVycy5mb3JFYWNoKGZ1bmN0aW9uIChpbmplY3RlZCwgaWQpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5qZWN0ZWQuc2NoZWR1bGVSZWZyZXNoID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbmplY3RlZC5zZXRSZWZyZXNoSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUaGlzIHZlcnNpb24gc3VwcG9ydHMgUmVhY3QgUmVmcmVzaC5cbiAgICAgICAgaGVscGVyc0J5UmVuZGVyZXJJRC5zZXQoaWQsIGluamVjdGVkKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gV2UgYWxzbyB3YW50IHRvIHRyYWNrIGN1cnJlbnRseSBtb3VudGVkIHJvb3RzLlxuXG4gICAgdmFyIG9sZE9uQ29tbWl0RmliZXJSb290ID0gaG9vay5vbkNvbW1pdEZpYmVyUm9vdDtcblxuICAgIHZhciBvbGRPblNjaGVkdWxlRmliZXJSb290ID0gaG9vay5vblNjaGVkdWxlRmliZXJSb290IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgaG9vay5vblNjaGVkdWxlRmliZXJSb290ID0gZnVuY3Rpb24gKGlkLCByb290LCBjaGlsZHJlbikge1xuICAgICAgaWYgKCFpc1BlcmZvcm1pbmdSZWZyZXNoKSB7XG4gICAgICAgIC8vIElmIGl0IHdhcyBpbnRlbnRpb25hbGx5IHNjaGVkdWxlZCwgZG9uJ3QgYXR0ZW1wdCB0byByZXN0b3JlLlxuICAgICAgICAvLyBUaGlzIGluY2x1ZGVzIGludGVudGlvbmFsbHkgc2NoZWR1bGVkIHVubW91bnRzLlxuICAgICAgICBmYWlsZWRSb290cy5kZWxldGUocm9vdCk7XG5cbiAgICAgICAgaWYgKHJvb3RFbGVtZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgIHJvb3RFbGVtZW50cy5zZXQocm9vdCwgY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvbGRPblNjaGVkdWxlRmliZXJSb290LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGhvb2sub25Db21taXRGaWJlclJvb3QgPSBmdW5jdGlvbiAoaWQsIHJvb3QsIG1heWJlUHJpb3JpdHlMZXZlbCwgZGlkRXJyb3IpIHtcbiAgICAgIHZhciBoZWxwZXJzID0gaGVscGVyc0J5UmVuZGVyZXJJRC5nZXQoaWQpO1xuXG4gICAgICBpZiAoaGVscGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhlbHBlcnNCeVJvb3Quc2V0KHJvb3QsIGhlbHBlcnMpO1xuICAgICAgICB2YXIgY3VycmVudCA9IHJvb3QuY3VycmVudDtcbiAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGN1cnJlbnQuYWx0ZXJuYXRlOyAvLyBXZSBuZWVkIHRvIGRldGVybWluZSB3aGV0aGVyIHRoaXMgcm9vdCBoYXMganVzdCAodW4pbW91bnRlZC5cbiAgICAgICAgLy8gVGhpcyBsb2dpYyBpcyBjb3B5LXBhc3RlZCBmcm9tIHNpbWlsYXIgbG9naWMgaW4gdGhlIERldlRvb2xzIGJhY2tlbmQuXG4gICAgICAgIC8vIElmIHRoaXMgYnJlYWtzIHdpdGggc29tZSByZWZhY3RvcmluZywgeW91J2xsIHdhbnQgdG8gdXBkYXRlIERldlRvb2xzIHRvby5cblxuICAgICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHdhc01vdW50ZWQgPSBhbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSAhPSBudWxsICYmIGFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmVsZW1lbnQgIT0gbnVsbCAmJiBtb3VudGVkUm9vdHMuaGFzKHJvb3QpO1xuICAgICAgICAgIHZhciBpc01vdW50ZWQgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUuZWxlbWVudCAhPSBudWxsO1xuXG4gICAgICAgICAgaWYgKCF3YXNNb3VudGVkICYmIGlzTW91bnRlZCkge1xuICAgICAgICAgICAgLy8gTW91bnQgYSBuZXcgcm9vdC5cbiAgICAgICAgICAgIG1vdW50ZWRSb290cy5hZGQocm9vdCk7XG4gICAgICAgICAgICBmYWlsZWRSb290cy5kZWxldGUocm9vdCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh3YXNNb3VudGVkICYmIGlzTW91bnRlZCkgOyBlbHNlIGlmICh3YXNNb3VudGVkICYmICFpc01vdW50ZWQpIHtcbiAgICAgICAgICAgIC8vIFVubW91bnQgYW4gZXhpc3Rpbmcgcm9vdC5cbiAgICAgICAgICAgIG1vdW50ZWRSb290cy5kZWxldGUocm9vdCk7XG5cbiAgICAgICAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICAgICAgICAvLyBXZSdsbCByZW1vdW50IGl0IG9uIGZ1dHVyZSBlZGl0cy5cbiAgICAgICAgICAgICAgZmFpbGVkUm9vdHMuYWRkKHJvb3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaGVscGVyc0J5Um9vdC5kZWxldGUocm9vdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghd2FzTW91bnRlZCAmJiAhaXNNb3VudGVkKSB7XG4gICAgICAgICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gV2UnbGwgcmVtb3VudCBpdCBvbiBmdXR1cmUgZWRpdHMuXG4gICAgICAgICAgICAgIGZhaWxlZFJvb3RzLmFkZChyb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTW91bnQgYSBuZXcgcm9vdC5cbiAgICAgICAgICBtb3VudGVkUm9vdHMuYWRkKHJvb3QpO1xuICAgICAgICB9XG4gICAgICB9IC8vIEFsd2F5cyBjYWxsIHRoZSBkZWNvcmF0ZWQgRGV2VG9vbHMgaG9vay5cblxuXG4gICAgICByZXR1cm4gb2xkT25Db21taXRGaWJlclJvb3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBoYXNVbnJlY292ZXJhYmxlRXJyb3JzKCkge1xuICAvLyBUT0RPOiBkZWxldGUgdGhpcyBhZnRlciByZW1vdmluZyBkZXBlbmRlbmN5IGluIFJOLlxuICByZXR1cm4gZmFsc2U7XG59IC8vIEV4cG9zZWQgZm9yIHRlc3RpbmcuXG5cbmZ1bmN0aW9uIF9nZXRNb3VudGVkUm9vdENvdW50KCkge1xuICB7XG4gICAgcmV0dXJuIG1vdW50ZWRSb290cy5zaXplO1xuICB9XG59IC8vIFRoaXMgaXMgYSB3cmFwcGVyIG92ZXIgbW9yZSBwcmltaXRpdmUgZnVuY3Rpb25zIGZvciBzZXR0aW5nIHNpZ25hdHVyZS5cbi8vIFNpZ25hdHVyZXMgbGV0IHVzIGRlY2lkZSB3aGV0aGVyIHRoZSBIb29rIG9yZGVyIGhhcyBjaGFuZ2VkIG9uIHJlZnJlc2guXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIGEgdHJhbnNmb3JtIHRhcmdldCwgZS5nLjpcbi8vIHZhciBfcyA9IGNyZWF0ZVNpZ25hdHVyZUZ1bmN0aW9uRm9yVHJhbnNmb3JtKClcbi8vXG4vLyBmdW5jdGlvbiBIZWxsbygpIHtcbi8vICAgY29uc3QgW2Zvbywgc2V0Rm9vXSA9IHVzZVN0YXRlKDApO1xuLy8gICBjb25zdCB2YWx1ZSA9IHVzZUN1c3RvbUhvb2soKTtcbi8vICAgX3MoKTsgLyogQ2FsbCB3aXRob3V0IGFyZ3VtZW50cyB0cmlnZ2VycyBjb2xsZWN0aW5nIHRoZSBjdXN0b20gSG9vayBsaXN0LlxuLy8gICAgICAgICAgKiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGR1cmluZyB0aGUgbW9kdWxlIGV2YWx1YXRpb24gYmVjYXVzZSB3ZVxuLy8gICAgICAgICAgKiBkb24ndCB3YW50IHRvIGNoYW5nZSB0aGUgbW9kdWxlIG9yZGVyIHdpdGggaW5saW5lIHJlcXVpcmVzLlxuLy8gICAgICAgICAgKiBOZXh0IGNhbGxzIGFyZSBub29wcy4gKi9cbi8vICAgcmV0dXJuIDxoMT5IaTwvaDE+O1xuLy8gfVxuLy9cbi8vIC8qIENhbGwgd2l0aCBhcmd1bWVudHMgYXR0YWNoZXMgdGhlIHNpZ25hdHVyZSB0byB0aGUgdHlwZTogKi9cbi8vIF9zKFxuLy8gICBIZWxsbyxcbi8vICAgJ3VzZVN0YXRle1tmb28sIHNldEZvb119KDApJyxcbi8vICAgKCkgPT4gW3VzZUN1c3RvbUhvb2tdLCAvKiBMYXp5IHRvIGF2b2lkIHRyaWdnZXJpbmcgaW5saW5lIHJlcXVpcmVzICovXG4vLyApO1xuXG5mdW5jdGlvbiBjcmVhdGVTaWduYXR1cmVGdW5jdGlvbkZvclRyYW5zZm9ybSgpIHtcbiAge1xuICAgIHZhciBzYXZlZFR5cGU7XG4gICAgdmFyIGhhc0N1c3RvbUhvb2tzO1xuICAgIHZhciBkaWRDb2xsZWN0SG9va3MgPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHR5cGUsIGtleSwgZm9yY2VSZXNldCwgZ2V0Q3VzdG9tSG9va3MpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBXZSdyZSBpbiB0aGUgaW5pdGlhbCBwaGFzZSB0aGF0IGFzc29jaWF0ZXMgc2lnbmF0dXJlc1xuICAgICAgICAvLyB3aXRoIHRoZSBmdW5jdGlvbnMuIE5vdGUgdGhpcyBtYXkgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzXG4gICAgICAgIC8vIGluIEhPQyBjaGFpbnMgbGlrZSBfcyhob2MxKF9zKGhvYzIoX3MoYWN0dWFsRnVuY3Rpb24pKSkpKS5cbiAgICAgICAgaWYgKCFzYXZlZFR5cGUpIHtcbiAgICAgICAgICAvLyBXZSdyZSBpbiB0aGUgaW5uZXJtb3N0IGNhbGwsIHNvIHRoaXMgaXMgdGhlIGFjdHVhbCB0eXBlLlxuICAgICAgICAgIHNhdmVkVHlwZSA9IHR5cGU7XG4gICAgICAgICAgaGFzQ3VzdG9tSG9va3MgPSB0eXBlb2YgZ2V0Q3VzdG9tSG9va3MgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIH0gLy8gU2V0IHRoZSBzaWduYXR1cmUgZm9yIGFsbCB0eXBlcyAoZXZlbiB3cmFwcGVycyEpIGluIGNhc2VcbiAgICAgICAgLy8gdGhleSBoYXZlIG5vIHNpZ25hdHVyZXMgb2YgdGhlaXIgb3duLiBUaGlzIGlzIHRvIHByZXZlbnRcbiAgICAgICAgLy8gcHJvYmxlbXMgbGlrZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwNDE3LlxuXG5cbiAgICAgICAgaWYgKHR5cGUgIT0gbnVsbCAmJiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgIHNldFNpZ25hdHVyZSh0eXBlLCBrZXksIGZvcmNlUmVzZXQsIGdldEN1c3RvbUhvb2tzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UncmUgaW4gdGhlIF9zKCkgY2FsbCB3aXRob3V0IGFyZ3VtZW50cywgd2hpY2ggbWVhbnNcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgdGltZSB0byBjb2xsZWN0IGN1c3RvbSBIb29rIHNpZ25hdHVyZXMuXG4gICAgICAgIC8vIE9ubHkgZG8gdGhpcyBvbmNlLiBUaGlzIHBhdGggaXMgaG90IGFuZCBydW5zICppbnNpZGUqIGV2ZXJ5IHJlbmRlciFcbiAgICAgICAgaWYgKCFkaWRDb2xsZWN0SG9va3MgJiYgaGFzQ3VzdG9tSG9va3MpIHtcbiAgICAgICAgICBkaWRDb2xsZWN0SG9va3MgPSB0cnVlO1xuICAgICAgICAgIGNvbGxlY3RDdXN0b21Ib29rc0ZvclNpZ25hdHVyZShzYXZlZFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXNMaWtlbHlDb21wb25lbnRUeXBlKHR5cGUpIHtcbiAge1xuICAgIHN3aXRjaCAodHlwZW9mIHR5cGUpIHtcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIEZpcnN0LCBkZWFsIHdpdGggY2xhc3Nlcy5cbiAgICAgICAgICBpZiAodHlwZS5wcm90b3R5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgLy8gUmVhY3QgY2xhc3MuXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3duTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0eXBlLnByb3RvdHlwZSk7XG5cbiAgICAgICAgICAgIGlmIChvd25OYW1lcy5sZW5ndGggPiAxIHx8IG93bk5hbWVzWzBdICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgbG9va3MgbGlrZSBhIGNsYXNzLlxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b1xuXG5cbiAgICAgICAgICAgIGlmICh0eXBlLnByb3RvdHlwZS5fX3Byb3RvX18gIT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgLy8gSXQgaGFzIGEgc3VwZXJjbGFzcy5cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSAvLyBQYXNzIHRocm91Z2guXG4gICAgICAgICAgICAvLyBUaGlzIGxvb2tzIGxpa2UgYSByZWd1bGFyIGZ1bmN0aW9uIHdpdGggZW1wdHkgcHJvdG90eXBlLlxuXG4gICAgICAgICAgfSAvLyBGb3IgcGxhaW4gZnVuY3Rpb25zIGFuZCBhcnJvd3MsIHVzZSBuYW1lIGFzIGEgaGV1cmlzdGljLlxuXG5cbiAgICAgICAgICB2YXIgbmFtZSA9IHR5cGUubmFtZSB8fCB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgL15bQS1aXS8udGVzdChuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoIChnZXRQcm9wZXJ0eSh0eXBlLCAnJCR0eXBlb2YnKSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgIC8vIERlZmluaXRlbHkgUmVhY3QgY29tcG9uZW50cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLl9nZXRNb3VudGVkUm9vdENvdW50ID0gX2dldE1vdW50ZWRSb290Q291bnQ7XG5leHBvcnRzLmNvbGxlY3RDdXN0b21Ib29rc0ZvclNpZ25hdHVyZSA9IGNvbGxlY3RDdXN0b21Ib29rc0ZvclNpZ25hdHVyZTtcbmV4cG9ydHMuY3JlYXRlU2lnbmF0dXJlRnVuY3Rpb25Gb3JUcmFuc2Zvcm0gPSBjcmVhdGVTaWduYXR1cmVGdW5jdGlvbkZvclRyYW5zZm9ybTtcbmV4cG9ydHMuZmluZEFmZmVjdGVkSG9zdEluc3RhbmNlcyA9IGZpbmRBZmZlY3RlZEhvc3RJbnN0YW5jZXM7XG5leHBvcnRzLmdldEZhbWlseUJ5SUQgPSBnZXRGYW1pbHlCeUlEO1xuZXhwb3J0cy5nZXRGYW1pbHlCeVR5cGUgPSBnZXRGYW1pbHlCeVR5cGU7XG5leHBvcnRzLmhhc1VucmVjb3ZlcmFibGVFcnJvcnMgPSBoYXNVbnJlY292ZXJhYmxlRXJyb3JzO1xuZXhwb3J0cy5pbmplY3RJbnRvR2xvYmFsSG9vayA9IGluamVjdEludG9HbG9iYWxIb29rO1xuZXhwb3J0cy5pc0xpa2VseUNvbXBvbmVudFR5cGUgPSBpc0xpa2VseUNvbXBvbmVudFR5cGU7XG5leHBvcnRzLnBlcmZvcm1SZWFjdFJlZnJlc2ggPSBwZXJmb3JtUmVhY3RSZWZyZXNoO1xuZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuZXhwb3J0cy5zZXRTaWduYXR1cmUgPSBzZXRTaWduYXR1cmU7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9NRU1PX1RZUEUiLCJQb3NzaWJseVdlYWtNYXAiLCJXZWFrTWFwIiwiTWFwIiwiYWxsRmFtaWxpZXNCeUlEIiwiYWxsRmFtaWxpZXNCeVR5cGUiLCJhbGxTaWduYXR1cmVzQnlUeXBlIiwidXBkYXRlZEZhbWlsaWVzQnlUeXBlIiwicGVuZGluZ1VwZGF0ZXMiLCJoZWxwZXJzQnlSZW5kZXJlcklEIiwiaGVscGVyc0J5Um9vdCIsIm1vdW50ZWRSb290cyIsIlNldCIsImZhaWxlZFJvb3RzIiwicm9vdEVsZW1lbnRzIiwiaXNQZXJmb3JtaW5nUmVmcmVzaCIsImNvbXB1dGVGdWxsS2V5Iiwic2lnbmF0dXJlIiwiZnVsbEtleSIsIm93bktleSIsImhvb2tzIiwiZ2V0Q3VzdG9tSG9va3MiLCJlcnIiLCJmb3JjZVJlc2V0IiwiaSIsImxlbmd0aCIsImhvb2siLCJuZXN0ZWRIb29rU2lnbmF0dXJlIiwiZ2V0IiwidW5kZWZpbmVkIiwibmVzdGVkSG9va0tleSIsImhhdmVFcXVhbFNpZ25hdHVyZXMiLCJwcmV2VHlwZSIsIm5leHRUeXBlIiwicHJldlNpZ25hdHVyZSIsIm5leHRTaWduYXR1cmUiLCJpc1JlYWN0Q2xhc3MiLCJ0eXBlIiwicHJvdG90eXBlIiwiaXNSZWFjdENvbXBvbmVudCIsImNhblByZXNlcnZlU3RhdGVCZXR3ZWVuIiwicmVzb2x2ZUZhbWlseSIsImNsb25lTWFwIiwibWFwIiwiY2xvbmUiLCJmb3JFYWNoIiwidmFsdWUiLCJrZXkiLCJzZXQiLCJjbG9uZVNldCIsImFkZCIsImdldFByb3BlcnR5Iiwib2JqZWN0IiwicHJvcGVydHkiLCJwZXJmb3JtUmVhY3RSZWZyZXNoIiwic3RhbGVGYW1pbGllcyIsInVwZGF0ZWRGYW1pbGllcyIsInVwZGF0ZXMiLCJfcmVmIiwiZmFtaWx5IiwiY3VycmVudCIsInVwZGF0ZSIsImhlbHBlcnMiLCJzZXRSZWZyZXNoSGFuZGxlciIsImRpZEVycm9yIiwiZmlyc3RFcnJvciIsImZhaWxlZFJvb3RzU25hcHNob3QiLCJtb3VudGVkUm9vdHNTbmFwc2hvdCIsImhlbHBlcnNCeVJvb3RTbmFwc2hvdCIsInJvb3QiLCJFcnJvciIsImhhcyIsImVsZW1lbnQiLCJzY2hlZHVsZVJvb3QiLCJzY2hlZHVsZVJlZnJlc2giLCJyZWdpc3RlciIsImlkIiwicHVzaCIsInJlbmRlciIsInNldFNpZ25hdHVyZSIsImFyZ3VtZW50cyIsImNvbGxlY3RDdXN0b21Ib29rc0ZvclNpZ25hdHVyZSIsImdldEZhbWlseUJ5SUQiLCJnZXRGYW1pbHlCeVR5cGUiLCJmaW5kQWZmZWN0ZWRIb3N0SW5zdGFuY2VzIiwiZmFtaWxpZXMiLCJhZmZlY3RlZEluc3RhbmNlcyIsImluc3RhbmNlc0ZvclJvb3QiLCJmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2giLCJpbnN0IiwiaW5qZWN0SW50b0dsb2JhbEhvb2siLCJnbG9iYWxPYmplY3QiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJuZXh0SUQiLCJyZW5kZXJlcnMiLCJzdXBwb3J0c0ZpYmVyIiwiaW5qZWN0IiwiaW5qZWN0ZWQiLCJvblNjaGVkdWxlRmliZXJSb290IiwiY2hpbGRyZW4iLCJvbkNvbW1pdEZpYmVyUm9vdCIsIm1heWJlUHJpb3JpdHlMZXZlbCIsIm9uQ29tbWl0RmliZXJVbm1vdW50IiwiaXNEaXNhYmxlZCIsImNvbnNvbGUiLCJvbGRJbmplY3QiLCJhcHBseSIsIm9sZE9uQ29tbWl0RmliZXJSb290Iiwib2xkT25TY2hlZHVsZUZpYmVyUm9vdCIsImRlbGV0ZSIsImFsdGVybmF0ZSIsIndhc01vdW50ZWQiLCJtZW1vaXplZFN0YXRlIiwiaXNNb3VudGVkIiwiaGFzVW5yZWNvdmVyYWJsZUVycm9ycyIsIl9nZXRNb3VudGVkUm9vdENvdW50Iiwic2l6ZSIsImNyZWF0ZVNpZ25hdHVyZUZ1bmN0aW9uRm9yVHJhbnNmb3JtIiwic2F2ZWRUeXBlIiwiaGFzQ3VzdG9tSG9va3MiLCJkaWRDb2xsZWN0SG9va3MiLCJpc0xpa2VseUNvbXBvbmVudFR5cGUiLCJvd25OYW1lcyIsIk9iamVjdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJfX3Byb3RvX18iLCJuYW1lIiwiZGlzcGxheU5hbWUiLCJ0ZXN0IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react-refresh/runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-refresh/runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-refresh-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtcmVmcmVzaC9ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLHNNQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LXJlZnJlc2gvcnVudGltZS5qcz85YzZlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWZyZXNoLXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVmcmVzaC1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react-refresh/runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js ***!
  \*****************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * @license React\n * react-server-dom-webpack-client.browser.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var ReactDOM = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n        var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // -----------------------------------------------------------------------------\n        var enableBinaryFlight = false;\n        function createStringDecoder() {\n            return new TextDecoder();\n        }\n        var decoderOptions = {\n            stream: true\n        };\n        function readPartialStringChunk(decoder, buffer) {\n            return decoder.decode(buffer, decoderOptions);\n        }\n        function readFinalStringChunk(decoder, buffer) {\n            return decoder.decode(buffer);\n        }\n        // This is the parsed shape of the wire format which is why it is\n        // condensed to only the essentialy information\n        var ID = 0;\n        var CHUNKS = 1;\n        var NAME = 2; // export const ASYNC = 3;\n        // This logic is correct because currently only include the 4th tuple member\n        // when the module is async. If that changes we will need to actually assert\n        // the value is true. We don't index into the 4th slot because flow does not\n        // like the potential out of bounds access\n        function isAsyncImport(metadata) {\n            return metadata.length === 4;\n        }\n        function resolveClientReference(bundlerConfig, metadata) {\n            if (bundlerConfig) {\n                var moduleExports = bundlerConfig[metadata[ID]];\n                var resolvedModuleData = moduleExports[metadata[NAME]];\n                var name;\n                if (resolvedModuleData) {\n                    // The potentially aliased name.\n                    name = resolvedModuleData.name;\n                } else {\n                    // If we don't have this specific name, we might have the full module.\n                    resolvedModuleData = moduleExports[\"*\"];\n                    if (!resolvedModuleData) {\n                        throw new Error('Could not find the module \"' + metadata[ID] + '\" in the React SSR Manifest. ' + \"This is probably a bug in the React Server Components bundler.\");\n                    }\n                    name = metadata[NAME];\n                }\n                if (isAsyncImport(metadata)) {\n                    return [\n                        resolvedModuleData.id,\n                        resolvedModuleData.chunks,\n                        name,\n                        1\n                    ];\n                } else {\n                    return [\n                        resolvedModuleData.id,\n                        resolvedModuleData.chunks,\n                        name\n                    ];\n                }\n            }\n            return metadata;\n        }\n        // If they're still pending they're a thenable. This map also exists\n        // in Webpack but unfortunately it's not exposed so we have to\n        // replicate it in user space. null means that it has already loaded.\n        var chunkCache = new Map();\n        function requireAsyncModule(id) {\n            // We've already loaded all the chunks. We can require the module.\n            var promise = __webpack_require__(id);\n            if (typeof promise.then !== \"function\") {\n                // This wasn't a promise after all.\n                return null;\n            } else if (promise.status === \"fulfilled\") {\n                // This module was already resolved earlier.\n                return null;\n            } else {\n                // Instrument the Promise to stash the result.\n                promise.then(function(value) {\n                    var fulfilledThenable = promise;\n                    fulfilledThenable.status = \"fulfilled\";\n                    fulfilledThenable.value = value;\n                }, function(reason) {\n                    var rejectedThenable = promise;\n                    rejectedThenable.status = \"rejected\";\n                    rejectedThenable.reason = reason;\n                });\n                return promise;\n            }\n        }\n        function ignoreReject() {} // Start preloading the modules since we might need them soon.\n        // This function doesn't suspend.\n        function preloadModule(metadata) {\n            var chunks = metadata[CHUNKS];\n            var promises = [];\n            var i = 0;\n            while(i < chunks.length){\n                var chunkId = chunks[i++];\n                var chunkFilename = chunks[i++];\n                var entry = chunkCache.get(chunkId);\n                if (entry === undefined) {\n                    var thenable = loadChunk(chunkId, chunkFilename);\n                    promises.push(thenable); // $FlowFixMe[method-unbinding]\n                    var resolve = chunkCache.set.bind(chunkCache, chunkId, null);\n                    thenable.then(resolve, ignoreReject);\n                    chunkCache.set(chunkId, thenable);\n                } else if (entry !== null) {\n                    promises.push(entry);\n                }\n            }\n            if (isAsyncImport(metadata)) {\n                if (promises.length === 0) {\n                    return requireAsyncModule(metadata[ID]);\n                } else {\n                    return Promise.all(promises).then(function() {\n                        return requireAsyncModule(metadata[ID]);\n                    });\n                }\n            } else if (promises.length > 0) {\n                return Promise.all(promises);\n            } else {\n                return null;\n            }\n        } // Actually require the module or suspend if it's not yet ready.\n        // Increase priority if necessary.\n        function requireModule(metadata) {\n            var moduleExports = __webpack_require__(metadata[ID]);\n            if (isAsyncImport(metadata)) {\n                if (typeof moduleExports.then !== \"function\") ;\n                else if (moduleExports.status === \"fulfilled\") {\n                    // This Promise should've been instrumented by preloadModule.\n                    moduleExports = moduleExports.value;\n                } else {\n                    throw moduleExports.reason;\n                }\n            }\n            if (metadata[NAME] === \"*\") {\n                // This is a placeholder value that represents that the caller imported this\n                // as a CommonJS module as is.\n                return moduleExports;\n            }\n            if (metadata[NAME] === \"\") {\n                // This is a placeholder value that represents that the caller accessed the\n                // default property of this if it was an ESM interop module.\n                return moduleExports.__esModule ? moduleExports.default : moduleExports;\n            }\n            return moduleExports[metadata[NAME]];\n        }\n        var chunkMap = new Map();\n        /**\n * We patch the chunk filename function in webpack to insert our own resolution\n * of chunks that come from Flight and may not be known to the webpack runtime\n */ var webpackGetChunkFilename = __webpack_require__.u;\n        __webpack_require__.u = function(chunkId) {\n            var flightChunk = chunkMap.get(chunkId);\n            if (flightChunk !== undefined) {\n                return flightChunk;\n            }\n            return webpackGetChunkFilename(chunkId);\n        };\n        function loadChunk(chunkId, filename) {\n            chunkMap.set(chunkId, filename);\n            return __webpack_require__.e(chunkId);\n        }\n        var ReactDOMSharedInternals = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        // This client file is in the shared folder because it applies to both SSR and browser contexts.\n        var ReactDOMCurrentDispatcher = ReactDOMSharedInternals.Dispatcher;\n        function dispatchHint(code, model) {\n            var dispatcher = ReactDOMCurrentDispatcher.current;\n            if (dispatcher) {\n                switch(code){\n                    case \"D\":\n                        {\n                            var refined = refineModel(code, model);\n                            var href = refined;\n                            dispatcher.prefetchDNS(href);\n                            return;\n                        }\n                    case \"C\":\n                        {\n                            var _refined = refineModel(code, model);\n                            if (typeof _refined === \"string\") {\n                                var _href = _refined;\n                                dispatcher.preconnect(_href);\n                            } else {\n                                var _href2 = _refined[0];\n                                var crossOrigin = _refined[1];\n                                dispatcher.preconnect(_href2, crossOrigin);\n                            }\n                            return;\n                        }\n                    case \"L\":\n                        {\n                            var _refined2 = refineModel(code, model);\n                            var _href3 = _refined2[0];\n                            var as = _refined2[1];\n                            if (_refined2.length === 3) {\n                                var options = _refined2[2];\n                                dispatcher.preload(_href3, as, options);\n                            } else {\n                                dispatcher.preload(_href3, as);\n                            }\n                            return;\n                        }\n                    case \"m\":\n                        {\n                            var _refined3 = refineModel(code, model);\n                            if (typeof _refined3 === \"string\") {\n                                var _href4 = _refined3;\n                                dispatcher.preloadModule(_href4);\n                            } else {\n                                var _href5 = _refined3[0];\n                                var _options = _refined3[1];\n                                dispatcher.preloadModule(_href5, _options);\n                            }\n                            return;\n                        }\n                    case \"S\":\n                        {\n                            var _refined4 = refineModel(code, model);\n                            if (typeof _refined4 === \"string\") {\n                                var _href6 = _refined4;\n                                dispatcher.preinitStyle(_href6);\n                            } else {\n                                var _href7 = _refined4[0];\n                                var precedence = _refined4[1] === 0 ? undefined : _refined4[1];\n                                var _options2 = _refined4.length === 3 ? _refined4[2] : undefined;\n                                dispatcher.preinitStyle(_href7, precedence, _options2);\n                            }\n                            return;\n                        }\n                    case \"X\":\n                        {\n                            var _refined5 = refineModel(code, model);\n                            if (typeof _refined5 === \"string\") {\n                                var _href8 = _refined5;\n                                dispatcher.preinitScript(_href8);\n                            } else {\n                                var _href9 = _refined5[0];\n                                var _options3 = _refined5[1];\n                                dispatcher.preinitScript(_href9, _options3);\n                            }\n                            return;\n                        }\n                    case \"M\":\n                        {\n                            var _refined6 = refineModel(code, model);\n                            if (typeof _refined6 === \"string\") {\n                                var _href10 = _refined6;\n                                dispatcher.preinitModuleScript(_href10);\n                            } else {\n                                var _href11 = _refined6[0];\n                                var _options4 = _refined6[1];\n                                dispatcher.preinitModuleScript(_href11, _options4);\n                            }\n                            return;\n                        }\n                }\n            }\n        } // Flow is having trouble refining the HintModels so we help it a bit.\n        // This should be compiled out in the production build.\n        function refineModel(code, model) {\n            return model;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for(\"react.default_value\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        var getPrototypeOf = Object.getPrototypeOf;\n        // in case they error.\n        var jsxPropsParents = new WeakMap();\n        var jsxChildrenParents = new WeakMap();\n        function isObjectPrototype(object) {\n            if (!object) {\n                return false;\n            }\n            var ObjectPrototype = Object.prototype;\n            if (object === ObjectPrototype) {\n                return true;\n            } // It might be an object from a different Realm which is\n            // still just a plain simple object.\n            if (getPrototypeOf(object)) {\n                return false;\n            }\n            var names = Object.getOwnPropertyNames(object);\n            for(var i = 0; i < names.length; i++){\n                if (!(names[i] in ObjectPrototype)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        function isSimpleObject(object) {\n            if (!isObjectPrototype(getPrototypeOf(object))) {\n                return false;\n            }\n            var names = Object.getOwnPropertyNames(object);\n            for(var i = 0; i < names.length; i++){\n                var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);\n                if (!descriptor) {\n                    return false;\n                }\n                if (!descriptor.enumerable) {\n                    if ((names[i] === \"key\" || names[i] === \"ref\") && typeof descriptor.get === \"function\") {\n                        continue;\n                    }\n                    return false;\n                }\n            }\n            return true;\n        }\n        function objectName(object) {\n            // $FlowFixMe[method-unbinding]\n            var name = Object.prototype.toString.call(object);\n            return name.replace(/^\\[object (.*)\\]$/, function(m, p0) {\n                return p0;\n            });\n        }\n        function describeKeyForErrorMessage(key) {\n            var encodedKey = JSON.stringify(key);\n            return '\"' + key + '\"' === encodedKey ? key : encodedKey;\n        }\n        function describeValueForErrorMessage(value) {\n            switch(typeof value){\n                case \"string\":\n                    {\n                        return JSON.stringify(value.length <= 10 ? value : value.slice(0, 10) + \"...\");\n                    }\n                case \"object\":\n                    {\n                        if (isArray(value)) {\n                            return \"[...]\";\n                        }\n                        var name = objectName(value);\n                        if (name === \"Object\") {\n                            return \"{...}\";\n                        }\n                        return name;\n                    }\n                case \"function\":\n                    return \"function\";\n                default:\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    return String(value);\n            }\n        }\n        function describeElementType(type) {\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeElementType(type.render);\n                    case REACT_MEMO_TYPE:\n                        return describeElementType(type.type);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeElementType(init(payload));\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        function describeObjectForErrorMessage(objectOrArray, expandedName) {\n            var objKind = objectName(objectOrArray);\n            if (objKind !== \"Object\" && objKind !== \"Array\") {\n                return objKind;\n            }\n            var str = \"\";\n            var start = -1;\n            var length = 0;\n            if (isArray(objectOrArray)) {\n                if (jsxChildrenParents.has(objectOrArray)) {\n                    // Print JSX Children\n                    var type = jsxChildrenParents.get(objectOrArray);\n                    str = \"<\" + describeElementType(type) + \">\";\n                    var array = objectOrArray;\n                    for(var i = 0; i < array.length; i++){\n                        var value = array[i];\n                        var substr = void 0;\n                        if (typeof value === \"string\") {\n                            substr = value;\n                        } else if (typeof value === \"object\" && value !== null) {\n                            substr = \"{\" + describeObjectForErrorMessage(value) + \"}\";\n                        } else {\n                            substr = \"{\" + describeValueForErrorMessage(value) + \"}\";\n                        }\n                        if (\"\" + i === expandedName) {\n                            start = str.length;\n                            length = substr.length;\n                            str += substr;\n                        } else if (substr.length < 15 && str.length + substr.length < 40) {\n                            str += substr;\n                        } else {\n                            str += \"{...}\";\n                        }\n                    }\n                    str += \"</\" + describeElementType(type) + \">\";\n                } else {\n                    // Print Array\n                    str = \"[\";\n                    var _array = objectOrArray;\n                    for(var _i = 0; _i < _array.length; _i++){\n                        if (_i > 0) {\n                            str += \", \";\n                        }\n                        var _value = _array[_i];\n                        var _substr = void 0;\n                        if (typeof _value === \"object\" && _value !== null) {\n                            _substr = describeObjectForErrorMessage(_value);\n                        } else {\n                            _substr = describeValueForErrorMessage(_value);\n                        }\n                        if (\"\" + _i === expandedName) {\n                            start = str.length;\n                            length = _substr.length;\n                            str += _substr;\n                        } else if (_substr.length < 10 && str.length + _substr.length < 40) {\n                            str += _substr;\n                        } else {\n                            str += \"...\";\n                        }\n                    }\n                    str += \"]\";\n                }\n            } else {\n                if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE) {\n                    str = \"<\" + describeElementType(objectOrArray.type) + \"/>\";\n                } else if (jsxPropsParents.has(objectOrArray)) {\n                    // Print JSX\n                    var _type = jsxPropsParents.get(objectOrArray);\n                    str = \"<\" + (describeElementType(_type) || \"...\");\n                    var object = objectOrArray;\n                    var names = Object.keys(object);\n                    for(var _i2 = 0; _i2 < names.length; _i2++){\n                        str += \" \";\n                        var name = names[_i2];\n                        str += describeKeyForErrorMessage(name) + \"=\";\n                        var _value2 = object[name];\n                        var _substr2 = void 0;\n                        if (name === expandedName && typeof _value2 === \"object\" && _value2 !== null) {\n                            _substr2 = describeObjectForErrorMessage(_value2);\n                        } else {\n                            _substr2 = describeValueForErrorMessage(_value2);\n                        }\n                        if (typeof _value2 !== \"string\") {\n                            _substr2 = \"{\" + _substr2 + \"}\";\n                        }\n                        if (name === expandedName) {\n                            start = str.length;\n                            length = _substr2.length;\n                            str += _substr2;\n                        } else if (_substr2.length < 10 && str.length + _substr2.length < 40) {\n                            str += _substr2;\n                        } else {\n                            str += \"...\";\n                        }\n                    }\n                    str += \">\";\n                } else {\n                    // Print Object\n                    str = \"{\";\n                    var _object = objectOrArray;\n                    var _names = Object.keys(_object);\n                    for(var _i3 = 0; _i3 < _names.length; _i3++){\n                        if (_i3 > 0) {\n                            str += \", \";\n                        }\n                        var _name = _names[_i3];\n                        str += describeKeyForErrorMessage(_name) + \": \";\n                        var _value3 = _object[_name];\n                        var _substr3 = void 0;\n                        if (typeof _value3 === \"object\" && _value3 !== null) {\n                            _substr3 = describeObjectForErrorMessage(_value3);\n                        } else {\n                            _substr3 = describeValueForErrorMessage(_value3);\n                        }\n                        if (_name === expandedName) {\n                            start = str.length;\n                            length = _substr3.length;\n                            str += _substr3;\n                        } else if (_substr3.length < 10 && str.length + _substr3.length < 40) {\n                            str += _substr3;\n                        } else {\n                            str += \"...\";\n                        }\n                    }\n                    str += \"}\";\n                }\n            }\n            if (expandedName === undefined) {\n                return str;\n            }\n            if (start > -1 && length > 0) {\n                var highlight = \" \".repeat(start) + \"^\".repeat(length);\n                return \"\\n  \" + str + \"\\n  \" + highlight;\n            }\n            return \"\\n  \" + str;\n        }\n        var ObjectPrototype = Object.prototype;\n        var knownServerReferences = new WeakMap(); // Serializable values\n        // Thenable<ReactServerValue>\n        // function serializeByValueID(id: number): string {\n        //   return '$' + id.toString(16);\n        // }\n        function serializePromiseID(id) {\n            return \"$@\" + id.toString(16);\n        }\n        function serializeServerReferenceID(id) {\n            return \"$F\" + id.toString(16);\n        }\n        function serializeSymbolReference(name) {\n            return \"$S\" + name;\n        }\n        function serializeFormDataReference(id) {\n            // Why K? F is \"Function\". D is \"Date\". What else?\n            return \"$K\" + id.toString(16);\n        }\n        function serializeNumber(number) {\n            if (Number.isFinite(number)) {\n                if (number === 0 && 1 / number === -Infinity) {\n                    return \"$-0\";\n                } else {\n                    return number;\n                }\n            } else {\n                if (number === Infinity) {\n                    return \"$Infinity\";\n                } else if (number === -Infinity) {\n                    return \"$-Infinity\";\n                } else {\n                    return \"$NaN\";\n                }\n            }\n        }\n        function serializeUndefined() {\n            return \"$undefined\";\n        }\n        function serializeDateFromDateJSON(dateJSON) {\n            // JSON.stringify automatically calls Date.prototype.toJSON which calls toISOString.\n            // We need only tack on a $D prefix.\n            return \"$D\" + dateJSON;\n        }\n        function serializeBigInt(n) {\n            return \"$n\" + n.toString(10);\n        }\n        function serializeMapID(id) {\n            return \"$Q\" + id.toString(16);\n        }\n        function serializeSetID(id) {\n            return \"$W\" + id.toString(16);\n        }\n        function escapeStringValue(value) {\n            if (value[0] === \"$\") {\n                // We need to escape $ prefixed strings since we use those to encode\n                // references to IDs and as special symbol values.\n                return \"$\" + value;\n            } else {\n                return value;\n            }\n        }\n        function processReply(root, formFieldPrefix, resolve, reject) {\n            var nextPartId = 1;\n            var pendingParts = 0;\n            var formData = null;\n            function resolveToJSON(key, value) {\n                var parent = this; // Make sure that `parent[key]` wasn't JSONified before `value` was passed to us\n                {\n                    // $FlowFixMe[incompatible-use]\n                    var originalValue = parent[key];\n                    if (typeof originalValue === \"object\" && originalValue !== value && !(originalValue instanceof Date)) {\n                        if (objectName(originalValue) !== \"Object\") {\n                            error(\"Only plain objects can be passed to Server Functions from the Client. \" + \"%s objects are not supported.%s\", objectName(originalValue), describeObjectForErrorMessage(parent, key));\n                        } else {\n                            error(\"Only plain objects can be passed to Server Functions from the Client. \" + \"Objects with toJSON methods are not supported. Convert it manually \" + \"to a simple value before passing it to props.%s\", describeObjectForErrorMessage(parent, key));\n                        }\n                    }\n                }\n                if (value === null) {\n                    return null;\n                }\n                if (typeof value === \"object\") {\n                    // $FlowFixMe[method-unbinding]\n                    if (typeof value.then === \"function\") {\n                        // We assume that any object with a .then property is a \"Thenable\" type,\n                        // or a Promise type. Either of which can be represented by a Promise.\n                        if (formData === null) {\n                            // Upgrade to use FormData to allow us to stream this value.\n                            formData = new FormData();\n                        }\n                        pendingParts++;\n                        var promiseId = nextPartId++;\n                        var thenable = value;\n                        thenable.then(function(partValue) {\n                            var partJSON = JSON.stringify(partValue, resolveToJSON); // $FlowFixMe[incompatible-type] We know it's not null because we assigned it above.\n                            var data = formData; // eslint-disable-next-line react-internal/safe-string-coercion\n                            data.append(formFieldPrefix + promiseId, partJSON);\n                            pendingParts--;\n                            if (pendingParts === 0) {\n                                resolve(data);\n                            }\n                        }, function(reason) {\n                            // In the future we could consider serializing this as an error\n                            // that throws on the server instead.\n                            reject(reason);\n                        });\n                        return serializePromiseID(promiseId);\n                    }\n                    if (isArray(value)) {\n                        // $FlowFixMe[incompatible-return]\n                        return value;\n                    } // TODO: Should we the Object.prototype.toString.call() to test for cross-realm objects?\n                    if (value instanceof FormData) {\n                        if (formData === null) {\n                            // Upgrade to use FormData to allow us to use rich objects as its values.\n                            formData = new FormData();\n                        }\n                        var data = formData;\n                        var refId = nextPartId++; // Copy all the form fields with a prefix for this reference.\n                        // These must come first in the form order because we assume that all the\n                        // fields are available before this is referenced.\n                        var prefix = formFieldPrefix + refId + \"_\"; // $FlowFixMe[prop-missing]: FormData has forEach.\n                        value.forEach(function(originalValue, originalKey) {\n                            data.append(prefix + originalKey, originalValue);\n                        });\n                        return serializeFormDataReference(refId);\n                    }\n                    if (value instanceof Map) {\n                        var partJSON = JSON.stringify(Array.from(value), resolveToJSON);\n                        if (formData === null) {\n                            formData = new FormData();\n                        }\n                        var mapId = nextPartId++;\n                        formData.append(formFieldPrefix + mapId, partJSON);\n                        return serializeMapID(mapId);\n                    }\n                    if (value instanceof Set) {\n                        var _partJSON = JSON.stringify(Array.from(value), resolveToJSON);\n                        if (formData === null) {\n                            formData = new FormData();\n                        }\n                        var setId = nextPartId++;\n                        formData.append(formFieldPrefix + setId, _partJSON);\n                        return serializeSetID(setId);\n                    }\n                    var iteratorFn = getIteratorFn(value);\n                    if (iteratorFn) {\n                        return Array.from(value);\n                    } // Verify that this is a simple plain object.\n                    var proto = getPrototypeOf(value);\n                    if (proto !== ObjectPrototype && (proto === null || getPrototypeOf(proto) !== null)) {\n                        throw new Error(\"Only plain objects, and a few built-ins, can be passed to Server Actions. \" + \"Classes or null prototypes are not supported.\");\n                    }\n                    {\n                        if (value.$$typeof === REACT_ELEMENT_TYPE) {\n                            error(\"React Element cannot be passed to Server Functions from the Client.%s\", describeObjectForErrorMessage(parent, key));\n                        } else if (value.$$typeof === REACT_LAZY_TYPE) {\n                            error(\"React Lazy cannot be passed to Server Functions from the Client.%s\", describeObjectForErrorMessage(parent, key));\n                        } else if (value.$$typeof === REACT_PROVIDER_TYPE) {\n                            error(\"React Context Providers cannot be passed to Server Functions from the Client.%s\", describeObjectForErrorMessage(parent, key));\n                        } else if (objectName(value) !== \"Object\") {\n                            error(\"Only plain objects can be passed to Server Functions from the Client. \" + \"%s objects are not supported.%s\", objectName(value), describeObjectForErrorMessage(parent, key));\n                        } else if (!isSimpleObject(value)) {\n                            error(\"Only plain objects can be passed to Server Functions from the Client. \" + \"Classes or other objects with methods are not supported.%s\", describeObjectForErrorMessage(parent, key));\n                        } else if (Object.getOwnPropertySymbols) {\n                            var symbols = Object.getOwnPropertySymbols(value);\n                            if (symbols.length > 0) {\n                                error(\"Only plain objects can be passed to Server Functions from the Client. \" + \"Objects with symbol properties like %s are not supported.%s\", symbols[0].description, describeObjectForErrorMessage(parent, key));\n                            }\n                        }\n                    }\n                    return value;\n                }\n                if (typeof value === \"string\") {\n                    // TODO: Maybe too clever. If we support URL there's no similar trick.\n                    if (value[value.length - 1] === \"Z\") {\n                        // Possibly a Date, whose toJSON automatically calls toISOString\n                        // $FlowFixMe[incompatible-use]\n                        var _originalValue = parent[key];\n                        if (_originalValue instanceof Date) {\n                            return serializeDateFromDateJSON(value);\n                        }\n                    }\n                    return escapeStringValue(value);\n                }\n                if (typeof value === \"boolean\") {\n                    return value;\n                }\n                if (typeof value === \"number\") {\n                    return serializeNumber(value);\n                }\n                if (typeof value === \"undefined\") {\n                    return serializeUndefined();\n                }\n                if (typeof value === \"function\") {\n                    var metaData = knownServerReferences.get(value);\n                    if (metaData !== undefined) {\n                        var metaDataJSON = JSON.stringify(metaData, resolveToJSON);\n                        if (formData === null) {\n                            // Upgrade to use FormData to allow us to stream this value.\n                            formData = new FormData();\n                        } // The reference to this function came from the same client so we can pass it back.\n                        var _refId = nextPartId++; // eslint-disable-next-line react-internal/safe-string-coercion\n                        formData.set(formFieldPrefix + _refId, metaDataJSON);\n                        return serializeServerReferenceID(_refId);\n                    }\n                    throw new Error(\"Client Functions cannot be passed directly to Server Functions. \" + \"Only Functions passed from the Server can be passed back again.\");\n                }\n                if (typeof value === \"symbol\") {\n                    // $FlowFixMe[incompatible-type] `description` might be undefined\n                    var name = value.description;\n                    if (Symbol.for(name) !== value) {\n                        throw new Error(\"Only global symbols received from Symbol.for(...) can be passed to Server Functions. \" + (\"The symbol Symbol.for(\" + // $FlowFixMe[incompatible-type] `description` might be undefined\n                        value.description + \") cannot be found among global symbols.\"));\n                    }\n                    return serializeSymbolReference(name);\n                }\n                if (typeof value === \"bigint\") {\n                    return serializeBigInt(value);\n                }\n                throw new Error(\"Type \" + typeof value + \" is not supported as an argument to a Server Function.\");\n            } // $FlowFixMe[incompatible-type] it's not going to be undefined because we'll encode it.\n            var json = JSON.stringify(root, resolveToJSON);\n            if (formData === null) {\n                // If it's a simple data structure, we just use plain JSON.\n                resolve(json);\n            } else {\n                // Otherwise, we use FormData to let us stream in the result.\n                formData.set(formFieldPrefix + \"0\", json);\n                if (pendingParts === 0) {\n                    // $FlowFixMe[incompatible-call] this has already been refined.\n                    resolve(formData);\n                }\n            }\n        }\n        function registerServerReference(proxy, reference) {\n            knownServerReferences.set(proxy, reference);\n        } // $FlowFixMe[method-unbinding]\n        function createServerReference(id, callServer) {\n            var proxy = function() {\n                // $FlowFixMe[method-unbinding]\n                var args = Array.prototype.slice.call(arguments);\n                return callServer(id, args);\n            };\n            registerServerReference(proxy, {\n                id: id,\n                bound: null\n            });\n            return proxy;\n        }\n        var ContextRegistry = ReactSharedInternals.ContextRegistry;\n        function getOrCreateServerContext(globalName) {\n            if (!ContextRegistry[globalName]) {\n                var context = {\n                    $$typeof: REACT_SERVER_CONTEXT_TYPE,\n                    // As a workaround to support multiple concurrent renderers, we categorize\n                    // some renderers as primary and others as secondary. We only expect\n                    // there to be two concurrent renderers at most: React Native (primary) and\n                    // Fabric (secondary); React DOM (primary) and React ART (secondary).\n                    // Secondary renderers store their context values on separate fields.\n                    _currentValue: REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED,\n                    _currentValue2: REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED,\n                    _defaultValue: REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED,\n                    // Used to track how many concurrent renderers this context currently\n                    // supports within in a single renderer. Such as parallel server rendering.\n                    _threadCount: 0,\n                    // These are circular\n                    Provider: null,\n                    Consumer: null,\n                    _globalName: globalName\n                };\n                context.Provider = {\n                    $$typeof: REACT_PROVIDER_TYPE,\n                    _context: context\n                };\n                {\n                    var hasWarnedAboutUsingConsumer;\n                    context._currentRenderer = null;\n                    context._currentRenderer2 = null;\n                    Object.defineProperties(context, {\n                        Consumer: {\n                            get: function() {\n                                if (!hasWarnedAboutUsingConsumer) {\n                                    error(\"Consumer pattern is not supported by ReactServerContext\");\n                                    hasWarnedAboutUsingConsumer = true;\n                                }\n                                return null;\n                            }\n                        }\n                    });\n                }\n                ContextRegistry[globalName] = context;\n            }\n            return ContextRegistry[globalName];\n        }\n        var ROW_ID = 0;\n        var ROW_TAG = 1;\n        var ROW_LENGTH = 2;\n        var ROW_CHUNK_BY_NEWLINE = 3;\n        var ROW_CHUNK_BY_LENGTH = 4;\n        var PENDING = \"pending\";\n        var BLOCKED = \"blocked\";\n        var CYCLIC = \"cyclic\";\n        var RESOLVED_MODEL = \"resolved_model\";\n        var RESOLVED_MODULE = \"resolved_module\";\n        var INITIALIZED = \"fulfilled\";\n        var ERRORED = \"rejected\"; // $FlowFixMe[missing-this-annot]\n        function Chunk(status, value, reason, response) {\n            this.status = status;\n            this.value = value;\n            this.reason = reason;\n            this._response = response;\n        } // We subclass Promise.prototype so that we get other methods like .catch\n        Chunk.prototype = Object.create(Promise.prototype); // TODO: This doesn't return a new Promise chain unlike the real .then\n        Chunk.prototype.then = function(resolve, reject) {\n            var chunk = this; // If we have resolved content, we try to initialize it first which\n            // might put us back into one of the other states.\n            switch(chunk.status){\n                case RESOLVED_MODEL:\n                    initializeModelChunk(chunk);\n                    break;\n                case RESOLVED_MODULE:\n                    initializeModuleChunk(chunk);\n                    break;\n            } // The status might have changed after initialization.\n            switch(chunk.status){\n                case INITIALIZED:\n                    resolve(chunk.value);\n                    break;\n                case PENDING:\n                case BLOCKED:\n                case CYCLIC:\n                    if (resolve) {\n                        if (chunk.value === null) {\n                            chunk.value = [];\n                        }\n                        chunk.value.push(resolve);\n                    }\n                    if (reject) {\n                        if (chunk.reason === null) {\n                            chunk.reason = [];\n                        }\n                        chunk.reason.push(reject);\n                    }\n                    break;\n                default:\n                    reject(chunk.reason);\n                    break;\n            }\n        };\n        function readChunk(chunk) {\n            // If we have resolved content, we try to initialize it first which\n            // might put us back into one of the other states.\n            switch(chunk.status){\n                case RESOLVED_MODEL:\n                    initializeModelChunk(chunk);\n                    break;\n                case RESOLVED_MODULE:\n                    initializeModuleChunk(chunk);\n                    break;\n            } // The status might have changed after initialization.\n            switch(chunk.status){\n                case INITIALIZED:\n                    return chunk.value;\n                case PENDING:\n                case BLOCKED:\n                case CYCLIC:\n                    // eslint-disable-next-line no-throw-literal\n                    throw chunk;\n                default:\n                    throw chunk.reason;\n            }\n        }\n        function getRoot(response) {\n            var chunk = getChunk(response, 0);\n            return chunk;\n        }\n        function createPendingChunk(response) {\n            // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors\n            return new Chunk(PENDING, null, null, response);\n        }\n        function createBlockedChunk(response) {\n            // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors\n            return new Chunk(BLOCKED, null, null, response);\n        }\n        function createErrorChunk(response, error) {\n            // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors\n            return new Chunk(ERRORED, null, error, response);\n        }\n        function wakeChunk(listeners, value) {\n            for(var i = 0; i < listeners.length; i++){\n                var listener = listeners[i];\n                listener(value);\n            }\n        }\n        function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {\n            switch(chunk.status){\n                case INITIALIZED:\n                    wakeChunk(resolveListeners, chunk.value);\n                    break;\n                case PENDING:\n                case BLOCKED:\n                case CYCLIC:\n                    chunk.value = resolveListeners;\n                    chunk.reason = rejectListeners;\n                    break;\n                case ERRORED:\n                    if (rejectListeners) {\n                        wakeChunk(rejectListeners, chunk.reason);\n                    }\n                    break;\n            }\n        }\n        function triggerErrorOnChunk(chunk, error) {\n            if (chunk.status !== PENDING && chunk.status !== BLOCKED) {\n                // We already resolved. We didn't expect to see this.\n                return;\n            }\n            var listeners = chunk.reason;\n            var erroredChunk = chunk;\n            erroredChunk.status = ERRORED;\n            erroredChunk.reason = error;\n            if (listeners !== null) {\n                wakeChunk(listeners, error);\n            }\n        }\n        function createResolvedModelChunk(response, value) {\n            // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors\n            return new Chunk(RESOLVED_MODEL, value, null, response);\n        }\n        function createResolvedModuleChunk(response, value) {\n            // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors\n            return new Chunk(RESOLVED_MODULE, value, null, response);\n        }\n        function createInitializedTextChunk(response, value) {\n            // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors\n            return new Chunk(INITIALIZED, value, null, response);\n        }\n        function resolveModelChunk(chunk, value) {\n            if (chunk.status !== PENDING) {\n                // We already resolved. We didn't expect to see this.\n                return;\n            }\n            var resolveListeners = chunk.value;\n            var rejectListeners = chunk.reason;\n            var resolvedChunk = chunk;\n            resolvedChunk.status = RESOLVED_MODEL;\n            resolvedChunk.value = value;\n            if (resolveListeners !== null) {\n                // This is unfortunate that we're reading this eagerly if\n                // we already have listeners attached since they might no\n                // longer be rendered or might not be the highest pri.\n                initializeModelChunk(resolvedChunk); // The status might have changed after initialization.\n                wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);\n            }\n        }\n        function resolveModuleChunk(chunk, value) {\n            if (chunk.status !== PENDING && chunk.status !== BLOCKED) {\n                // We already resolved. We didn't expect to see this.\n                return;\n            }\n            var resolveListeners = chunk.value;\n            var rejectListeners = chunk.reason;\n            var resolvedChunk = chunk;\n            resolvedChunk.status = RESOLVED_MODULE;\n            resolvedChunk.value = value;\n            if (resolveListeners !== null) {\n                initializeModuleChunk(resolvedChunk);\n                wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);\n            }\n        }\n        var initializingChunk = null;\n        var initializingChunkBlockedModel = null;\n        function initializeModelChunk(chunk) {\n            var prevChunk = initializingChunk;\n            var prevBlocked = initializingChunkBlockedModel;\n            initializingChunk = chunk;\n            initializingChunkBlockedModel = null;\n            var resolvedModel = chunk.value; // We go to the CYCLIC state until we've fully resolved this.\n            // We do this before parsing in case we try to initialize the same chunk\n            // while parsing the model. Such as in a cyclic reference.\n            var cyclicChunk = chunk;\n            cyclicChunk.status = CYCLIC;\n            cyclicChunk.value = null;\n            cyclicChunk.reason = null;\n            try {\n                var value = parseModel(chunk._response, resolvedModel);\n                if (initializingChunkBlockedModel !== null && initializingChunkBlockedModel.deps > 0) {\n                    initializingChunkBlockedModel.value = value; // We discovered new dependencies on modules that are not yet resolved.\n                    // We have to go the BLOCKED state until they're resolved.\n                    var blockedChunk = chunk;\n                    blockedChunk.status = BLOCKED;\n                    blockedChunk.value = null;\n                    blockedChunk.reason = null;\n                } else {\n                    var resolveListeners = cyclicChunk.value;\n                    var initializedChunk = chunk;\n                    initializedChunk.status = INITIALIZED;\n                    initializedChunk.value = value;\n                    if (resolveListeners !== null) {\n                        wakeChunk(resolveListeners, value);\n                    }\n                }\n            } catch (error) {\n                var erroredChunk = chunk;\n                erroredChunk.status = ERRORED;\n                erroredChunk.reason = error;\n            } finally{\n                initializingChunk = prevChunk;\n                initializingChunkBlockedModel = prevBlocked;\n            }\n        }\n        function initializeModuleChunk(chunk) {\n            try {\n                var value = requireModule(chunk.value);\n                var initializedChunk = chunk;\n                initializedChunk.status = INITIALIZED;\n                initializedChunk.value = value;\n            } catch (error) {\n                var erroredChunk = chunk;\n                erroredChunk.status = ERRORED;\n                erroredChunk.reason = error;\n            }\n        } // Report that any missing chunks in the model is now going to throw this\n        // error upon read. Also notify any pending promises.\n        function reportGlobalError(response, error) {\n            response._chunks.forEach(function(chunk) {\n                // If this chunk was already resolved or errored, it won't\n                // trigger an error but if it wasn't then we need to\n                // because we won't be getting any new data to resolve it.\n                if (chunk.status === PENDING) {\n                    triggerErrorOnChunk(chunk, error);\n                }\n            });\n        }\n        function createElement(type, key, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: null,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: null\n            };\n            {\n                // We don't really need to add any of these but keeping them for good measure.\n                // Unfortunately, _store is enumerable in jest matchers so for equality to\n                // work, I need to keep it or make _store non-enumerable in the other file.\n                element._store = {};\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: true // This element has already been validated on the server.\n                });\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: null\n                });\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: null\n                });\n            }\n            return element;\n        }\n        function createLazyChunkWrapper(chunk) {\n            var lazyType = {\n                $$typeof: REACT_LAZY_TYPE,\n                _payload: chunk,\n                _init: readChunk\n            };\n            return lazyType;\n        }\n        function getChunk(response, id) {\n            var chunks = response._chunks;\n            var chunk = chunks.get(id);\n            if (!chunk) {\n                chunk = createPendingChunk(response);\n                chunks.set(id, chunk);\n            }\n            return chunk;\n        }\n        function createModelResolver(chunk, parentObject, key, cyclic) {\n            var blocked;\n            if (initializingChunkBlockedModel) {\n                blocked = initializingChunkBlockedModel;\n                if (!cyclic) {\n                    blocked.deps++;\n                }\n            } else {\n                blocked = initializingChunkBlockedModel = {\n                    deps: cyclic ? 0 : 1,\n                    value: null\n                };\n            }\n            return function(value) {\n                parentObject[key] = value;\n                blocked.deps--;\n                if (blocked.deps === 0) {\n                    if (chunk.status !== BLOCKED) {\n                        return;\n                    }\n                    var resolveListeners = chunk.value;\n                    var initializedChunk = chunk;\n                    initializedChunk.status = INITIALIZED;\n                    initializedChunk.value = blocked.value;\n                    if (resolveListeners !== null) {\n                        wakeChunk(resolveListeners, blocked.value);\n                    }\n                }\n            };\n        }\n        function createModelReject(chunk) {\n            return function(error) {\n                return triggerErrorOnChunk(chunk, error);\n            };\n        }\n        function createServerReferenceProxy(response, metaData) {\n            var callServer = response._callServer;\n            var proxy = function() {\n                // $FlowFixMe[method-unbinding]\n                var args = Array.prototype.slice.call(arguments);\n                var p = metaData.bound;\n                if (!p) {\n                    return callServer(metaData.id, args);\n                }\n                if (p.status === INITIALIZED) {\n                    var bound = p.value;\n                    return callServer(metaData.id, bound.concat(args));\n                } // Since this is a fake Promise whose .then doesn't chain, we have to wrap it.\n                // TODO: Remove the wrapper once that's fixed.\n                return Promise.resolve(p).then(function(bound) {\n                    return callServer(metaData.id, bound.concat(args));\n                });\n            };\n            registerServerReference(proxy, metaData);\n            return proxy;\n        }\n        function getOutlinedModel(response, id) {\n            var chunk = getChunk(response, id);\n            switch(chunk.status){\n                case RESOLVED_MODEL:\n                    initializeModelChunk(chunk);\n                    break;\n            } // The status might have changed after initialization.\n            switch(chunk.status){\n                case INITIALIZED:\n                    {\n                        return chunk.value;\n                    }\n                // We always encode it first in the stream so it won't be pending.\n                default:\n                    throw chunk.reason;\n            }\n        }\n        function parseModelString(response, parentObject, key, value) {\n            if (value[0] === \"$\") {\n                if (value === \"$\") {\n                    // A very common symbol.\n                    return REACT_ELEMENT_TYPE;\n                }\n                switch(value[1]){\n                    case \"$\":\n                        {\n                            // This was an escaped string value.\n                            return value.slice(1);\n                        }\n                    case \"L\":\n                        {\n                            // Lazy node\n                            var id = parseInt(value.slice(2), 16);\n                            var chunk = getChunk(response, id); // We create a React.lazy wrapper around any lazy values.\n                            // When passed into React, we'll know how to suspend on this.\n                            return createLazyChunkWrapper(chunk);\n                        }\n                    case \"@\":\n                        {\n                            // Promise\n                            var _id = parseInt(value.slice(2), 16);\n                            var _chunk = getChunk(response, _id);\n                            return _chunk;\n                        }\n                    case \"S\":\n                        {\n                            // Symbol\n                            return Symbol.for(value.slice(2));\n                        }\n                    case \"P\":\n                        {\n                            // Server Context Provider\n                            return getOrCreateServerContext(value.slice(2)).Provider;\n                        }\n                    case \"F\":\n                        {\n                            // Server Reference\n                            var _id2 = parseInt(value.slice(2), 16);\n                            var metadata = getOutlinedModel(response, _id2);\n                            return createServerReferenceProxy(response, metadata);\n                        }\n                    case \"Q\":\n                        {\n                            // Map\n                            var _id3 = parseInt(value.slice(2), 16);\n                            var data = getOutlinedModel(response, _id3);\n                            return new Map(data);\n                        }\n                    case \"W\":\n                        {\n                            // Set\n                            var _id4 = parseInt(value.slice(2), 16);\n                            var _data = getOutlinedModel(response, _id4);\n                            return new Set(_data);\n                        }\n                    case \"I\":\n                        {\n                            // $Infinity\n                            return Infinity;\n                        }\n                    case \"-\":\n                        {\n                            // $-0 or $-Infinity\n                            if (value === \"$-0\") {\n                                return -0;\n                            } else {\n                                return -Infinity;\n                            }\n                        }\n                    case \"N\":\n                        {\n                            // $NaN\n                            return NaN;\n                        }\n                    case \"u\":\n                        {\n                            // matches \"$undefined\"\n                            // Special encoding for `undefined` which can't be serialized as JSON otherwise.\n                            return undefined;\n                        }\n                    case \"D\":\n                        {\n                            // Date\n                            return new Date(Date.parse(value.slice(2)));\n                        }\n                    case \"n\":\n                        {\n                            // BigInt\n                            return BigInt(value.slice(2));\n                        }\n                    default:\n                        {\n                            // We assume that anything else is a reference ID.\n                            var _id5 = parseInt(value.slice(1), 16);\n                            var _chunk2 = getChunk(response, _id5);\n                            switch(_chunk2.status){\n                                case RESOLVED_MODEL:\n                                    initializeModelChunk(_chunk2);\n                                    break;\n                                case RESOLVED_MODULE:\n                                    initializeModuleChunk(_chunk2);\n                                    break;\n                            } // The status might have changed after initialization.\n                            switch(_chunk2.status){\n                                case INITIALIZED:\n                                    return _chunk2.value;\n                                case PENDING:\n                                case BLOCKED:\n                                case CYCLIC:\n                                    var parentChunk = initializingChunk;\n                                    _chunk2.then(createModelResolver(parentChunk, parentObject, key, _chunk2.status === CYCLIC), createModelReject(parentChunk));\n                                    return null;\n                                default:\n                                    throw _chunk2.reason;\n                            }\n                        }\n                }\n            }\n            return value;\n        }\n        function parseModelTuple(response, value) {\n            var tuple = value;\n            if (tuple[0] === REACT_ELEMENT_TYPE) {\n                // TODO: Consider having React just directly accept these arrays as elements.\n                // Or even change the ReactElement type to be an array.\n                return createElement(tuple[1], tuple[2], tuple[3]);\n            }\n            return value;\n        }\n        function missingCall() {\n            throw new Error('Trying to call a function from \"use server\" but the callServer option ' + \"was not implemented in your router runtime.\");\n        }\n        function createResponse(bundlerConfig, moduleLoading, callServer, nonce) {\n            var chunks = new Map();\n            var response = {\n                _bundlerConfig: bundlerConfig,\n                _moduleLoading: moduleLoading,\n                _callServer: callServer !== undefined ? callServer : missingCall,\n                _nonce: nonce,\n                _chunks: chunks,\n                _stringDecoder: createStringDecoder(),\n                _fromJSON: null,\n                _rowState: 0,\n                _rowID: 0,\n                _rowTag: 0,\n                _rowLength: 0,\n                _buffer: []\n            }; // Don't inline this call because it causes closure to outline the call above.\n            response._fromJSON = createFromJSONCallback(response);\n            return response;\n        }\n        function resolveModel(response, id, model) {\n            var chunks = response._chunks;\n            var chunk = chunks.get(id);\n            if (!chunk) {\n                chunks.set(id, createResolvedModelChunk(response, model));\n            } else {\n                resolveModelChunk(chunk, model);\n            }\n        }\n        function resolveText(response, id, text) {\n            var chunks = response._chunks; // We assume that we always reference large strings after they've been\n            // emitted.\n            chunks.set(id, createInitializedTextChunk(response, text));\n        }\n        function resolveModule(response, id, model) {\n            var chunks = response._chunks;\n            var chunk = chunks.get(id);\n            var clientReferenceMetadata = parseModel(response, model);\n            var clientReference = resolveClientReference(response._bundlerConfig, clientReferenceMetadata);\n            // For now we preload all modules as early as possible since it's likely\n            // that we'll need them.\n            var promise = preloadModule(clientReference);\n            if (promise) {\n                var blockedChunk;\n                if (!chunk) {\n                    // Technically, we should just treat promise as the chunk in this\n                    // case. Because it'll just behave as any other promise.\n                    blockedChunk = createBlockedChunk(response);\n                    chunks.set(id, blockedChunk);\n                } else {\n                    // This can't actually happen because we don't have any forward\n                    // references to modules.\n                    blockedChunk = chunk;\n                    blockedChunk.status = BLOCKED;\n                }\n                promise.then(function() {\n                    return resolveModuleChunk(blockedChunk, clientReference);\n                }, function(error) {\n                    return triggerErrorOnChunk(blockedChunk, error);\n                });\n            } else {\n                if (!chunk) {\n                    chunks.set(id, createResolvedModuleChunk(response, clientReference));\n                } else {\n                    // This can't actually happen because we don't have any forward\n                    // references to modules.\n                    resolveModuleChunk(chunk, clientReference);\n                }\n            }\n        }\n        function resolveErrorDev(response, id, digest, message, stack) {\n            var error = new Error(message || \"An error occurred in the Server Components render but no message was provided\");\n            error.stack = stack;\n            error.digest = digest;\n            var errorWithDigest = error;\n            var chunks = response._chunks;\n            var chunk = chunks.get(id);\n            if (!chunk) {\n                chunks.set(id, createErrorChunk(response, errorWithDigest));\n            } else {\n                triggerErrorOnChunk(chunk, errorWithDigest);\n            }\n        }\n        function resolveHint(response, code, model) {\n            var hintModel = parseModel(response, model);\n            dispatchHint(code, hintModel);\n        }\n        function processFullRow(response, id, tag, buffer, chunk) {\n            var stringDecoder = response._stringDecoder;\n            var row = \"\";\n            for(var i = 0; i < buffer.length; i++){\n                row += readPartialStringChunk(stringDecoder, buffer[i]);\n            }\n            row += readFinalStringChunk(stringDecoder, chunk);\n            switch(tag){\n                case 73:\n                    {\n                        resolveModule(response, id, row);\n                        return;\n                    }\n                case 72:\n                    {\n                        var code = row[0];\n                        resolveHint(response, code, row.slice(1));\n                        return;\n                    }\n                case 69:\n                    {\n                        var errorInfo = JSON.parse(row);\n                        {\n                            resolveErrorDev(response, id, errorInfo.digest, errorInfo.message, errorInfo.stack);\n                        }\n                        return;\n                    }\n                case 84:\n                    {\n                        resolveText(response, id, row);\n                        return;\n                    }\n                case 80:\n                // Fallthrough\n                default:\n                    /* \"\"\" \"{\" \"[\" \"t\" \"f\" \"n\" \"0\" - \"9\" */ {\n                        // We assume anything else is JSON.\n                        resolveModel(response, id, row);\n                        return;\n                    }\n            }\n        }\n        function processBinaryChunk(response, chunk) {\n            var i = 0;\n            var rowState = response._rowState;\n            var rowID = response._rowID;\n            var rowTag = response._rowTag;\n            var rowLength = response._rowLength;\n            var buffer = response._buffer;\n            var chunkLength = chunk.length;\n            while(i < chunkLength){\n                var lastIdx = -1;\n                switch(rowState){\n                    case ROW_ID:\n                        {\n                            var byte = chunk[i++];\n                            if (byte === 58) {\n                                // Finished the rowID, next we'll parse the tag.\n                                rowState = ROW_TAG;\n                            } else {\n                                rowID = rowID << 4 | (byte > 96 ? byte - 87 : byte - 48);\n                            }\n                            continue;\n                        }\n                    case ROW_TAG:\n                        {\n                            var resolvedRowTag = chunk[i];\n                            if (resolvedRowTag === 84 || enableBinaryFlight) {\n                                rowTag = resolvedRowTag;\n                                rowState = ROW_LENGTH;\n                                i++;\n                            } else if (resolvedRowTag > 64 && resolvedRowTag < 91) {\n                                rowTag = resolvedRowTag;\n                                rowState = ROW_CHUNK_BY_NEWLINE;\n                                i++;\n                            } else {\n                                rowTag = 0;\n                                rowState = ROW_CHUNK_BY_NEWLINE; // This was an unknown tag so it was probably part of the data.\n                            }\n                            continue;\n                        }\n                    case ROW_LENGTH:\n                        {\n                            var _byte = chunk[i++];\n                            if (_byte === 44) {\n                                // Finished the rowLength, next we'll buffer up to that length.\n                                rowState = ROW_CHUNK_BY_LENGTH;\n                            } else {\n                                rowLength = rowLength << 4 | (_byte > 96 ? _byte - 87 : _byte - 48);\n                            }\n                            continue;\n                        }\n                    case ROW_CHUNK_BY_NEWLINE:\n                        {\n                            // We're looking for a newline\n                            lastIdx = chunk.indexOf(10, i);\n                            break;\n                        }\n                    case ROW_CHUNK_BY_LENGTH:\n                        {\n                            // We're looking for the remaining byte length\n                            lastIdx = i + rowLength;\n                            if (lastIdx > chunk.length) {\n                                lastIdx = -1;\n                            }\n                            break;\n                        }\n                }\n                var offset = chunk.byteOffset + i;\n                if (lastIdx > -1) {\n                    // We found the last chunk of the row\n                    var length = lastIdx - i;\n                    var lastChunk = new Uint8Array(chunk.buffer, offset, length);\n                    processFullRow(response, rowID, rowTag, buffer, lastChunk); // Reset state machine for a new row\n                    i = lastIdx;\n                    if (rowState === ROW_CHUNK_BY_NEWLINE) {\n                        // If we're trailing by a newline we need to skip it.\n                        i++;\n                    }\n                    rowState = ROW_ID;\n                    rowTag = 0;\n                    rowID = 0;\n                    rowLength = 0;\n                    buffer.length = 0;\n                } else {\n                    // The rest of this row is in a future chunk. We stash the rest of the\n                    // current chunk until we can process the full row.\n                    var _length = chunk.byteLength - i;\n                    var remainingSlice = new Uint8Array(chunk.buffer, offset, _length);\n                    buffer.push(remainingSlice); // Update how many bytes we're still waiting for. If we're looking for\n                    // a newline, this doesn't hurt since we'll just ignore it.\n                    rowLength -= remainingSlice.byteLength;\n                    break;\n                }\n            }\n            response._rowState = rowState;\n            response._rowID = rowID;\n            response._rowTag = rowTag;\n            response._rowLength = rowLength;\n        }\n        function parseModel(response, json) {\n            return JSON.parse(json, response._fromJSON);\n        }\n        function createFromJSONCallback(response) {\n            // $FlowFixMe[missing-this-annot]\n            return function(key, value) {\n                if (typeof value === \"string\") {\n                    // We can't use .bind here because we need the \"this\" value.\n                    return parseModelString(response, this, key, value);\n                }\n                if (typeof value === \"object\" && value !== null) {\n                    return parseModelTuple(response, value);\n                }\n                return value;\n            };\n        }\n        function close(response) {\n            // In case there are any remaining unresolved chunks, they won't\n            // be resolved now. So we need to issue an error to those.\n            // Ideally we should be able to early bail out if we kept a\n            // ref count of pending chunks.\n            reportGlobalError(response, new Error(\"Connection closed.\"));\n        }\n        function createResponseFromOptions(options) {\n            return createResponse(null, null, options && options.callServer ? options.callServer : undefined, undefined // nonce\n            );\n        }\n        function startReadingFromStream(response, stream) {\n            var reader = stream.getReader();\n            function progress(_ref) {\n                var done = _ref.done, value = _ref.value;\n                if (done) {\n                    close(response);\n                    return;\n                }\n                var buffer = value;\n                processBinaryChunk(response, buffer);\n                return reader.read().then(progress).catch(error);\n            }\n            function error(e) {\n                reportGlobalError(response, e);\n            }\n            reader.read().then(progress).catch(error);\n        }\n        function createFromReadableStream(stream, options) {\n            var response = createResponseFromOptions(options);\n            startReadingFromStream(response, stream);\n            return getRoot(response);\n        }\n        function createFromFetch(promiseForResponse, options) {\n            var response = createResponseFromOptions(options);\n            promiseForResponse.then(function(r) {\n                startReadingFromStream(response, r.body);\n            }, function(e) {\n                reportGlobalError(response, e);\n            });\n            return getRoot(response);\n        }\n        function encodeReply(value) /* We don't use URLSearchParams yet but maybe */ {\n            return new Promise(function(resolve, reject) {\n                processReply(value, \"\", resolve, reject);\n            });\n        }\n        exports.createFromFetch = createFromFetch;\n        exports.createFromReadableStream = createFromReadableStream;\n        exports.createServerReference = createServerReference;\n        exports.encodeReply = encodeReply;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2Nqcy9yZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2stY2xpZW50LmJyb3dzZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUMsR0FFRDtBQUVBLElBQUlBLElBQXFDLEVBQUU7SUFDeEM7UUFDSDtRQUVBLElBQUlDLFdBQVdDLG1CQUFPQSxDQUFDO1FBQ3ZCLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDO1FBRXBCLGdGQUFnRjtRQUNoRixJQUFJRSxxQkFBcUI7UUFFekIsU0FBU0M7WUFDUCxPQUFPLElBQUlDO1FBQ2I7UUFDQSxJQUFJQyxpQkFBaUI7WUFDbkJDLFFBQVE7UUFDVjtRQUNBLFNBQVNDLHVCQUF1QkMsT0FBTyxFQUFFQyxNQUFNO1lBQzdDLE9BQU9ELFFBQVFFLE1BQU0sQ0FBQ0QsUUFBUUo7UUFDaEM7UUFDQSxTQUFTTSxxQkFBcUJILE9BQU8sRUFBRUMsTUFBTTtZQUMzQyxPQUFPRCxRQUFRRSxNQUFNLENBQUNEO1FBQ3hCO1FBRUEsaUVBQWlFO1FBQ2pFLCtDQUErQztRQUMvQyxJQUFJRyxLQUFLO1FBQ1QsSUFBSUMsU0FBUztRQUNiLElBQUlDLE9BQU8sR0FBRywwQkFBMEI7UUFDeEMsNEVBQTRFO1FBQzVFLDRFQUE0RTtRQUM1RSw0RUFBNEU7UUFDNUUsMENBQTBDO1FBRTFDLFNBQVNDLGNBQWNDLFFBQVE7WUFDN0IsT0FBT0EsU0FBU0MsTUFBTSxLQUFLO1FBQzdCO1FBRUEsU0FBU0MsdUJBQXVCQyxhQUFhLEVBQUVILFFBQVE7WUFDckQsSUFBSUcsZUFBZTtnQkFDakIsSUFBSUMsZ0JBQWdCRCxhQUFhLENBQUNILFFBQVEsQ0FBQ0osR0FBRyxDQUFDO2dCQUMvQyxJQUFJUyxxQkFBcUJELGFBQWEsQ0FBQ0osUUFBUSxDQUFDRixLQUFLLENBQUM7Z0JBQ3RELElBQUlRO2dC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WUFFQVAsT0FBT0ssSUFBSSxHQUFHbFosSUFBSSxDQUFDK1ksVUFBVUksS0FBSyxDQUFDdlU7UUFDckM7UUFFQSxTQUFTeVUseUJBQXlCOWEsTUFBTSxFQUFFOEUsT0FBTztZQUMvQyxJQUFJeU4sV0FBVzZILDBCQUEwQnRWO1lBQ3pDdVYsdUJBQXVCOUgsVUFBVXZTO1lBQ2pDLE9BQU84UyxRQUFRUDtRQUNqQjtRQUVBLFNBQVN3SSxnQkFBZ0JDLGtCQUFrQixFQUFFbFcsT0FBTztZQUNsRCxJQUFJeU4sV0FBVzZILDBCQUEwQnRWO1lBQ3pDa1csbUJBQW1CdlosSUFBSSxDQUFDLFNBQVV3WixDQUFDO2dCQUNqQ1osdUJBQXVCOUgsVUFBVTBJLEVBQUVDLElBQUk7WUFDekMsR0FBRyxTQUFVTCxDQUFDO2dCQUNabEcsa0JBQWtCcEMsVUFBVXNJO1lBQzlCO1lBQ0EsT0FBTy9ILFFBQVFQO1FBQ2pCO1FBRUEsU0FBUzRJLFlBQVl4WixLQUFLLEVBQzFCLDhDQUE4QztZQUU1QyxPQUFPLElBQUltQixRQUFRLFNBQVVILE9BQU8sRUFBRXdMLE1BQU07Z0JBQzFDSCxhQUFhck0sT0FBTyxJQUFJZ0IsU0FBU3dMO1lBQ25DO1FBQ0Y7UUFFQWlOLHVCQUF1QixHQUFHTDtRQUMxQkssZ0NBQWdDLEdBQUdOO1FBQ25DTSw2QkFBNkIsR0FBRzdLO1FBQ2hDNkssbUJBQW1CLEdBQUdEO0lBQ3BCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2pzL3JlYWN0LXNlcnZlci1kb20td2VicGFjay1jbGllbnQuYnJvd3Nlci5kZXZlbG9wbWVudC5qcz80MmVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LXNlcnZlci1kb20td2VicGFjay1jbGllbnQuYnJvd3Nlci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIGVuYWJsZUJpbmFyeUZsaWdodCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdEZWNvZGVyKCkge1xuICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCk7XG59XG52YXIgZGVjb2Rlck9wdGlvbnMgPSB7XG4gIHN0cmVhbTogdHJ1ZVxufTtcbmZ1bmN0aW9uIHJlYWRQYXJ0aWFsU3RyaW5nQ2h1bmsoZGVjb2RlciwgYnVmZmVyKSB7XG4gIHJldHVybiBkZWNvZGVyLmRlY29kZShidWZmZXIsIGRlY29kZXJPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlYWRGaW5hbFN0cmluZ0NodW5rKGRlY29kZXIsIGJ1ZmZlcikge1xuICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoYnVmZmVyKTtcbn1cblxuLy8gVGhpcyBpcyB0aGUgcGFyc2VkIHNoYXBlIG9mIHRoZSB3aXJlIGZvcm1hdCB3aGljaCBpcyB3aHkgaXQgaXNcbi8vIGNvbmRlbnNlZCB0byBvbmx5IHRoZSBlc3NlbnRpYWx5IGluZm9ybWF0aW9uXG52YXIgSUQgPSAwO1xudmFyIENIVU5LUyA9IDE7XG52YXIgTkFNRSA9IDI7IC8vIGV4cG9ydCBjb25zdCBBU1lOQyA9IDM7XG4vLyBUaGlzIGxvZ2ljIGlzIGNvcnJlY3QgYmVjYXVzZSBjdXJyZW50bHkgb25seSBpbmNsdWRlIHRoZSA0dGggdHVwbGUgbWVtYmVyXG4vLyB3aGVuIHRoZSBtb2R1bGUgaXMgYXN5bmMuIElmIHRoYXQgY2hhbmdlcyB3ZSB3aWxsIG5lZWQgdG8gYWN0dWFsbHkgYXNzZXJ0XG4vLyB0aGUgdmFsdWUgaXMgdHJ1ZS4gV2UgZG9uJ3QgaW5kZXggaW50byB0aGUgNHRoIHNsb3QgYmVjYXVzZSBmbG93IGRvZXMgbm90XG4vLyBsaWtlIHRoZSBwb3RlbnRpYWwgb3V0IG9mIGJvdW5kcyBhY2Nlc3NcblxuZnVuY3Rpb24gaXNBc3luY0ltcG9ydChtZXRhZGF0YSkge1xuICByZXR1cm4gbWV0YWRhdGEubGVuZ3RoID09PSA0O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlQ2xpZW50UmVmZXJlbmNlKGJ1bmRsZXJDb25maWcsIG1ldGFkYXRhKSB7XG4gIGlmIChidW5kbGVyQ29uZmlnKSB7XG4gICAgdmFyIG1vZHVsZUV4cG9ydHMgPSBidW5kbGVyQ29uZmlnW21ldGFkYXRhW0lEXV07XG4gICAgdmFyIHJlc29sdmVkTW9kdWxlRGF0YSA9IG1vZHVsZUV4cG9ydHNbbWV0YWRhdGFbTkFNRV1dO1xuICAgIHZhciBuYW1lO1xuXG4gICAgaWYgKHJlc29sdmVkTW9kdWxlRGF0YSkge1xuICAgICAgLy8gVGhlIHBvdGVudGlhbGx5IGFsaWFzZWQgbmFtZS5cbiAgICAgIG5hbWUgPSByZXNvbHZlZE1vZHVsZURhdGEubmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSB0aGlzIHNwZWNpZmljIG5hbWUsIHdlIG1pZ2h0IGhhdmUgdGhlIGZ1bGwgbW9kdWxlLlxuICAgICAgcmVzb2x2ZWRNb2R1bGVEYXRhID0gbW9kdWxlRXhwb3J0c1snKiddO1xuXG4gICAgICBpZiAoIXJlc29sdmVkTW9kdWxlRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHRoZSBtb2R1bGUgXCInICsgbWV0YWRhdGFbSURdICsgJ1wiIGluIHRoZSBSZWFjdCBTU1IgTWFuaWZlc3QuICcgKyAnVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiB0aGUgUmVhY3QgU2VydmVyIENvbXBvbmVudHMgYnVuZGxlci4nKTtcbiAgICAgIH1cblxuICAgICAgbmFtZSA9IG1ldGFkYXRhW05BTUVdO1xuICAgIH1cblxuICAgIGlmIChpc0FzeW5jSW1wb3J0KG1ldGFkYXRhKSkge1xuICAgICAgcmV0dXJuIFtyZXNvbHZlZE1vZHVsZURhdGEuaWQsIHJlc29sdmVkTW9kdWxlRGF0YS5jaHVua3MsIG5hbWUsIDFcbiAgICAgIC8qIGFzeW5jICovXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3Jlc29sdmVkTW9kdWxlRGF0YS5pZCwgcmVzb2x2ZWRNb2R1bGVEYXRhLmNodW5rcywgbmFtZV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1ldGFkYXRhO1xufVxuLy8gSWYgdGhleSdyZSBzdGlsbCBwZW5kaW5nIHRoZXkncmUgYSB0aGVuYWJsZS4gVGhpcyBtYXAgYWxzbyBleGlzdHNcbi8vIGluIFdlYnBhY2sgYnV0IHVuZm9ydHVuYXRlbHkgaXQncyBub3QgZXhwb3NlZCBzbyB3ZSBoYXZlIHRvXG4vLyByZXBsaWNhdGUgaXQgaW4gdXNlciBzcGFjZS4gbnVsbCBtZWFucyB0aGF0IGl0IGhhcyBhbHJlYWR5IGxvYWRlZC5cblxudmFyIGNodW5rQ2FjaGUgPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVBc3luY01vZHVsZShpZCkge1xuICAvLyBXZSd2ZSBhbHJlYWR5IGxvYWRlZCBhbGwgdGhlIGNodW5rcy4gV2UgY2FuIHJlcXVpcmUgdGhlIG1vZHVsZS5cbiAgdmFyIHByb21pc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcblxuICBpZiAodHlwZW9mIHByb21pc2UudGhlbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRoaXMgd2Fzbid0IGEgcHJvbWlzZSBhZnRlciBhbGwuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XG4gICAgLy8gVGhpcyBtb2R1bGUgd2FzIGFscmVhZHkgcmVzb2x2ZWQgZWFybGllci5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBJbnN0cnVtZW50IHRoZSBQcm9taXNlIHRvIHN0YXNoIHRoZSByZXN1bHQuXG4gICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gcHJvbWlzZTtcbiAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnN0YXR1cyA9ICdmdWxmaWxsZWQnO1xuICAgICAgZnVsZmlsbGVkVGhlbmFibGUudmFsdWUgPSB2YWx1ZTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICB2YXIgcmVqZWN0ZWRUaGVuYWJsZSA9IHByb21pc2U7XG4gICAgICByZWplY3RlZFRoZW5hYmxlLnN0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgICByZWplY3RlZFRoZW5hYmxlLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpZ25vcmVSZWplY3QoKSB7Ly8gV2UgcmVseSBvbiByZWplY3RlZCBwcm9taXNlcyB0byBiZSBoYW5kbGVkIGJ5IGFub3RoZXIgbGlzdGVuZXIuXG59IC8vIFN0YXJ0IHByZWxvYWRpbmcgdGhlIG1vZHVsZXMgc2luY2Ugd2UgbWlnaHQgbmVlZCB0aGVtIHNvb24uXG4vLyBUaGlzIGZ1bmN0aW9uIGRvZXNuJ3Qgc3VzcGVuZC5cblxuXG5mdW5jdGlvbiBwcmVsb2FkTW9kdWxlKG1ldGFkYXRhKSB7XG4gIHZhciBjaHVua3MgPSBtZXRhZGF0YVtDSFVOS1NdO1xuICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgY2h1bmtzLmxlbmd0aCkge1xuICAgIHZhciBjaHVua0lkID0gY2h1bmtzW2krK107XG4gICAgdmFyIGNodW5rRmlsZW5hbWUgPSBjaHVua3NbaSsrXTtcbiAgICB2YXIgZW50cnkgPSBjaHVua0NhY2hlLmdldChjaHVua0lkKTtcblxuICAgIGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgdGhlbmFibGUgPSBsb2FkQ2h1bmsoY2h1bmtJZCwgY2h1bmtGaWxlbmFtZSk7XG4gICAgICBwcm9taXNlcy5wdXNoKHRoZW5hYmxlKTsgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuXG4gICAgICB2YXIgcmVzb2x2ZSA9IGNodW5rQ2FjaGUuc2V0LmJpbmQoY2h1bmtDYWNoZSwgY2h1bmtJZCwgbnVsbCk7XG4gICAgICB0aGVuYWJsZS50aGVuKHJlc29sdmUsIGlnbm9yZVJlamVjdCk7XG4gICAgICBjaHVua0NhY2hlLnNldChjaHVua0lkLCB0aGVuYWJsZSk7XG4gICAgfSBlbHNlIGlmIChlbnRyeSAhPT0gbnVsbCkge1xuICAgICAgcHJvbWlzZXMucHVzaChlbnRyeSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzQXN5bmNJbXBvcnQobWV0YWRhdGEpKSB7XG4gICAgaWYgKHByb21pc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHJlcXVpcmVBc3luY01vZHVsZShtZXRhZGF0YVtJRF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZUFzeW5jTW9kdWxlKG1ldGFkYXRhW0lEXSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvbWlzZXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0gLy8gQWN0dWFsbHkgcmVxdWlyZSB0aGUgbW9kdWxlIG9yIHN1c3BlbmQgaWYgaXQncyBub3QgeWV0IHJlYWR5LlxuLy8gSW5jcmVhc2UgcHJpb3JpdHkgaWYgbmVjZXNzYXJ5LlxuXG5mdW5jdGlvbiByZXF1aXJlTW9kdWxlKG1ldGFkYXRhKSB7XG4gIHZhciBtb2R1bGVFeHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhtZXRhZGF0YVtJRF0pO1xuXG4gIGlmIChpc0FzeW5jSW1wb3J0KG1ldGFkYXRhKSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlRXhwb3J0cy50aGVuICE9PSAnZnVuY3Rpb24nKSA7IGVsc2UgaWYgKG1vZHVsZUV4cG9ydHMuc3RhdHVzID09PSAnZnVsZmlsbGVkJykge1xuICAgICAgLy8gVGhpcyBQcm9taXNlIHNob3VsZCd2ZSBiZWVuIGluc3RydW1lbnRlZCBieSBwcmVsb2FkTW9kdWxlLlxuICAgICAgbW9kdWxlRXhwb3J0cyA9IG1vZHVsZUV4cG9ydHMudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG1vZHVsZUV4cG9ydHMucmVhc29uO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtZXRhZGF0YVtOQU1FXSA9PT0gJyonKSB7XG4gICAgLy8gVGhpcyBpcyBhIHBsYWNlaG9sZGVyIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGF0IHRoZSBjYWxsZXIgaW1wb3J0ZWQgdGhpc1xuICAgIC8vIGFzIGEgQ29tbW9uSlMgbW9kdWxlIGFzIGlzLlxuICAgIHJldHVybiBtb2R1bGVFeHBvcnRzO1xuICB9XG5cbiAgaWYgKG1ldGFkYXRhW05BTUVdID09PSAnJykge1xuICAgIC8vIFRoaXMgaXMgYSBwbGFjZWhvbGRlciB2YWx1ZSB0aGF0IHJlcHJlc2VudHMgdGhhdCB0aGUgY2FsbGVyIGFjY2Vzc2VkIHRoZVxuICAgIC8vIGRlZmF1bHQgcHJvcGVydHkgb2YgdGhpcyBpZiBpdCB3YXMgYW4gRVNNIGludGVyb3AgbW9kdWxlLlxuICAgIHJldHVybiBtb2R1bGVFeHBvcnRzLl9fZXNNb2R1bGUgPyBtb2R1bGVFeHBvcnRzLmRlZmF1bHQgOiBtb2R1bGVFeHBvcnRzO1xuICB9XG5cbiAgcmV0dXJuIG1vZHVsZUV4cG9ydHNbbWV0YWRhdGFbTkFNRV1dO1xufVxuXG52YXIgY2h1bmtNYXAgPSBuZXcgTWFwKCk7XG4vKipcbiAqIFdlIHBhdGNoIHRoZSBjaHVuayBmaWxlbmFtZSBmdW5jdGlvbiBpbiB3ZWJwYWNrIHRvIGluc2VydCBvdXIgb3duIHJlc29sdXRpb25cbiAqIG9mIGNodW5rcyB0aGF0IGNvbWUgZnJvbSBGbGlnaHQgYW5kIG1heSBub3QgYmUga25vd24gdG8gdGhlIHdlYnBhY2sgcnVudGltZVxuICovXG5cbnZhciB3ZWJwYWNrR2V0Q2h1bmtGaWxlbmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18udTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXy51ID0gZnVuY3Rpb24gKGNodW5rSWQpIHtcbiAgdmFyIGZsaWdodENodW5rID0gY2h1bmtNYXAuZ2V0KGNodW5rSWQpO1xuXG4gIGlmIChmbGlnaHRDaHVuayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZsaWdodENodW5rO1xuICB9XG5cbiAgcmV0dXJuIHdlYnBhY2tHZXRDaHVua0ZpbGVuYW1lKGNodW5rSWQpO1xufTtcblxuZnVuY3Rpb24gbG9hZENodW5rKGNodW5rSWQsIGZpbGVuYW1lKSB7XG4gIGNodW5rTWFwLnNldChjaHVua0lkLCBmaWxlbmFtZSk7XG4gIHJldHVybiBfX3dlYnBhY2tfY2h1bmtfbG9hZF9fKGNodW5rSWQpO1xufVxuXG52YXIgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMgPSBSZWFjdERPTS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuLy8gVGhpcyBjbGllbnQgZmlsZSBpcyBpbiB0aGUgc2hhcmVkIGZvbGRlciBiZWNhdXNlIGl0IGFwcGxpZXMgdG8gYm90aCBTU1IgYW5kIGJyb3dzZXIgY29udGV4dHMuXG52YXIgUmVhY3RET01DdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLkRpc3BhdGNoZXI7XG5mdW5jdGlvbiBkaXNwYXRjaEhpbnQoY29kZSwgbW9kZWwpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdERPTUN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG5cbiAgaWYgKGRpc3BhdGNoZXIpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgJ0QnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHJlZmluZWQgPSByZWZpbmVNb2RlbChjb2RlLCBtb2RlbCk7XG4gICAgICAgICAgdmFyIGhyZWYgPSByZWZpbmVkO1xuICAgICAgICAgIGRpc3BhdGNoZXIucHJlZmV0Y2hETlMoaHJlZik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ0MnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9yZWZpbmVkID0gcmVmaW5lTW9kZWwoY29kZSwgbW9kZWwpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBfcmVmaW5lZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBfaHJlZiA9IF9yZWZpbmVkO1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5wcmVjb25uZWN0KF9ocmVmKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9ocmVmMiA9IF9yZWZpbmVkWzBdO1xuICAgICAgICAgICAgdmFyIGNyb3NzT3JpZ2luID0gX3JlZmluZWRbMV07XG4gICAgICAgICAgICBkaXNwYXRjaGVyLnByZWNvbm5lY3QoX2hyZWYyLCBjcm9zc09yaWdpbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ0wnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9yZWZpbmVkMiA9IHJlZmluZU1vZGVsKGNvZGUsIG1vZGVsKTtcblxuICAgICAgICAgIHZhciBfaHJlZjMgPSBfcmVmaW5lZDJbMF07XG4gICAgICAgICAgdmFyIGFzID0gX3JlZmluZWQyWzFdO1xuXG4gICAgICAgICAgaWYgKF9yZWZpbmVkMi5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gX3JlZmluZWQyWzJdO1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5wcmVsb2FkKF9ocmVmMywgYXMsIG9wdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLnByZWxvYWQoX2hyZWYzLCBhcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ20nOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9yZWZpbmVkMyA9IHJlZmluZU1vZGVsKGNvZGUsIG1vZGVsKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgX3JlZmluZWQzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIF9ocmVmNCA9IF9yZWZpbmVkMztcbiAgICAgICAgICAgIGRpc3BhdGNoZXIucHJlbG9hZE1vZHVsZShfaHJlZjQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX2hyZWY1ID0gX3JlZmluZWQzWzBdO1xuICAgICAgICAgICAgdmFyIF9vcHRpb25zID0gX3JlZmluZWQzWzFdO1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5wcmVsb2FkTW9kdWxlKF9ocmVmNSwgX29wdGlvbnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdTJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfcmVmaW5lZDQgPSByZWZpbmVNb2RlbChjb2RlLCBtb2RlbCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIF9yZWZpbmVkNCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBfaHJlZjYgPSBfcmVmaW5lZDQ7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLnByZWluaXRTdHlsZShfaHJlZjYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX2hyZWY3ID0gX3JlZmluZWQ0WzBdO1xuICAgICAgICAgICAgdmFyIHByZWNlZGVuY2UgPSBfcmVmaW5lZDRbMV0gPT09IDAgPyB1bmRlZmluZWQgOiBfcmVmaW5lZDRbMV07XG5cbiAgICAgICAgICAgIHZhciBfb3B0aW9uczIgPSBfcmVmaW5lZDQubGVuZ3RoID09PSAzID8gX3JlZmluZWQ0WzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBkaXNwYXRjaGVyLnByZWluaXRTdHlsZShfaHJlZjcsIHByZWNlZGVuY2UsIF9vcHRpb25zMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ1gnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9yZWZpbmVkNSA9IHJlZmluZU1vZGVsKGNvZGUsIG1vZGVsKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgX3JlZmluZWQ1ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIF9ocmVmOCA9IF9yZWZpbmVkNTtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIucHJlaW5pdFNjcmlwdChfaHJlZjgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX2hyZWY5ID0gX3JlZmluZWQ1WzBdO1xuICAgICAgICAgICAgdmFyIF9vcHRpb25zMyA9IF9yZWZpbmVkNVsxXTtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIucHJlaW5pdFNjcmlwdChfaHJlZjksIF9vcHRpb25zMyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ00nOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9yZWZpbmVkNiA9IHJlZmluZU1vZGVsKGNvZGUsIG1vZGVsKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgX3JlZmluZWQ2ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIF9ocmVmMTAgPSBfcmVmaW5lZDY7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLnByZWluaXRNb2R1bGVTY3JpcHQoX2hyZWYxMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfaHJlZjExID0gX3JlZmluZWQ2WzBdO1xuICAgICAgICAgICAgdmFyIF9vcHRpb25zNCA9IF9yZWZpbmVkNlsxXTtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIucHJlaW5pdE1vZHVsZVNjcmlwdChfaHJlZjExLCBfb3B0aW9uczQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBGbG93IGlzIGhhdmluZyB0cm91YmxlIHJlZmluaW5nIHRoZSBIaW50TW9kZWxzIHNvIHdlIGhlbHAgaXQgYSBiaXQuXG4vLyBUaGlzIHNob3VsZCBiZSBjb21waWxlZCBvdXQgaW4gdGhlIHByb2R1Y3Rpb24gYnVpbGQuXG5cbmZ1bmN0aW9uIHJlZmluZU1vZGVsKGNvZGUsIG1vZGVsKSB7XG4gIHJldHVybiBtb2RlbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNlcnZlcl9jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEID0gU3ltYm9sLmZvcigncmVhY3QuZGVmYXVsdF92YWx1ZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuLy8gaW4gY2FzZSB0aGV5IGVycm9yLlxuXG52YXIganN4UHJvcHNQYXJlbnRzID0gbmV3IFdlYWtNYXAoKTtcbnZhciBqc3hDaGlsZHJlblBhcmVudHMgPSBuZXcgV2Vha01hcCgpO1xuXG5mdW5jdGlvbiBpc09iamVjdFByb3RvdHlwZShvYmplY3QpIHtcbiAgaWYgKCFvYmplY3QpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICBpZiAob2JqZWN0ID09PSBPYmplY3RQcm90b3R5cGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJdCBtaWdodCBiZSBhbiBvYmplY3QgZnJvbSBhIGRpZmZlcmVudCBSZWFsbSB3aGljaCBpc1xuICAvLyBzdGlsbCBqdXN0IGEgcGxhaW4gc2ltcGxlIG9iamVjdC5cblxuXG4gIGlmIChnZXRQcm90b3R5cGVPZihvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCEobmFtZXNbaV0gaW4gT2JqZWN0UHJvdG90eXBlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1NpbXBsZU9iamVjdChvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdFByb3RvdHlwZShnZXRQcm90b3R5cGVPZihvYmplY3QpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIG5hbWVzW2ldKTtcblxuICAgIGlmICghZGVzY3JpcHRvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoKG5hbWVzW2ldID09PSAna2V5JyB8fCBuYW1lc1tpXSA9PT0gJ3JlZicpICYmIHR5cGVvZiBkZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBSZWFjdCBhZGRzIGtleSBhbmQgcmVmIGdldHRlcnMgdG8gcHJvcHMgb2JqZWN0cyB0byBpc3N1ZSB3YXJuaW5ncy5cbiAgICAgICAgLy8gVGhvc2UgZ2V0dGVycyB3aWxsIG5vdCBiZSB0cmFuc2ZlcnJlZCB0byB0aGUgY2xpZW50LCBidXQgdGhhdCdzIG9rLFxuICAgICAgICAvLyBzbyB3ZSdsbCBzcGVjaWFsIGNhc2UgdGhlbS5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG9iamVjdE5hbWUob2JqZWN0KSB7XG4gIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgdmFyIG5hbWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KTtcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSgvXlxcW29iamVjdCAoLiopXFxdJC8sIGZ1bmN0aW9uIChtLCBwMCkge1xuICAgIHJldHVybiBwMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlS2V5Rm9yRXJyb3JNZXNzYWdlKGtleSkge1xuICB2YXIgZW5jb2RlZEtleSA9IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gIHJldHVybiAnXCInICsga2V5ICsgJ1wiJyA9PT0gZW5jb2RlZEtleSA/IGtleSA6IGVuY29kZWRLZXk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UodmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUubGVuZ3RoIDw9IDEwID8gdmFsdWUgOiB2YWx1ZS5zbGljZSgwLCAxMCkgKyAnLi4uJyk7XG4gICAgICB9XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAge1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gJ1suLi5dJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYW1lID0gb2JqZWN0TmFtZSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgcmV0dXJuICd7Li4ufSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiAnZnVuY3Rpb24nO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZUVsZW1lbnRUeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKG9iamVjdE9yQXJyYXksIGV4cGFuZGVkTmFtZSkge1xuICB2YXIgb2JqS2luZCA9IG9iamVjdE5hbWUob2JqZWN0T3JBcnJheSk7XG5cbiAgaWYgKG9iaktpbmQgIT09ICdPYmplY3QnICYmIG9iaktpbmQgIT09ICdBcnJheScpIHtcbiAgICByZXR1cm4gb2JqS2luZDtcbiAgfVxuXG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIHN0YXJ0ID0gLTE7XG4gIHZhciBsZW5ndGggPSAwO1xuXG4gIGlmIChpc0FycmF5KG9iamVjdE9yQXJyYXkpKSB7XG4gICAgaWYgKGpzeENoaWxkcmVuUGFyZW50cy5oYXMob2JqZWN0T3JBcnJheSkpIHtcbiAgICAgIC8vIFByaW50IEpTWCBDaGlsZHJlblxuICAgICAgdmFyIHR5cGUgPSBqc3hDaGlsZHJlblBhcmVudHMuZ2V0KG9iamVjdE9yQXJyYXkpO1xuICAgICAgc3RyID0gJzwnICsgZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlKSArICc+JztcbiAgICAgIHZhciBhcnJheSA9IG9iamVjdE9yQXJyYXk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV07XG4gICAgICAgIHZhciBzdWJzdHIgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBzdWJzdHIgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgc3Vic3RyID0gJ3snICsgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgJ30nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1YnN0ciA9ICd7JyArIGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgJ30nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCcnICsgaSA9PT0gZXhwYW5kZWROYW1lKSB7XG4gICAgICAgICAgc3RhcnQgPSBzdHIubGVuZ3RoO1xuICAgICAgICAgIGxlbmd0aCA9IHN1YnN0ci5sZW5ndGg7XG4gICAgICAgICAgc3RyICs9IHN1YnN0cjtcbiAgICAgICAgfSBlbHNlIGlmIChzdWJzdHIubGVuZ3RoIDwgMTUgJiYgc3RyLmxlbmd0aCArIHN1YnN0ci5sZW5ndGggPCA0MCkge1xuICAgICAgICAgIHN0ciArPSBzdWJzdHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyICs9ICd7Li4ufSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RyICs9ICc8LycgKyBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUpICsgJz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQcmludCBBcnJheVxuICAgICAgc3RyID0gJ1snO1xuICAgICAgdmFyIF9hcnJheSA9IG9iamVjdE9yQXJyYXk7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfYXJyYXkubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGlmIChfaSA+IDApIHtcbiAgICAgICAgICBzdHIgKz0gJywgJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfdmFsdWUgPSBfYXJyYXlbX2ldO1xuXG4gICAgICAgIHZhciBfc3Vic3RyID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgX3ZhbHVlID09PSAnb2JqZWN0JyAmJiBfdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICBfc3Vic3RyID0gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfc3Vic3RyID0gZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZShfdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCcnICsgX2kgPT09IGV4cGFuZGVkTmFtZSkge1xuICAgICAgICAgIHN0YXJ0ID0gc3RyLmxlbmd0aDtcbiAgICAgICAgICBsZW5ndGggPSBfc3Vic3RyLmxlbmd0aDtcbiAgICAgICAgICBzdHIgKz0gX3N1YnN0cjtcbiAgICAgICAgfSBlbHNlIGlmIChfc3Vic3RyLmxlbmd0aCA8IDEwICYmIHN0ci5sZW5ndGggKyBfc3Vic3RyLmxlbmd0aCA8IDQwKSB7XG4gICAgICAgICAgc3RyICs9IF9zdWJzdHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyICs9ICcuLi4nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0ciArPSAnXSc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChvYmplY3RPckFycmF5LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIHN0ciA9ICc8JyArIGRlc2NyaWJlRWxlbWVudFR5cGUob2JqZWN0T3JBcnJheS50eXBlKSArICcvPic7XG4gICAgfSBlbHNlIGlmIChqc3hQcm9wc1BhcmVudHMuaGFzKG9iamVjdE9yQXJyYXkpKSB7XG4gICAgICAvLyBQcmludCBKU1hcbiAgICAgIHZhciBfdHlwZSA9IGpzeFByb3BzUGFyZW50cy5nZXQob2JqZWN0T3JBcnJheSk7XG5cbiAgICAgIHN0ciA9ICc8JyArIChkZXNjcmliZUVsZW1lbnRUeXBlKF90eXBlKSB8fCAnLi4uJyk7XG4gICAgICB2YXIgb2JqZWN0ID0gb2JqZWN0T3JBcnJheTtcbiAgICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5hbWVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgc3RyICs9ICcgJztcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tfaTJdO1xuICAgICAgICBzdHIgKz0gZGVzY3JpYmVLZXlGb3JFcnJvck1lc3NhZ2UobmFtZSkgKyAnPSc7XG4gICAgICAgIHZhciBfdmFsdWUyID0gb2JqZWN0W25hbWVdO1xuXG4gICAgICAgIHZhciBfc3Vic3RyMiA9IHZvaWQgMDtcblxuICAgICAgICBpZiAobmFtZSA9PT0gZXhwYW5kZWROYW1lICYmIHR5cGVvZiBfdmFsdWUyID09PSAnb2JqZWN0JyAmJiBfdmFsdWUyICE9PSBudWxsKSB7XG4gICAgICAgICAgX3N1YnN0cjIgPSBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShfdmFsdWUyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfc3Vic3RyMiA9IGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIF92YWx1ZTIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgX3N1YnN0cjIgPSAneycgKyBfc3Vic3RyMiArICd9JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lID09PSBleHBhbmRlZE5hbWUpIHtcbiAgICAgICAgICBzdGFydCA9IHN0ci5sZW5ndGg7XG4gICAgICAgICAgbGVuZ3RoID0gX3N1YnN0cjIubGVuZ3RoO1xuICAgICAgICAgIHN0ciArPSBfc3Vic3RyMjtcbiAgICAgICAgfSBlbHNlIGlmIChfc3Vic3RyMi5sZW5ndGggPCAxMCAmJiBzdHIubGVuZ3RoICsgX3N1YnN0cjIubGVuZ3RoIDwgNDApIHtcbiAgICAgICAgICBzdHIgKz0gX3N1YnN0cjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyICs9ICcuLi4nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0ciArPSAnPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFByaW50IE9iamVjdFxuICAgICAgc3RyID0gJ3snO1xuICAgICAgdmFyIF9vYmplY3QgPSBvYmplY3RPckFycmF5O1xuXG4gICAgICB2YXIgX25hbWVzID0gT2JqZWN0LmtleXMoX29iamVjdCk7XG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IF9uYW1lcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgIGlmIChfaTMgPiAwKSB7XG4gICAgICAgICAgc3RyICs9ICcsICc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX25hbWUgPSBfbmFtZXNbX2kzXTtcbiAgICAgICAgc3RyICs9IGRlc2NyaWJlS2V5Rm9yRXJyb3JNZXNzYWdlKF9uYW1lKSArICc6ICc7XG4gICAgICAgIHZhciBfdmFsdWUzID0gX29iamVjdFtfbmFtZV07XG5cbiAgICAgICAgdmFyIF9zdWJzdHIzID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgX3ZhbHVlMyA9PT0gJ29iamVjdCcgJiYgX3ZhbHVlMyAhPT0gbnVsbCkge1xuICAgICAgICAgIF9zdWJzdHIzID0gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3N1YnN0cjMgPSBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKF92YWx1ZTMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9uYW1lID09PSBleHBhbmRlZE5hbWUpIHtcbiAgICAgICAgICBzdGFydCA9IHN0ci5sZW5ndGg7XG4gICAgICAgICAgbGVuZ3RoID0gX3N1YnN0cjMubGVuZ3RoO1xuICAgICAgICAgIHN0ciArPSBfc3Vic3RyMztcbiAgICAgICAgfSBlbHNlIGlmIChfc3Vic3RyMy5sZW5ndGggPCAxMCAmJiBzdHIubGVuZ3RoICsgX3N1YnN0cjMubGVuZ3RoIDwgNDApIHtcbiAgICAgICAgICBzdHIgKz0gX3N1YnN0cjM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyICs9ICcuLi4nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0ciArPSAnfSc7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cGFuZGVkTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmIChzdGFydCA+IC0xICYmIGxlbmd0aCA+IDApIHtcbiAgICB2YXIgaGlnaGxpZ2h0ID0gJyAnLnJlcGVhdChzdGFydCkgKyAnXicucmVwZWF0KGxlbmd0aCk7XG4gICAgcmV0dXJuICdcXG4gICcgKyBzdHIgKyAnXFxuICAnICsgaGlnaGxpZ2h0O1xuICB9XG5cbiAgcmV0dXJuICdcXG4gICcgKyBzdHI7XG59XG5cbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIGtub3duU2VydmVyUmVmZXJlbmNlcyA9IG5ldyBXZWFrTWFwKCk7IC8vIFNlcmlhbGl6YWJsZSB2YWx1ZXNcbi8vIFRoZW5hYmxlPFJlYWN0U2VydmVyVmFsdWU+XG4vLyBmdW5jdGlvbiBzZXJpYWxpemVCeVZhbHVlSUQoaWQ6IG51bWJlcik6IHN0cmluZyB7XG4vLyAgIHJldHVybiAnJCcgKyBpZC50b1N0cmluZygxNik7XG4vLyB9XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVByb21pc2VJRChpZCkge1xuICByZXR1cm4gJyRAJyArIGlkLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplU2VydmVyUmVmZXJlbmNlSUQoaWQpIHtcbiAgcmV0dXJuICckRicgKyBpZC50b1N0cmluZygxNik7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVN5bWJvbFJlZmVyZW5jZShuYW1lKSB7XG4gIHJldHVybiAnJFMnICsgbmFtZTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplRm9ybURhdGFSZWZlcmVuY2UoaWQpIHtcbiAgLy8gV2h5IEs/IEYgaXMgXCJGdW5jdGlvblwiLiBEIGlzIFwiRGF0ZVwiLiBXaGF0IGVsc2U/XG4gIHJldHVybiAnJEsnICsgaWQudG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVOdW1iZXIobnVtYmVyKSB7XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUobnVtYmVyKSkge1xuICAgIGlmIChudW1iZXIgPT09IDAgJiYgMSAvIG51bWJlciA9PT0gLUluZmluaXR5KSB7XG4gICAgICByZXR1cm4gJyQtMCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChudW1iZXIgPT09IEluZmluaXR5KSB7XG4gICAgICByZXR1cm4gJyRJbmZpbml0eSc7XG4gICAgfSBlbHNlIGlmIChudW1iZXIgPT09IC1JbmZpbml0eSkge1xuICAgICAgcmV0dXJuICckLUluZmluaXR5JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICckTmFOJztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplVW5kZWZpbmVkKCkge1xuICByZXR1cm4gJyR1bmRlZmluZWQnO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVEYXRlRnJvbURhdGVKU09OKGRhdGVKU09OKSB7XG4gIC8vIEpTT04uc3RyaW5naWZ5IGF1dG9tYXRpY2FsbHkgY2FsbHMgRGF0ZS5wcm90b3R5cGUudG9KU09OIHdoaWNoIGNhbGxzIHRvSVNPU3RyaW5nLlxuICAvLyBXZSBuZWVkIG9ubHkgdGFjayBvbiBhICREIHByZWZpeC5cbiAgcmV0dXJuICckRCcgKyBkYXRlSlNPTjtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplQmlnSW50KG4pIHtcbiAgcmV0dXJuICckbicgKyBuLnRvU3RyaW5nKDEwKTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplTWFwSUQoaWQpIHtcbiAgcmV0dXJuICckUScgKyBpZC50b1N0cmluZygxNik7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVNldElEKGlkKSB7XG4gIHJldHVybiAnJFcnICsgaWQudG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmdWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWVbMF0gPT09ICckJykge1xuICAgIC8vIFdlIG5lZWQgdG8gZXNjYXBlICQgcHJlZml4ZWQgc3RyaW5ncyBzaW5jZSB3ZSB1c2UgdGhvc2UgdG8gZW5jb2RlXG4gICAgLy8gcmVmZXJlbmNlcyB0byBJRHMgYW5kIGFzIHNwZWNpYWwgc3ltYm9sIHZhbHVlcy5cbiAgICByZXR1cm4gJyQnICsgdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZXBseShyb290LCBmb3JtRmllbGRQcmVmaXgsIHJlc29sdmUsIHJlamVjdCkge1xuICB2YXIgbmV4dFBhcnRJZCA9IDE7XG4gIHZhciBwZW5kaW5nUGFydHMgPSAwO1xuICB2YXIgZm9ybURhdGEgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVUb0pTT04oa2V5LCB2YWx1ZSkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzOyAvLyBNYWtlIHN1cmUgdGhhdCBgcGFyZW50W2tleV1gIHdhc24ndCBKU09OaWZpZWQgYmVmb3JlIGB2YWx1ZWAgd2FzIHBhc3NlZCB0byB1c1xuXG4gICAge1xuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXVxuICAgICAgdmFyIG9yaWdpbmFsVmFsdWUgPSBwYXJlbnRba2V5XTtcblxuICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbFZhbHVlID09PSAnb2JqZWN0JyAmJiBvcmlnaW5hbFZhbHVlICE9PSB2YWx1ZSAmJiAhKG9yaWdpbmFsVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICBpZiAob2JqZWN0TmFtZShvcmlnaW5hbFZhbHVlKSAhPT0gJ09iamVjdCcpIHtcbiAgICAgICAgICBlcnJvcignT25seSBwbGFpbiBvYmplY3RzIGNhbiBiZSBwYXNzZWQgdG8gU2VydmVyIEZ1bmN0aW9ucyBmcm9tIHRoZSBDbGllbnQuICcgKyAnJXMgb2JqZWN0cyBhcmUgbm90IHN1cHBvcnRlZC4lcycsIG9iamVjdE5hbWUob3JpZ2luYWxWYWx1ZSksIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHBhcmVudCwga2V5KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IoJ09ubHkgcGxhaW4gb2JqZWN0cyBjYW4gYmUgcGFzc2VkIHRvIFNlcnZlciBGdW5jdGlvbnMgZnJvbSB0aGUgQ2xpZW50LiAnICsgJ09iamVjdHMgd2l0aCB0b0pTT04gbWV0aG9kcyBhcmUgbm90IHN1cHBvcnRlZC4gQ29udmVydCBpdCBtYW51YWxseSAnICsgJ3RvIGEgc2ltcGxlIHZhbHVlIGJlZm9yZSBwYXNzaW5nIGl0IHRvIHByb3BzLiVzJywgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UocGFyZW50LCBrZXkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBhbnkgb2JqZWN0IHdpdGggYSAudGhlbiBwcm9wZXJ0eSBpcyBhIFwiVGhlbmFibGVcIiB0eXBlLFxuICAgICAgICAvLyBvciBhIFByb21pc2UgdHlwZS4gRWl0aGVyIG9mIHdoaWNoIGNhbiBiZSByZXByZXNlbnRlZCBieSBhIFByb21pc2UuXG4gICAgICAgIGlmIChmb3JtRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFVwZ3JhZGUgdG8gdXNlIEZvcm1EYXRhIHRvIGFsbG93IHVzIHRvIHN0cmVhbSB0aGlzIHZhbHVlLlxuICAgICAgICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIH1cblxuICAgICAgICBwZW5kaW5nUGFydHMrKztcbiAgICAgICAgdmFyIHByb21pc2VJZCA9IG5leHRQYXJ0SWQrKztcbiAgICAgICAgdmFyIHRoZW5hYmxlID0gdmFsdWU7XG4gICAgICAgIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKHBhcnRWYWx1ZSkge1xuICAgICAgICAgIHZhciBwYXJ0SlNPTiA9IEpTT04uc3RyaW5naWZ5KHBhcnRWYWx1ZSwgcmVzb2x2ZVRvSlNPTik7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIFdlIGtub3cgaXQncyBub3QgbnVsbCBiZWNhdXNlIHdlIGFzc2lnbmVkIGl0IGFib3ZlLlxuXG4gICAgICAgICAgdmFyIGRhdGEgPSBmb3JtRGF0YTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cbiAgICAgICAgICBkYXRhLmFwcGVuZChmb3JtRmllbGRQcmVmaXggKyBwcm9taXNlSWQsIHBhcnRKU09OKTtcbiAgICAgICAgICBwZW5kaW5nUGFydHMtLTtcblxuICAgICAgICAgIGlmIChwZW5kaW5nUGFydHMgPT09IDApIHtcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgLy8gSW4gdGhlIGZ1dHVyZSB3ZSBjb3VsZCBjb25zaWRlciBzZXJpYWxpemluZyB0aGlzIGFzIGFuIGVycm9yXG4gICAgICAgICAgLy8gdGhhdCB0aHJvd3Mgb24gdGhlIHNlcnZlciBpbnN0ZWFkLlxuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVByb21pc2VJRChwcm9taXNlSWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IC8vIFRPRE86IFNob3VsZCB3ZSB0aGUgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCkgdG8gdGVzdCBmb3IgY3Jvc3MtcmVhbG0gb2JqZWN0cz9cblxuXG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICBpZiAoZm9ybURhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBVcGdyYWRlIHRvIHVzZSBGb3JtRGF0YSB0byBhbGxvdyB1cyB0byB1c2UgcmljaCBvYmplY3RzIGFzIGl0cyB2YWx1ZXMuXG4gICAgICAgICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhID0gZm9ybURhdGE7XG4gICAgICAgIHZhciByZWZJZCA9IG5leHRQYXJ0SWQrKzsgLy8gQ29weSBhbGwgdGhlIGZvcm0gZmllbGRzIHdpdGggYSBwcmVmaXggZm9yIHRoaXMgcmVmZXJlbmNlLlxuICAgICAgICAvLyBUaGVzZSBtdXN0IGNvbWUgZmlyc3QgaW4gdGhlIGZvcm0gb3JkZXIgYmVjYXVzZSB3ZSBhc3N1bWUgdGhhdCBhbGwgdGhlXG4gICAgICAgIC8vIGZpZWxkcyBhcmUgYXZhaWxhYmxlIGJlZm9yZSB0aGlzIGlzIHJlZmVyZW5jZWQuXG5cbiAgICAgICAgdmFyIHByZWZpeCA9IGZvcm1GaWVsZFByZWZpeCArIHJlZklkICsgJ18nOyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ106IEZvcm1EYXRhIGhhcyBmb3JFYWNoLlxuXG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKG9yaWdpbmFsVmFsdWUsIG9yaWdpbmFsS2V5KSB7XG4gICAgICAgICAgZGF0YS5hcHBlbmQocHJlZml4ICsgb3JpZ2luYWxLZXksIG9yaWdpbmFsVmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUZvcm1EYXRhUmVmZXJlbmNlKHJlZklkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHZhciBwYXJ0SlNPTiA9IEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20odmFsdWUpLCByZXNvbHZlVG9KU09OKTtcblxuICAgICAgICBpZiAoZm9ybURhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hcElkID0gbmV4dFBhcnRJZCsrO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoZm9ybUZpZWxkUHJlZml4ICsgbWFwSWQsIHBhcnRKU09OKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZU1hcElEKG1hcElkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIHZhciBfcGFydEpTT04gPSBKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKHZhbHVlKSwgcmVzb2x2ZVRvSlNPTik7XG5cbiAgICAgICAgaWYgKGZvcm1EYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZXRJZCA9IG5leHRQYXJ0SWQrKztcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKGZvcm1GaWVsZFByZWZpeCArIHNldElkLCBfcGFydEpTT04pO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplU2V0SUQoc2V0SWQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4odmFsdWUpO1xuXG4gICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG4gICAgICB9IC8vIFZlcmlmeSB0aGF0IHRoaXMgaXMgYSBzaW1wbGUgcGxhaW4gb2JqZWN0LlxuXG5cbiAgICAgIHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKHZhbHVlKTtcblxuICAgICAgaWYgKHByb3RvICE9PSBPYmplY3RQcm90b3R5cGUgJiYgKHByb3RvID09PSBudWxsIHx8IGdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IHBsYWluIG9iamVjdHMsIGFuZCBhIGZldyBidWlsdC1pbnMsIGNhbiBiZSBwYXNzZWQgdG8gU2VydmVyIEFjdGlvbnMuICcgKyAnQ2xhc3NlcyBvciBudWxsIHByb3RvdHlwZXMgYXJlIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QgRWxlbWVudCBjYW5ub3QgYmUgcGFzc2VkIHRvIFNlcnZlciBGdW5jdGlvbnMgZnJvbSB0aGUgQ2xpZW50LiVzJywgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UocGFyZW50LCBrZXkpKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IExhenkgY2Fubm90IGJlIHBhc3NlZCB0byBTZXJ2ZXIgRnVuY3Rpb25zIGZyb20gdGhlIENsaWVudC4lcycsIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHBhcmVudCwga2V5KSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QgQ29udGV4dCBQcm92aWRlcnMgY2Fubm90IGJlIHBhc3NlZCB0byBTZXJ2ZXIgRnVuY3Rpb25zIGZyb20gdGhlIENsaWVudC4lcycsIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHBhcmVudCwga2V5KSk7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqZWN0TmFtZSh2YWx1ZSkgIT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgZXJyb3IoJ09ubHkgcGxhaW4gb2JqZWN0cyBjYW4gYmUgcGFzc2VkIHRvIFNlcnZlciBGdW5jdGlvbnMgZnJvbSB0aGUgQ2xpZW50LiAnICsgJyVzIG9iamVjdHMgYXJlIG5vdCBzdXBwb3J0ZWQuJXMnLCBvYmplY3ROYW1lKHZhbHVlKSwgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UocGFyZW50LCBrZXkpKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNTaW1wbGVPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgZXJyb3IoJ09ubHkgcGxhaW4gb2JqZWN0cyBjYW4gYmUgcGFzc2VkIHRvIFNlcnZlciBGdW5jdGlvbnMgZnJvbSB0aGUgQ2xpZW50LiAnICsgJ0NsYXNzZXMgb3Igb3RoZXIgb2JqZWN0cyB3aXRoIG1ldGhvZHMgYXJlIG5vdCBzdXBwb3J0ZWQuJXMnLCBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShwYXJlbnQsIGtleSkpO1xuICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHN5bWJvbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZXJyb3IoJ09ubHkgcGxhaW4gb2JqZWN0cyBjYW4gYmUgcGFzc2VkIHRvIFNlcnZlciBGdW5jdGlvbnMgZnJvbSB0aGUgQ2xpZW50LiAnICsgJ09iamVjdHMgd2l0aCBzeW1ib2wgcHJvcGVydGllcyBsaWtlICVzIGFyZSBub3Qgc3VwcG9ydGVkLiVzJywgc3ltYm9sc1swXS5kZXNjcmlwdGlvbiwgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UocGFyZW50LCBrZXkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVE9ETzogTWF5YmUgdG9vIGNsZXZlci4gSWYgd2Ugc3VwcG9ydCBVUkwgdGhlcmUncyBubyBzaW1pbGFyIHRyaWNrLlxuICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnWicpIHtcbiAgICAgICAgLy8gUG9zc2libHkgYSBEYXRlLCB3aG9zZSB0b0pTT04gYXV0b21hdGljYWxseSBjYWxscyB0b0lTT1N0cmluZ1xuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdXG4gICAgICAgIHZhciBfb3JpZ2luYWxWYWx1ZSA9IHBhcmVudFtrZXldO1xuXG4gICAgICAgIGlmIChfb3JpZ2luYWxWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplRGF0ZUZyb21EYXRlSlNPTih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVzY2FwZVN0cmluZ1ZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZU51bWJlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVVbmRlZmluZWQoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgbWV0YURhdGEgPSBrbm93blNlcnZlclJlZmVyZW5jZXMuZ2V0KHZhbHVlKTtcblxuICAgICAgaWYgKG1ldGFEYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG1ldGFEYXRhSlNPTiA9IEpTT04uc3RyaW5naWZ5KG1ldGFEYXRhLCByZXNvbHZlVG9KU09OKTtcblxuICAgICAgICBpZiAoZm9ybURhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBVcGdyYWRlIHRvIHVzZSBGb3JtRGF0YSB0byBhbGxvdyB1cyB0byBzdHJlYW0gdGhpcyB2YWx1ZS5cbiAgICAgICAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICB9IC8vIFRoZSByZWZlcmVuY2UgdG8gdGhpcyBmdW5jdGlvbiBjYW1lIGZyb20gdGhlIHNhbWUgY2xpZW50IHNvIHdlIGNhbiBwYXNzIGl0IGJhY2suXG5cblxuICAgICAgICB2YXIgX3JlZklkID0gbmV4dFBhcnRJZCsrOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgICAgIGZvcm1EYXRhLnNldChmb3JtRmllbGRQcmVmaXggKyBfcmVmSWQsIG1ldGFEYXRhSlNPTik7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVTZXJ2ZXJSZWZlcmVuY2VJRChfcmVmSWQpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudCBGdW5jdGlvbnMgY2Fubm90IGJlIHBhc3NlZCBkaXJlY3RseSB0byBTZXJ2ZXIgRnVuY3Rpb25zLiAnICsgJ09ubHkgRnVuY3Rpb25zIHBhc3NlZCBmcm9tIHRoZSBTZXJ2ZXIgY2FuIGJlIHBhc3NlZCBiYWNrIGFnYWluLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBgZGVzY3JpcHRpb25gIG1pZ2h0IGJlIHVuZGVmaW5lZFxuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5kZXNjcmlwdGlvbjtcblxuICAgICAgaWYgKFN5bWJvbC5mb3IobmFtZSkgIT09IHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBnbG9iYWwgc3ltYm9scyByZWNlaXZlZCBmcm9tIFN5bWJvbC5mb3IoLi4uKSBjYW4gYmUgcGFzc2VkIHRvIFNlcnZlciBGdW5jdGlvbnMuICcgKyAoXCJUaGUgc3ltYm9sIFN5bWJvbC5mb3IoXCIgKyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBgZGVzY3JpcHRpb25gIG1pZ2h0IGJlIHVuZGVmaW5lZFxuICAgICAgICB2YWx1ZS5kZXNjcmlwdGlvbiArIFwiKSBjYW5ub3QgYmUgZm91bmQgYW1vbmcgZ2xvYmFsIHN5bWJvbHMuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZVN5bWJvbFJlZmVyZW5jZShuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZUJpZ0ludCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZSBcIiArIHR5cGVvZiB2YWx1ZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYXMgYW4gYXJndW1lbnQgdG8gYSBTZXJ2ZXIgRnVuY3Rpb24uXCIpO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIGl0J3Mgbm90IGdvaW5nIHRvIGJlIHVuZGVmaW5lZCBiZWNhdXNlIHdlJ2xsIGVuY29kZSBpdC5cblxuXG4gIHZhciBqc29uID0gSlNPTi5zdHJpbmdpZnkocm9vdCwgcmVzb2x2ZVRvSlNPTik7XG5cbiAgaWYgKGZvcm1EYXRhID09PSBudWxsKSB7XG4gICAgLy8gSWYgaXQncyBhIHNpbXBsZSBkYXRhIHN0cnVjdHVyZSwgd2UganVzdCB1c2UgcGxhaW4gSlNPTi5cbiAgICByZXNvbHZlKGpzb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSwgd2UgdXNlIEZvcm1EYXRhIHRvIGxldCB1cyBzdHJlYW0gaW4gdGhlIHJlc3VsdC5cbiAgICBmb3JtRGF0YS5zZXQoZm9ybUZpZWxkUHJlZml4ICsgJzAnLCBqc29uKTtcblxuICAgIGlmIChwZW5kaW5nUGFydHMgPT09IDApIHtcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdIHRoaXMgaGFzIGFscmVhZHkgYmVlbiByZWZpbmVkLlxuICAgICAgcmVzb2x2ZShmb3JtRGF0YSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyU2VydmVyUmVmZXJlbmNlKHByb3h5LCByZWZlcmVuY2UpIHtcblxuICBrbm93blNlcnZlclJlZmVyZW5jZXMuc2V0KHByb3h5LCByZWZlcmVuY2UpO1xufSAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG5cbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlclJlZmVyZW5jZShpZCwgY2FsbFNlcnZlcikge1xuICB2YXIgcHJveHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gY2FsbFNlcnZlcihpZCwgYXJncyk7XG4gIH07XG5cbiAgcmVnaXN0ZXJTZXJ2ZXJSZWZlcmVuY2UocHJveHksIHtcbiAgICBpZDogaWQsXG4gICAgYm91bmQ6IG51bGxcbiAgfSk7XG4gIHJldHVybiBwcm94eTtcbn1cblxudmFyIENvbnRleHRSZWdpc3RyeSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkNvbnRleHRSZWdpc3RyeTtcbmZ1bmN0aW9uIGdldE9yQ3JlYXRlU2VydmVyQ29udGV4dChnbG9iYWxOYW1lKSB7XG4gIGlmICghQ29udGV4dFJlZ2lzdHJ5W2dsb2JhbE5hbWVdKSB7XG4gICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSxcbiAgICAgIC8vIEFzIGEgd29ya2Fyb3VuZCB0byBzdXBwb3J0IG11bHRpcGxlIGNvbmN1cnJlbnQgcmVuZGVyZXJzLCB3ZSBjYXRlZ29yaXplXG4gICAgICAvLyBzb21lIHJlbmRlcmVycyBhcyBwcmltYXJ5IGFuZCBvdGhlcnMgYXMgc2Vjb25kYXJ5LiBXZSBvbmx5IGV4cGVjdFxuICAgICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgICAvLyBGYWJyaWMgKHNlY29uZGFyeSk7IFJlYWN0IERPTSAocHJpbWFyeSkgYW5kIFJlYWN0IEFSVCAoc2Vjb25kYXJ5KS5cbiAgICAgIC8vIFNlY29uZGFyeSByZW5kZXJlcnMgc3RvcmUgdGhlaXIgY29udGV4dCB2YWx1ZXMgb24gc2VwYXJhdGUgZmllbGRzLlxuICAgICAgX2N1cnJlbnRWYWx1ZTogUkVBQ1RfU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVELFxuICAgICAgX2N1cnJlbnRWYWx1ZTI6IFJFQUNUX1NFUlZFUl9DT05URVhUX0RFRkFVTFRfVkFMVUVfTk9UX0xPQURFRCxcbiAgICAgIF9kZWZhdWx0VmFsdWU6IFJFQUNUX1NFUlZFUl9DT05URVhUX0RFRkFVTFRfVkFMVUVfTk9UX0xPQURFRCxcbiAgICAgIC8vIFVzZWQgdG8gdHJhY2sgaG93IG1hbnkgY29uY3VycmVudCByZW5kZXJlcnMgdGhpcyBjb250ZXh0IGN1cnJlbnRseVxuICAgICAgLy8gc3VwcG9ydHMgd2l0aGluIGluIGEgc2luZ2xlIHJlbmRlcmVyLiBTdWNoIGFzIHBhcmFsbGVsIHNlcnZlciByZW5kZXJpbmcuXG4gICAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICAgIFByb3ZpZGVyOiBudWxsLFxuICAgICAgQ29uc3VtZXI6IG51bGwsXG4gICAgICBfZ2xvYmFsTmFtZTogZ2xvYmFsTmFtZVxuICAgIH07XG4gICAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAgICQkdHlwZW9mOiBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICAgICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgICB9O1xuXG4gICAge1xuICAgICAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lcjtcbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnRleHQsIHtcbiAgICAgICAgQ29uc3VtZXI6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyKSB7XG4gICAgICAgICAgICAgIGVycm9yKCdDb25zdW1lciBwYXR0ZXJuIGlzIG5vdCBzdXBwb3J0ZWQgYnkgUmVhY3RTZXJ2ZXJDb250ZXh0Jyk7XG5cbiAgICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBDb250ZXh0UmVnaXN0cnlbZ2xvYmFsTmFtZV0gPSBjb250ZXh0O1xuICB9XG5cbiAgcmV0dXJuIENvbnRleHRSZWdpc3RyeVtnbG9iYWxOYW1lXTtcbn1cblxudmFyIFJPV19JRCA9IDA7XG52YXIgUk9XX1RBRyA9IDE7XG52YXIgUk9XX0xFTkdUSCA9IDI7XG52YXIgUk9XX0NIVU5LX0JZX05FV0xJTkUgPSAzO1xudmFyIFJPV19DSFVOS19CWV9MRU5HVEggPSA0O1xudmFyIFBFTkRJTkcgPSAncGVuZGluZyc7XG52YXIgQkxPQ0tFRCA9ICdibG9ja2VkJztcbnZhciBDWUNMSUMgPSAnY3ljbGljJztcbnZhciBSRVNPTFZFRF9NT0RFTCA9ICdyZXNvbHZlZF9tb2RlbCc7XG52YXIgUkVTT0xWRURfTU9EVUxFID0gJ3Jlc29sdmVkX21vZHVsZSc7XG52YXIgSU5JVElBTElaRUQgPSAnZnVsZmlsbGVkJztcbnZhciBFUlJPUkVEID0gJ3JlamVjdGVkJzsgLy8gJEZsb3dGaXhNZVttaXNzaW5nLXRoaXMtYW5ub3RdXG5cbmZ1bmN0aW9uIENodW5rKHN0YXR1cywgdmFsdWUsIHJlYXNvbiwgcmVzcG9uc2UpIHtcbiAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gIHRoaXMuX3Jlc3BvbnNlID0gcmVzcG9uc2U7XG59IC8vIFdlIHN1YmNsYXNzIFByb21pc2UucHJvdG90eXBlIHNvIHRoYXQgd2UgZ2V0IG90aGVyIG1ldGhvZHMgbGlrZSAuY2F0Y2hcblxuXG5DaHVuay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFByb21pc2UucHJvdG90eXBlKTsgLy8gVE9ETzogVGhpcyBkb2Vzbid0IHJldHVybiBhIG5ldyBQcm9taXNlIGNoYWluIHVubGlrZSB0aGUgcmVhbCAudGhlblxuXG5DaHVuay5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgdmFyIGNodW5rID0gdGhpczsgLy8gSWYgd2UgaGF2ZSByZXNvbHZlZCBjb250ZW50LCB3ZSB0cnkgdG8gaW5pdGlhbGl6ZSBpdCBmaXJzdCB3aGljaFxuICAvLyBtaWdodCBwdXQgdXMgYmFjayBpbnRvIG9uZSBvZiB0aGUgb3RoZXIgc3RhdGVzLlxuXG4gIHN3aXRjaCAoY2h1bmsuc3RhdHVzKSB7XG4gICAgY2FzZSBSRVNPTFZFRF9NT0RFTDpcbiAgICAgIGluaXRpYWxpemVNb2RlbENodW5rKGNodW5rKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBSRVNPTFZFRF9NT0RVTEU6XG4gICAgICBpbml0aWFsaXplTW9kdWxlQ2h1bmsoY2h1bmspO1xuICAgICAgYnJlYWs7XG4gIH0gLy8gVGhlIHN0YXR1cyBtaWdodCBoYXZlIGNoYW5nZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uXG5cblxuICBzd2l0Y2ggKGNodW5rLnN0YXR1cykge1xuICAgIGNhc2UgSU5JVElBTElaRUQ6XG4gICAgICByZXNvbHZlKGNodW5rLnZhbHVlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBQRU5ESU5HOlxuICAgIGNhc2UgQkxPQ0tFRDpcbiAgICBjYXNlIENZQ0xJQzpcbiAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgIGlmIChjaHVuay52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGNodW5rLnZhbHVlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBjaHVuay52YWx1ZS5wdXNoKHJlc29sdmUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVqZWN0KSB7XG4gICAgICAgIGlmIChjaHVuay5yZWFzb24gPT09IG51bGwpIHtcbiAgICAgICAgICBjaHVuay5yZWFzb24gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNodW5rLnJlYXNvbi5wdXNoKHJlamVjdCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJlamVjdChjaHVuay5yZWFzb24pO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlYWRDaHVuayhjaHVuaykge1xuICAvLyBJZiB3ZSBoYXZlIHJlc29sdmVkIGNvbnRlbnQsIHdlIHRyeSB0byBpbml0aWFsaXplIGl0IGZpcnN0IHdoaWNoXG4gIC8vIG1pZ2h0IHB1dCB1cyBiYWNrIGludG8gb25lIG9mIHRoZSBvdGhlciBzdGF0ZXMuXG4gIHN3aXRjaCAoY2h1bmsuc3RhdHVzKSB7XG4gICAgY2FzZSBSRVNPTFZFRF9NT0RFTDpcbiAgICAgIGluaXRpYWxpemVNb2RlbENodW5rKGNodW5rKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBSRVNPTFZFRF9NT0RVTEU6XG4gICAgICBpbml0aWFsaXplTW9kdWxlQ2h1bmsoY2h1bmspO1xuICAgICAgYnJlYWs7XG4gIH0gLy8gVGhlIHN0YXR1cyBtaWdodCBoYXZlIGNoYW5nZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uXG5cblxuICBzd2l0Y2ggKGNodW5rLnN0YXR1cykge1xuICAgIGNhc2UgSU5JVElBTElaRUQ6XG4gICAgICByZXR1cm4gY2h1bmsudmFsdWU7XG5cbiAgICBjYXNlIFBFTkRJTkc6XG4gICAgY2FzZSBCTE9DS0VEOlxuICAgIGNhc2UgQ1lDTElDOlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICAgIHRocm93IGNodW5rO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IGNodW5rLnJlYXNvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSb290KHJlc3BvbnNlKSB7XG4gIHZhciBjaHVuayA9IGdldENodW5rKHJlc3BvbnNlLCAwKTtcbiAgcmV0dXJuIGNodW5rO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQZW5kaW5nQ2h1bmsocmVzcG9uc2UpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbnZhbGlkLWNvbnN0cnVjdG9yXSBGbG93IGRvZXNuJ3Qgc3VwcG9ydCBmdW5jdGlvbnMgYXMgY29uc3RydWN0b3JzXG4gIHJldHVybiBuZXcgQ2h1bmsoUEVORElORywgbnVsbCwgbnVsbCwgcmVzcG9uc2UpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCbG9ja2VkQ2h1bmsocmVzcG9uc2UpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbnZhbGlkLWNvbnN0cnVjdG9yXSBGbG93IGRvZXNuJ3Qgc3VwcG9ydCBmdW5jdGlvbnMgYXMgY29uc3RydWN0b3JzXG4gIHJldHVybiBuZXcgQ2h1bmsoQkxPQ0tFRCwgbnVsbCwgbnVsbCwgcmVzcG9uc2UpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFcnJvckNodW5rKHJlc3BvbnNlLCBlcnJvcikge1xuICAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29uc3RydWN0b3JdIEZsb3cgZG9lc24ndCBzdXBwb3J0IGZ1bmN0aW9ucyBhcyBjb25zdHJ1Y3RvcnNcbiAgcmV0dXJuIG5ldyBDaHVuayhFUlJPUkVELCBudWxsLCBlcnJvciwgcmVzcG9uc2UpO1xufVxuXG5mdW5jdGlvbiB3YWtlQ2h1bmsobGlzdGVuZXJzLCB2YWx1ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICBsaXN0ZW5lcih2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FrZUNodW5rSWZJbml0aWFsaXplZChjaHVuaywgcmVzb2x2ZUxpc3RlbmVycywgcmVqZWN0TGlzdGVuZXJzKSB7XG4gIHN3aXRjaCAoY2h1bmsuc3RhdHVzKSB7XG4gICAgY2FzZSBJTklUSUFMSVpFRDpcbiAgICAgIHdha2VDaHVuayhyZXNvbHZlTGlzdGVuZXJzLCBjaHVuay52YWx1ZSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgUEVORElORzpcbiAgICBjYXNlIEJMT0NLRUQ6XG4gICAgY2FzZSBDWUNMSUM6XG4gICAgICBjaHVuay52YWx1ZSA9IHJlc29sdmVMaXN0ZW5lcnM7XG4gICAgICBjaHVuay5yZWFzb24gPSByZWplY3RMaXN0ZW5lcnM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgRVJST1JFRDpcbiAgICAgIGlmIChyZWplY3RMaXN0ZW5lcnMpIHtcbiAgICAgICAgd2FrZUNodW5rKHJlamVjdExpc3RlbmVycywgY2h1bmsucmVhc29uKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJpZ2dlckVycm9yT25DaHVuayhjaHVuaywgZXJyb3IpIHtcbiAgaWYgKGNodW5rLnN0YXR1cyAhPT0gUEVORElORyAmJiBjaHVuay5zdGF0dXMgIT09IEJMT0NLRUQpIHtcbiAgICAvLyBXZSBhbHJlYWR5IHJlc29sdmVkLiBXZSBkaWRuJ3QgZXhwZWN0IHRvIHNlZSB0aGlzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSBjaHVuay5yZWFzb247XG4gIHZhciBlcnJvcmVkQ2h1bmsgPSBjaHVuaztcbiAgZXJyb3JlZENodW5rLnN0YXR1cyA9IEVSUk9SRUQ7XG4gIGVycm9yZWRDaHVuay5yZWFzb24gPSBlcnJvcjtcblxuICBpZiAobGlzdGVuZXJzICE9PSBudWxsKSB7XG4gICAgd2FrZUNodW5rKGxpc3RlbmVycywgZXJyb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmVkTW9kZWxDaHVuayhyZXNwb25zZSwgdmFsdWUpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbnZhbGlkLWNvbnN0cnVjdG9yXSBGbG93IGRvZXNuJ3Qgc3VwcG9ydCBmdW5jdGlvbnMgYXMgY29uc3RydWN0b3JzXG4gIHJldHVybiBuZXcgQ2h1bmsoUkVTT0xWRURfTU9ERUwsIHZhbHVlLCBudWxsLCByZXNwb25zZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmVkTW9kdWxlQ2h1bmsocmVzcG9uc2UsIHZhbHVlKSB7XG4gIC8vICRGbG93Rml4TWVbaW52YWxpZC1jb25zdHJ1Y3Rvcl0gRmxvdyBkb2Vzbid0IHN1cHBvcnQgZnVuY3Rpb25zIGFzIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IENodW5rKFJFU09MVkVEX01PRFVMRSwgdmFsdWUsIG51bGwsIHJlc3BvbnNlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5pdGlhbGl6ZWRUZXh0Q2h1bmsocmVzcG9uc2UsIHZhbHVlKSB7XG4gIC8vICRGbG93Rml4TWVbaW52YWxpZC1jb25zdHJ1Y3Rvcl0gRmxvdyBkb2Vzbid0IHN1cHBvcnQgZnVuY3Rpb25zIGFzIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IENodW5rKElOSVRJQUxJWkVELCB2YWx1ZSwgbnVsbCwgcmVzcG9uc2UpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kZWxDaHVuayhjaHVuaywgdmFsdWUpIHtcbiAgaWYgKGNodW5rLnN0YXR1cyAhPT0gUEVORElORykge1xuICAgIC8vIFdlIGFscmVhZHkgcmVzb2x2ZWQuIFdlIGRpZG4ndCBleHBlY3QgdG8gc2VlIHRoaXMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlc29sdmVMaXN0ZW5lcnMgPSBjaHVuay52YWx1ZTtcbiAgdmFyIHJlamVjdExpc3RlbmVycyA9IGNodW5rLnJlYXNvbjtcbiAgdmFyIHJlc29sdmVkQ2h1bmsgPSBjaHVuaztcbiAgcmVzb2x2ZWRDaHVuay5zdGF0dXMgPSBSRVNPTFZFRF9NT0RFTDtcbiAgcmVzb2x2ZWRDaHVuay52YWx1ZSA9IHZhbHVlO1xuXG4gIGlmIChyZXNvbHZlTGlzdGVuZXJzICE9PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB1bmZvcnR1bmF0ZSB0aGF0IHdlJ3JlIHJlYWRpbmcgdGhpcyBlYWdlcmx5IGlmXG4gICAgLy8gd2UgYWxyZWFkeSBoYXZlIGxpc3RlbmVycyBhdHRhY2hlZCBzaW5jZSB0aGV5IG1pZ2h0IG5vXG4gICAgLy8gbG9uZ2VyIGJlIHJlbmRlcmVkIG9yIG1pZ2h0IG5vdCBiZSB0aGUgaGlnaGVzdCBwcmkuXG4gICAgaW5pdGlhbGl6ZU1vZGVsQ2h1bmsocmVzb2x2ZWRDaHVuayk7IC8vIFRoZSBzdGF0dXMgbWlnaHQgaGF2ZSBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uLlxuXG4gICAgd2FrZUNodW5rSWZJbml0aWFsaXplZChjaHVuaywgcmVzb2x2ZUxpc3RlbmVycywgcmVqZWN0TGlzdGVuZXJzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kdWxlQ2h1bmsoY2h1bmssIHZhbHVlKSB7XG4gIGlmIChjaHVuay5zdGF0dXMgIT09IFBFTkRJTkcgJiYgY2h1bmsuc3RhdHVzICE9PSBCTE9DS0VEKSB7XG4gICAgLy8gV2UgYWxyZWFkeSByZXNvbHZlZC4gV2UgZGlkbid0IGV4cGVjdCB0byBzZWUgdGhpcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVzb2x2ZUxpc3RlbmVycyA9IGNodW5rLnZhbHVlO1xuICB2YXIgcmVqZWN0TGlzdGVuZXJzID0gY2h1bmsucmVhc29uO1xuICB2YXIgcmVzb2x2ZWRDaHVuayA9IGNodW5rO1xuICByZXNvbHZlZENodW5rLnN0YXR1cyA9IFJFU09MVkVEX01PRFVMRTtcbiAgcmVzb2x2ZWRDaHVuay52YWx1ZSA9IHZhbHVlO1xuXG4gIGlmIChyZXNvbHZlTGlzdGVuZXJzICE9PSBudWxsKSB7XG4gICAgaW5pdGlhbGl6ZU1vZHVsZUNodW5rKHJlc29sdmVkQ2h1bmspO1xuICAgIHdha2VDaHVua0lmSW5pdGlhbGl6ZWQoY2h1bmssIHJlc29sdmVMaXN0ZW5lcnMsIHJlamVjdExpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIGluaXRpYWxpemluZ0NodW5rID0gbnVsbDtcbnZhciBpbml0aWFsaXppbmdDaHVua0Jsb2NrZWRNb2RlbCA9IG51bGw7XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVNb2RlbENodW5rKGNodW5rKSB7XG4gIHZhciBwcmV2Q2h1bmsgPSBpbml0aWFsaXppbmdDaHVuaztcbiAgdmFyIHByZXZCbG9ja2VkID0gaW5pdGlhbGl6aW5nQ2h1bmtCbG9ja2VkTW9kZWw7XG4gIGluaXRpYWxpemluZ0NodW5rID0gY2h1bms7XG4gIGluaXRpYWxpemluZ0NodW5rQmxvY2tlZE1vZGVsID0gbnVsbDtcbiAgdmFyIHJlc29sdmVkTW9kZWwgPSBjaHVuay52YWx1ZTsgLy8gV2UgZ28gdG8gdGhlIENZQ0xJQyBzdGF0ZSB1bnRpbCB3ZSd2ZSBmdWxseSByZXNvbHZlZCB0aGlzLlxuICAvLyBXZSBkbyB0aGlzIGJlZm9yZSBwYXJzaW5nIGluIGNhc2Ugd2UgdHJ5IHRvIGluaXRpYWxpemUgdGhlIHNhbWUgY2h1bmtcbiAgLy8gd2hpbGUgcGFyc2luZyB0aGUgbW9kZWwuIFN1Y2ggYXMgaW4gYSBjeWNsaWMgcmVmZXJlbmNlLlxuXG4gIHZhciBjeWNsaWNDaHVuayA9IGNodW5rO1xuICBjeWNsaWNDaHVuay5zdGF0dXMgPSBDWUNMSUM7XG4gIGN5Y2xpY0NodW5rLnZhbHVlID0gbnVsbDtcbiAgY3ljbGljQ2h1bmsucmVhc29uID0gbnVsbDtcblxuICB0cnkge1xuICAgIHZhciB2YWx1ZSA9IHBhcnNlTW9kZWwoY2h1bmsuX3Jlc3BvbnNlLCByZXNvbHZlZE1vZGVsKTtcblxuICAgIGlmIChpbml0aWFsaXppbmdDaHVua0Jsb2NrZWRNb2RlbCAhPT0gbnVsbCAmJiBpbml0aWFsaXppbmdDaHVua0Jsb2NrZWRNb2RlbC5kZXBzID4gMCkge1xuICAgICAgaW5pdGlhbGl6aW5nQ2h1bmtCbG9ja2VkTW9kZWwudmFsdWUgPSB2YWx1ZTsgLy8gV2UgZGlzY292ZXJlZCBuZXcgZGVwZW5kZW5jaWVzIG9uIG1vZHVsZXMgdGhhdCBhcmUgbm90IHlldCByZXNvbHZlZC5cbiAgICAgIC8vIFdlIGhhdmUgdG8gZ28gdGhlIEJMT0NLRUQgc3RhdGUgdW50aWwgdGhleSdyZSByZXNvbHZlZC5cblxuICAgICAgdmFyIGJsb2NrZWRDaHVuayA9IGNodW5rO1xuICAgICAgYmxvY2tlZENodW5rLnN0YXR1cyA9IEJMT0NLRUQ7XG4gICAgICBibG9ja2VkQ2h1bmsudmFsdWUgPSBudWxsO1xuICAgICAgYmxvY2tlZENodW5rLnJlYXNvbiA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXNvbHZlTGlzdGVuZXJzID0gY3ljbGljQ2h1bmsudmFsdWU7XG4gICAgICB2YXIgaW5pdGlhbGl6ZWRDaHVuayA9IGNodW5rO1xuICAgICAgaW5pdGlhbGl6ZWRDaHVuay5zdGF0dXMgPSBJTklUSUFMSVpFRDtcbiAgICAgIGluaXRpYWxpemVkQ2h1bmsudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgaWYgKHJlc29sdmVMaXN0ZW5lcnMgIT09IG51bGwpIHtcbiAgICAgICAgd2FrZUNodW5rKHJlc29sdmVMaXN0ZW5lcnMsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdmFyIGVycm9yZWRDaHVuayA9IGNodW5rO1xuICAgIGVycm9yZWRDaHVuay5zdGF0dXMgPSBFUlJPUkVEO1xuICAgIGVycm9yZWRDaHVuay5yZWFzb24gPSBlcnJvcjtcbiAgfSBmaW5hbGx5IHtcbiAgICBpbml0aWFsaXppbmdDaHVuayA9IHByZXZDaHVuaztcbiAgICBpbml0aWFsaXppbmdDaHVua0Jsb2NrZWRNb2RlbCA9IHByZXZCbG9ja2VkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVNb2R1bGVDaHVuayhjaHVuaykge1xuICB0cnkge1xuICAgIHZhciB2YWx1ZSA9IHJlcXVpcmVNb2R1bGUoY2h1bmsudmFsdWUpO1xuICAgIHZhciBpbml0aWFsaXplZENodW5rID0gY2h1bms7XG4gICAgaW5pdGlhbGl6ZWRDaHVuay5zdGF0dXMgPSBJTklUSUFMSVpFRDtcbiAgICBpbml0aWFsaXplZENodW5rLnZhbHVlID0gdmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdmFyIGVycm9yZWRDaHVuayA9IGNodW5rO1xuICAgIGVycm9yZWRDaHVuay5zdGF0dXMgPSBFUlJPUkVEO1xuICAgIGVycm9yZWRDaHVuay5yZWFzb24gPSBlcnJvcjtcbiAgfVxufSAvLyBSZXBvcnQgdGhhdCBhbnkgbWlzc2luZyBjaHVua3MgaW4gdGhlIG1vZGVsIGlzIG5vdyBnb2luZyB0byB0aHJvdyB0aGlzXG4vLyBlcnJvciB1cG9uIHJlYWQuIEFsc28gbm90aWZ5IGFueSBwZW5kaW5nIHByb21pc2VzLlxuXG5cbmZ1bmN0aW9uIHJlcG9ydEdsb2JhbEVycm9yKHJlc3BvbnNlLCBlcnJvcikge1xuICByZXNwb25zZS5fY2h1bmtzLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgLy8gSWYgdGhpcyBjaHVuayB3YXMgYWxyZWFkeSByZXNvbHZlZCBvciBlcnJvcmVkLCBpdCB3b24ndFxuICAgIC8vIHRyaWdnZXIgYW4gZXJyb3IgYnV0IGlmIGl0IHdhc24ndCB0aGVuIHdlIG5lZWQgdG9cbiAgICAvLyBiZWNhdXNlIHdlIHdvbid0IGJlIGdldHRpbmcgYW55IG5ldyBkYXRhIHRvIHJlc29sdmUgaXQuXG4gICAgaWYgKGNodW5rLnN0YXR1cyA9PT0gUEVORElORykge1xuICAgICAgdHJpZ2dlckVycm9yT25DaHVuayhjaHVuaywgZXJyb3IpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwga2V5LCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogbnVsbCxcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG51bGxcbiAgfTtcblxuICB7XG4gICAgLy8gV2UgZG9uJ3QgcmVhbGx5IG5lZWQgdG8gYWRkIGFueSBvZiB0aGVzZSBidXQga2VlcGluZyB0aGVtIGZvciBnb29kIG1lYXN1cmUuXG4gICAgLy8gVW5mb3J0dW5hdGVseSwgX3N0b3JlIGlzIGVudW1lcmFibGUgaW4gamVzdCBtYXRjaGVycyBzbyBmb3IgZXF1YWxpdHkgdG9cbiAgICAvLyB3b3JrLCBJIG5lZWQgdG8ga2VlcCBpdCBvciBtYWtlIF9zdG9yZSBub24tZW51bWVyYWJsZSBpbiB0aGUgb3RoZXIgZmlsZS5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHRydWUgLy8gVGhpcyBlbGVtZW50IGhhcyBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIG9uIHRoZSBzZXJ2ZXIuXG5cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxhenlDaHVua1dyYXBwZXIoY2h1bmspIHtcbiAgdmFyIGxhenlUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgX3BheWxvYWQ6IGNodW5rLFxuICAgIF9pbml0OiByZWFkQ2h1bmtcbiAgfTtcbiAgcmV0dXJuIGxhenlUeXBlO1xufVxuXG5mdW5jdGlvbiBnZXRDaHVuayhyZXNwb25zZSwgaWQpIHtcbiAgdmFyIGNodW5rcyA9IHJlc3BvbnNlLl9jaHVua3M7XG4gIHZhciBjaHVuayA9IGNodW5rcy5nZXQoaWQpO1xuXG4gIGlmICghY2h1bmspIHtcbiAgICBjaHVuayA9IGNyZWF0ZVBlbmRpbmdDaHVuayhyZXNwb25zZSk7XG4gICAgY2h1bmtzLnNldChpZCwgY2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNb2RlbFJlc29sdmVyKGNodW5rLCBwYXJlbnRPYmplY3QsIGtleSwgY3ljbGljKSB7XG4gIHZhciBibG9ja2VkO1xuXG4gIGlmIChpbml0aWFsaXppbmdDaHVua0Jsb2NrZWRNb2RlbCkge1xuICAgIGJsb2NrZWQgPSBpbml0aWFsaXppbmdDaHVua0Jsb2NrZWRNb2RlbDtcblxuICAgIGlmICghY3ljbGljKSB7XG4gICAgICBibG9ja2VkLmRlcHMrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmxvY2tlZCA9IGluaXRpYWxpemluZ0NodW5rQmxvY2tlZE1vZGVsID0ge1xuICAgICAgZGVwczogY3ljbGljID8gMCA6IDEsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcGFyZW50T2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICBibG9ja2VkLmRlcHMtLTtcblxuICAgIGlmIChibG9ja2VkLmRlcHMgPT09IDApIHtcbiAgICAgIGlmIChjaHVuay5zdGF0dXMgIT09IEJMT0NLRUQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzb2x2ZUxpc3RlbmVycyA9IGNodW5rLnZhbHVlO1xuICAgICAgdmFyIGluaXRpYWxpemVkQ2h1bmsgPSBjaHVuaztcbiAgICAgIGluaXRpYWxpemVkQ2h1bmsuc3RhdHVzID0gSU5JVElBTElaRUQ7XG4gICAgICBpbml0aWFsaXplZENodW5rLnZhbHVlID0gYmxvY2tlZC52YWx1ZTtcblxuICAgICAgaWYgKHJlc29sdmVMaXN0ZW5lcnMgIT09IG51bGwpIHtcbiAgICAgICAgd2FrZUNodW5rKHJlc29sdmVMaXN0ZW5lcnMsIGJsb2NrZWQudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTW9kZWxSZWplY3QoY2h1bmspIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHJldHVybiB0cmlnZ2VyRXJyb3JPbkNodW5rKGNodW5rLCBlcnJvcik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlclJlZmVyZW5jZVByb3h5KHJlc3BvbnNlLCBtZXRhRGF0YSkge1xuICB2YXIgY2FsbFNlcnZlciA9IHJlc3BvbnNlLl9jYWxsU2VydmVyO1xuXG4gIHZhciBwcm94eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBwID0gbWV0YURhdGEuYm91bmQ7XG5cbiAgICBpZiAoIXApIHtcbiAgICAgIHJldHVybiBjYWxsU2VydmVyKG1ldGFEYXRhLmlkLCBhcmdzKTtcbiAgICB9XG5cbiAgICBpZiAocC5zdGF0dXMgPT09IElOSVRJQUxJWkVEKSB7XG4gICAgICB2YXIgYm91bmQgPSBwLnZhbHVlO1xuICAgICAgcmV0dXJuIGNhbGxTZXJ2ZXIobWV0YURhdGEuaWQsIGJvdW5kLmNvbmNhdChhcmdzKSk7XG4gICAgfSAvLyBTaW5jZSB0aGlzIGlzIGEgZmFrZSBQcm9taXNlIHdob3NlIC50aGVuIGRvZXNuJ3QgY2hhaW4sIHdlIGhhdmUgdG8gd3JhcCBpdC5cbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhlIHdyYXBwZXIgb25jZSB0aGF0J3MgZml4ZWQuXG5cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocCkudGhlbihmdW5jdGlvbiAoYm91bmQpIHtcbiAgICAgIHJldHVybiBjYWxsU2VydmVyKG1ldGFEYXRhLmlkLCBib3VuZC5jb25jYXQoYXJncykpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJlZ2lzdGVyU2VydmVyUmVmZXJlbmNlKHByb3h5LCBtZXRhRGF0YSk7XG4gIHJldHVybiBwcm94eTtcbn1cblxuZnVuY3Rpb24gZ2V0T3V0bGluZWRNb2RlbChyZXNwb25zZSwgaWQpIHtcbiAgdmFyIGNodW5rID0gZ2V0Q2h1bmsocmVzcG9uc2UsIGlkKTtcblxuICBzd2l0Y2ggKGNodW5rLnN0YXR1cykge1xuICAgIGNhc2UgUkVTT0xWRURfTU9ERUw6XG4gICAgICBpbml0aWFsaXplTW9kZWxDaHVuayhjaHVuayk7XG4gICAgICBicmVhaztcbiAgfSAvLyBUaGUgc3RhdHVzIG1pZ2h0IGhhdmUgY2hhbmdlZCBhZnRlciBpbml0aWFsaXphdGlvbi5cblxuXG4gIHN3aXRjaCAoY2h1bmsuc3RhdHVzKSB7XG4gICAgY2FzZSBJTklUSUFMSVpFRDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGNodW5rLnZhbHVlO1xuICAgICAgfVxuICAgIC8vIFdlIGFsd2F5cyBlbmNvZGUgaXQgZmlyc3QgaW4gdGhlIHN0cmVhbSBzbyBpdCB3b24ndCBiZSBwZW5kaW5nLlxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IGNodW5rLnJlYXNvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGVsU3RyaW5nKHJlc3BvbnNlLCBwYXJlbnRPYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlWzBdID09PSAnJCcpIHtcbiAgICBpZiAodmFsdWUgPT09ICckJykge1xuICAgICAgLy8gQSB2ZXJ5IGNvbW1vbiBzeW1ib2wuXG4gICAgICByZXR1cm4gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICAgIH1cblxuICAgIHN3aXRjaCAodmFsdWVbMV0pIHtcbiAgICAgIGNhc2UgJyQnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVGhpcyB3YXMgYW4gZXNjYXBlZCBzdHJpbmcgdmFsdWUuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ0wnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gTGF6eSBub2RlXG4gICAgICAgICAgdmFyIGlkID0gcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDE2KTtcbiAgICAgICAgICB2YXIgY2h1bmsgPSBnZXRDaHVuayhyZXNwb25zZSwgaWQpOyAvLyBXZSBjcmVhdGUgYSBSZWFjdC5sYXp5IHdyYXBwZXIgYXJvdW5kIGFueSBsYXp5IHZhbHVlcy5cbiAgICAgICAgICAvLyBXaGVuIHBhc3NlZCBpbnRvIFJlYWN0LCB3ZSdsbCBrbm93IGhvdyB0byBzdXNwZW5kIG9uIHRoaXMuXG5cbiAgICAgICAgICByZXR1cm4gY3JlYXRlTGF6eUNodW5rV3JhcHBlcihjaHVuayk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnQCc6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBQcm9taXNlXG4gICAgICAgICAgdmFyIF9pZCA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAxNik7XG5cbiAgICAgICAgICB2YXIgX2NodW5rID0gZ2V0Q2h1bmsocmVzcG9uc2UsIF9pZCk7XG5cbiAgICAgICAgICByZXR1cm4gX2NodW5rO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ1MnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gU3ltYm9sXG4gICAgICAgICAgcmV0dXJuIFN5bWJvbC5mb3IodmFsdWUuc2xpY2UoMikpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ1AnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gU2VydmVyIENvbnRleHQgUHJvdmlkZXJcbiAgICAgICAgICByZXR1cm4gZ2V0T3JDcmVhdGVTZXJ2ZXJDb250ZXh0KHZhbHVlLnNsaWNlKDIpKS5Qcm92aWRlcjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdGJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFNlcnZlciBSZWZlcmVuY2VcbiAgICAgICAgICB2YXIgX2lkMiA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAxNik7XG5cbiAgICAgICAgICB2YXIgbWV0YWRhdGEgPSBnZXRPdXRsaW5lZE1vZGVsKHJlc3BvbnNlLCBfaWQyKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlU2VydmVyUmVmZXJlbmNlUHJveHkocmVzcG9uc2UsIG1ldGFkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdRJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIE1hcFxuICAgICAgICAgIHZhciBfaWQzID0gcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDE2KTtcblxuICAgICAgICAgIHZhciBkYXRhID0gZ2V0T3V0bGluZWRNb2RlbChyZXNwb25zZSwgX2lkMyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBNYXAoZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnVyc6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBTZXRcbiAgICAgICAgICB2YXIgX2lkNCA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAxNik7XG5cbiAgICAgICAgICB2YXIgX2RhdGEgPSBnZXRPdXRsaW5lZE1vZGVsKHJlc3BvbnNlLCBfaWQ0KTtcblxuICAgICAgICAgIHJldHVybiBuZXcgU2V0KF9kYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdJJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vICRJbmZpbml0eVxuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICctJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vICQtMCBvciAkLUluZmluaXR5XG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnJC0wJykge1xuICAgICAgICAgICAgcmV0dXJuIC0wO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdOJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vICROYU5cbiAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3UnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gbWF0Y2hlcyBcIiR1bmRlZmluZWRcIlxuICAgICAgICAgIC8vIFNwZWNpYWwgZW5jb2RpbmcgZm9yIGB1bmRlZmluZWRgIHdoaWNoIGNhbid0IGJlIHNlcmlhbGl6ZWQgYXMgSlNPTiBvdGhlcndpc2UuXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdEJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIERhdGVcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5wYXJzZSh2YWx1ZS5zbGljZSgyKSkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ24nOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gQmlnSW50XG4gICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZS5zbGljZSgyKSk7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGFueXRoaW5nIGVsc2UgaXMgYSByZWZlcmVuY2UgSUQuXG4gICAgICAgICAgdmFyIF9pZDUgPSBwYXJzZUludCh2YWx1ZS5zbGljZSgxKSwgMTYpO1xuXG4gICAgICAgICAgdmFyIF9jaHVuazIgPSBnZXRDaHVuayhyZXNwb25zZSwgX2lkNSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKF9jaHVuazIuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFJFU09MVkVEX01PREVMOlxuICAgICAgICAgICAgICBpbml0aWFsaXplTW9kZWxDaHVuayhfY2h1bmsyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgUkVTT0xWRURfTU9EVUxFOlxuICAgICAgICAgICAgICBpbml0aWFsaXplTW9kdWxlQ2h1bmsoX2NodW5rMik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gLy8gVGhlIHN0YXR1cyBtaWdodCBoYXZlIGNoYW5nZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uXG5cblxuICAgICAgICAgIHN3aXRjaCAoX2NodW5rMi5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgSU5JVElBTElaRUQ6XG4gICAgICAgICAgICAgIHJldHVybiBfY2h1bmsyLnZhbHVlO1xuXG4gICAgICAgICAgICBjYXNlIFBFTkRJTkc6XG4gICAgICAgICAgICBjYXNlIEJMT0NLRUQ6XG4gICAgICAgICAgICBjYXNlIENZQ0xJQzpcbiAgICAgICAgICAgICAgdmFyIHBhcmVudENodW5rID0gaW5pdGlhbGl6aW5nQ2h1bms7XG5cbiAgICAgICAgICAgICAgX2NodW5rMi50aGVuKGNyZWF0ZU1vZGVsUmVzb2x2ZXIocGFyZW50Q2h1bmssIHBhcmVudE9iamVjdCwga2V5LCBfY2h1bmsyLnN0YXR1cyA9PT0gQ1lDTElDKSwgY3JlYXRlTW9kZWxSZWplY3QocGFyZW50Q2h1bmspKTtcblxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgX2NodW5rMi5yZWFzb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGVsVHVwbGUocmVzcG9uc2UsIHZhbHVlKSB7XG4gIHZhciB0dXBsZSA9IHZhbHVlO1xuXG4gIGlmICh0dXBsZVswXSA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgLy8gVE9ETzogQ29uc2lkZXIgaGF2aW5nIFJlYWN0IGp1c3QgZGlyZWN0bHkgYWNjZXB0IHRoZXNlIGFycmF5cyBhcyBlbGVtZW50cy5cbiAgICAvLyBPciBldmVuIGNoYW5nZSB0aGUgUmVhY3RFbGVtZW50IHR5cGUgdG8gYmUgYW4gYXJyYXkuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodHVwbGVbMV0sIHR1cGxlWzJdLCB0dXBsZVszXSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIG1pc3NpbmdDYWxsKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBjYWxsIGEgZnVuY3Rpb24gZnJvbSBcInVzZSBzZXJ2ZXJcIiBidXQgdGhlIGNhbGxTZXJ2ZXIgb3B0aW9uICcgKyAnd2FzIG5vdCBpbXBsZW1lbnRlZCBpbiB5b3VyIHJvdXRlciBydW50aW1lLicpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZShidW5kbGVyQ29uZmlnLCBtb2R1bGVMb2FkaW5nLCBjYWxsU2VydmVyLCBub25jZSkge1xuICB2YXIgY2h1bmtzID0gbmV3IE1hcCgpO1xuICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgX2J1bmRsZXJDb25maWc6IGJ1bmRsZXJDb25maWcsXG4gICAgX21vZHVsZUxvYWRpbmc6IG1vZHVsZUxvYWRpbmcsXG4gICAgX2NhbGxTZXJ2ZXI6IGNhbGxTZXJ2ZXIgIT09IHVuZGVmaW5lZCA/IGNhbGxTZXJ2ZXIgOiBtaXNzaW5nQ2FsbCxcbiAgICBfbm9uY2U6IG5vbmNlLFxuICAgIF9jaHVua3M6IGNodW5rcyxcbiAgICBfc3RyaW5nRGVjb2RlcjogY3JlYXRlU3RyaW5nRGVjb2RlcigpLFxuICAgIF9mcm9tSlNPTjogbnVsbCxcbiAgICBfcm93U3RhdGU6IDAsXG4gICAgX3Jvd0lEOiAwLFxuICAgIF9yb3dUYWc6IDAsXG4gICAgX3Jvd0xlbmd0aDogMCxcbiAgICBfYnVmZmVyOiBbXVxuICB9OyAvLyBEb24ndCBpbmxpbmUgdGhpcyBjYWxsIGJlY2F1c2UgaXQgY2F1c2VzIGNsb3N1cmUgdG8gb3V0bGluZSB0aGUgY2FsbCBhYm92ZS5cblxuICByZXNwb25zZS5fZnJvbUpTT04gPSBjcmVhdGVGcm9tSlNPTkNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kZWwocmVzcG9uc2UsIGlkLCBtb2RlbCkge1xuICB2YXIgY2h1bmtzID0gcmVzcG9uc2UuX2NodW5rcztcbiAgdmFyIGNodW5rID0gY2h1bmtzLmdldChpZCk7XG5cbiAgaWYgKCFjaHVuaykge1xuICAgIGNodW5rcy5zZXQoaWQsIGNyZWF0ZVJlc29sdmVkTW9kZWxDaHVuayhyZXNwb25zZSwgbW9kZWwpKTtcbiAgfSBlbHNlIHtcbiAgICByZXNvbHZlTW9kZWxDaHVuayhjaHVuaywgbW9kZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVUZXh0KHJlc3BvbnNlLCBpZCwgdGV4dCkge1xuICB2YXIgY2h1bmtzID0gcmVzcG9uc2UuX2NodW5rczsgLy8gV2UgYXNzdW1lIHRoYXQgd2UgYWx3YXlzIHJlZmVyZW5jZSBsYXJnZSBzdHJpbmdzIGFmdGVyIHRoZXkndmUgYmVlblxuICAvLyBlbWl0dGVkLlxuXG4gIGNodW5rcy5zZXQoaWQsIGNyZWF0ZUluaXRpYWxpemVkVGV4dENodW5rKHJlc3BvbnNlLCB0ZXh0KSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2R1bGUocmVzcG9uc2UsIGlkLCBtb2RlbCkge1xuICB2YXIgY2h1bmtzID0gcmVzcG9uc2UuX2NodW5rcztcbiAgdmFyIGNodW5rID0gY2h1bmtzLmdldChpZCk7XG4gIHZhciBjbGllbnRSZWZlcmVuY2VNZXRhZGF0YSA9IHBhcnNlTW9kZWwocmVzcG9uc2UsIG1vZGVsKTtcbiAgdmFyIGNsaWVudFJlZmVyZW5jZSA9IHJlc29sdmVDbGllbnRSZWZlcmVuY2UocmVzcG9uc2UuX2J1bmRsZXJDb25maWcsIGNsaWVudFJlZmVyZW5jZU1ldGFkYXRhKTtcbiAgLy8gRm9yIG5vdyB3ZSBwcmVsb2FkIGFsbCBtb2R1bGVzIGFzIGVhcmx5IGFzIHBvc3NpYmxlIHNpbmNlIGl0J3MgbGlrZWx5XG4gIC8vIHRoYXQgd2UnbGwgbmVlZCB0aGVtLlxuXG4gIHZhciBwcm9taXNlID0gcHJlbG9hZE1vZHVsZShjbGllbnRSZWZlcmVuY2UpO1xuXG4gIGlmIChwcm9taXNlKSB7XG4gICAgdmFyIGJsb2NrZWRDaHVuaztcblxuICAgIGlmICghY2h1bmspIHtcbiAgICAgIC8vIFRlY2huaWNhbGx5LCB3ZSBzaG91bGQganVzdCB0cmVhdCBwcm9taXNlIGFzIHRoZSBjaHVuayBpbiB0aGlzXG4gICAgICAvLyBjYXNlLiBCZWNhdXNlIGl0J2xsIGp1c3QgYmVoYXZlIGFzIGFueSBvdGhlciBwcm9taXNlLlxuICAgICAgYmxvY2tlZENodW5rID0gY3JlYXRlQmxvY2tlZENodW5rKHJlc3BvbnNlKTtcbiAgICAgIGNodW5rcy5zZXQoaWQsIGJsb2NrZWRDaHVuayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgY2FuJ3QgYWN0dWFsbHkgaGFwcGVuIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhbnkgZm9yd2FyZFxuICAgICAgLy8gcmVmZXJlbmNlcyB0byBtb2R1bGVzLlxuICAgICAgYmxvY2tlZENodW5rID0gY2h1bms7XG4gICAgICBibG9ja2VkQ2h1bmsuc3RhdHVzID0gQkxPQ0tFRDtcbiAgICB9XG5cbiAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVNb2R1bGVDaHVuayhibG9ja2VkQ2h1bmssIGNsaWVudFJlZmVyZW5jZSk7XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gdHJpZ2dlckVycm9yT25DaHVuayhibG9ja2VkQ2h1bmssIGVycm9yKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWNodW5rKSB7XG4gICAgICBjaHVua3Muc2V0KGlkLCBjcmVhdGVSZXNvbHZlZE1vZHVsZUNodW5rKHJlc3BvbnNlLCBjbGllbnRSZWZlcmVuY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBjYW4ndCBhY3R1YWxseSBoYXBwZW4gYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGFueSBmb3J3YXJkXG4gICAgICAvLyByZWZlcmVuY2VzIHRvIG1vZHVsZXMuXG4gICAgICByZXNvbHZlTW9kdWxlQ2h1bmsoY2h1bmssIGNsaWVudFJlZmVyZW5jZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVFcnJvckRldihyZXNwb25zZSwgaWQsIGRpZ2VzdCwgbWVzc2FnZSwgc3RhY2spIHtcblxuXG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdBbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgU2VydmVyIENvbXBvbmVudHMgcmVuZGVyIGJ1dCBubyBtZXNzYWdlIHdhcyBwcm92aWRlZCcpO1xuICBlcnJvci5zdGFjayA9IHN0YWNrO1xuICBlcnJvci5kaWdlc3QgPSBkaWdlc3Q7XG4gIHZhciBlcnJvcldpdGhEaWdlc3QgPSBlcnJvcjtcbiAgdmFyIGNodW5rcyA9IHJlc3BvbnNlLl9jaHVua3M7XG4gIHZhciBjaHVuayA9IGNodW5rcy5nZXQoaWQpO1xuXG4gIGlmICghY2h1bmspIHtcbiAgICBjaHVua3Muc2V0KGlkLCBjcmVhdGVFcnJvckNodW5rKHJlc3BvbnNlLCBlcnJvcldpdGhEaWdlc3QpKTtcbiAgfSBlbHNlIHtcbiAgICB0cmlnZ2VyRXJyb3JPbkNodW5rKGNodW5rLCBlcnJvcldpdGhEaWdlc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVIaW50KHJlc3BvbnNlLCBjb2RlLCBtb2RlbCkge1xuICB2YXIgaGludE1vZGVsID0gcGFyc2VNb2RlbChyZXNwb25zZSwgbW9kZWwpO1xuICBkaXNwYXRjaEhpbnQoY29kZSwgaGludE1vZGVsKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0Z1bGxSb3cocmVzcG9uc2UsIGlkLCB0YWcsIGJ1ZmZlciwgY2h1bmspIHtcblxuICB2YXIgc3RyaW5nRGVjb2RlciA9IHJlc3BvbnNlLl9zdHJpbmdEZWNvZGVyO1xuICB2YXIgcm93ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICByb3cgKz0gcmVhZFBhcnRpYWxTdHJpbmdDaHVuayhzdHJpbmdEZWNvZGVyLCBidWZmZXJbaV0pO1xuICB9XG5cbiAgcm93ICs9IHJlYWRGaW5hbFN0cmluZ0NodW5rKHN0cmluZ0RlY29kZXIsIGNodW5rKTtcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgNzNcbiAgICAvKiBcIklcIiAqL1xuICAgIDpcbiAgICAgIHtcbiAgICAgICAgcmVzb2x2ZU1vZHVsZShyZXNwb25zZSwgaWQsIHJvdyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgNzJcbiAgICAvKiBcIkhcIiAqL1xuICAgIDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvZGUgPSByb3dbMF07XG4gICAgICAgIHJlc29sdmVIaW50KHJlc3BvbnNlLCBjb2RlLCByb3cuc2xpY2UoMSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIDY5XG4gICAgLyogXCJFXCIgKi9cbiAgICA6XG4gICAgICB7XG4gICAgICAgIHZhciBlcnJvckluZm8gPSBKU09OLnBhcnNlKHJvdyk7XG5cbiAgICAgICAge1xuICAgICAgICAgIHJlc29sdmVFcnJvckRldihyZXNwb25zZSwgaWQsIGVycm9ySW5mby5kaWdlc3QsIGVycm9ySW5mby5tZXNzYWdlLCBlcnJvckluZm8uc3RhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSA4NFxuICAgIC8qIFwiVFwiICovXG4gICAgOlxuICAgICAge1xuICAgICAgICByZXNvbHZlVGV4dChyZXNwb25zZSwgaWQsIHJvdyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgODBcbiAgICAvKiBcIlBcIiAqL1xuICAgIDpcbiAgICAvLyBGYWxsdGhyb3VnaFxuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8qIFwiXCJcIiBcIntcIiBcIltcIiBcInRcIiBcImZcIiBcIm5cIiBcIjBcIiAtIFwiOVwiICovXG4gICAgICB7XG4gICAgICAgIC8vIFdlIGFzc3VtZSBhbnl0aGluZyBlbHNlIGlzIEpTT04uXG4gICAgICAgIHJlc29sdmVNb2RlbChyZXNwb25zZSwgaWQsIHJvdyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQmluYXJ5Q2h1bmsocmVzcG9uc2UsIGNodW5rKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJvd1N0YXRlID0gcmVzcG9uc2UuX3Jvd1N0YXRlO1xuICB2YXIgcm93SUQgPSByZXNwb25zZS5fcm93SUQ7XG4gIHZhciByb3dUYWcgPSByZXNwb25zZS5fcm93VGFnO1xuICB2YXIgcm93TGVuZ3RoID0gcmVzcG9uc2UuX3Jvd0xlbmd0aDtcbiAgdmFyIGJ1ZmZlciA9IHJlc3BvbnNlLl9idWZmZXI7XG4gIHZhciBjaHVua0xlbmd0aCA9IGNodW5rLmxlbmd0aDtcblxuICB3aGlsZSAoaSA8IGNodW5rTGVuZ3RoKSB7XG4gICAgdmFyIGxhc3RJZHggPSAtMTtcblxuICAgIHN3aXRjaCAocm93U3RhdGUpIHtcbiAgICAgIGNhc2UgUk9XX0lEOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGJ5dGUgPSBjaHVua1tpKytdO1xuXG4gICAgICAgICAgaWYgKGJ5dGUgPT09IDU4XG4gICAgICAgICAgLyogXCI6XCIgKi9cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgLy8gRmluaXNoZWQgdGhlIHJvd0lELCBuZXh0IHdlJ2xsIHBhcnNlIHRoZSB0YWcuXG4gICAgICAgICAgICAgIHJvd1N0YXRlID0gUk9XX1RBRztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb3dJRCA9IHJvd0lEIDw8IDQgfCAoYnl0ZSA+IDk2ID8gYnl0ZSAtIDg3IDogYnl0ZSAtIDQ4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJPV19UQUc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWRSb3dUYWcgPSBjaHVua1tpXTtcblxuICAgICAgICAgIGlmIChyZXNvbHZlZFJvd1RhZyA9PT0gODRcbiAgICAgICAgICAvKiBcIlRcIiAqL1xuICAgICAgICAgIHx8IGVuYWJsZUJpbmFyeUZsaWdodCBcbiAgICAgICAgICAvKiBcIlZcIiAqL1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgICByb3dUYWcgPSByZXNvbHZlZFJvd1RhZztcbiAgICAgICAgICAgICAgcm93U3RhdGUgPSBST1dfTEVOR1RIO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc29sdmVkUm93VGFnID4gNjQgJiYgcmVzb2x2ZWRSb3dUYWcgPCA5MVxuICAgICAgICAgIC8qIFwiQVwiLVwiWlwiICovXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJvd1RhZyA9IHJlc29sdmVkUm93VGFnO1xuICAgICAgICAgICAgICByb3dTdGF0ZSA9IFJPV19DSFVOS19CWV9ORVdMSU5FO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm93VGFnID0gMDtcbiAgICAgICAgICAgIHJvd1N0YXRlID0gUk9XX0NIVU5LX0JZX05FV0xJTkU7IC8vIFRoaXMgd2FzIGFuIHVua25vd24gdGFnIHNvIGl0IHdhcyBwcm9iYWJseSBwYXJ0IG9mIHRoZSBkYXRhLlxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUk9XX0xFTkdUSDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfYnl0ZSA9IGNodW5rW2krK107XG5cbiAgICAgICAgICBpZiAoX2J5dGUgPT09IDQ0XG4gICAgICAgICAgLyogXCIsXCIgKi9cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgLy8gRmluaXNoZWQgdGhlIHJvd0xlbmd0aCwgbmV4dCB3ZSdsbCBidWZmZXIgdXAgdG8gdGhhdCBsZW5ndGguXG4gICAgICAgICAgICAgIHJvd1N0YXRlID0gUk9XX0NIVU5LX0JZX0xFTkdUSDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb3dMZW5ndGggPSByb3dMZW5ndGggPDwgNCB8IChfYnl0ZSA+IDk2ID8gX2J5dGUgLSA4NyA6IF9ieXRlIC0gNDgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUk9XX0NIVU5LX0JZX05FV0xJTkU6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSdyZSBsb29raW5nIGZvciBhIG5ld2xpbmVcbiAgICAgICAgICBsYXN0SWR4ID0gY2h1bmsuaW5kZXhPZigxMFxuICAgICAgICAgIC8qIFwiXFxuXCIgKi9cbiAgICAgICAgICAsIGkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUk9XX0NIVU5LX0JZX0xFTkdUSDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlJ3JlIGxvb2tpbmcgZm9yIHRoZSByZW1haW5pbmcgYnl0ZSBsZW5ndGhcbiAgICAgICAgICBsYXN0SWR4ID0gaSArIHJvd0xlbmd0aDtcblxuICAgICAgICAgIGlmIChsYXN0SWR4ID4gY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBsYXN0SWR4ID0gLTE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0ID0gY2h1bmsuYnl0ZU9mZnNldCArIGk7XG5cbiAgICBpZiAobGFzdElkeCA+IC0xKSB7XG4gICAgICAvLyBXZSBmb3VuZCB0aGUgbGFzdCBjaHVuayBvZiB0aGUgcm93XG4gICAgICB2YXIgbGVuZ3RoID0gbGFzdElkeCAtIGk7XG4gICAgICB2YXIgbGFzdENodW5rID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBwcm9jZXNzRnVsbFJvdyhyZXNwb25zZSwgcm93SUQsIHJvd1RhZywgYnVmZmVyLCBsYXN0Q2h1bmspOyAvLyBSZXNldCBzdGF0ZSBtYWNoaW5lIGZvciBhIG5ldyByb3dcblxuICAgICAgaSA9IGxhc3RJZHg7XG5cbiAgICAgIGlmIChyb3dTdGF0ZSA9PT0gUk9XX0NIVU5LX0JZX05FV0xJTkUpIHtcbiAgICAgICAgLy8gSWYgd2UncmUgdHJhaWxpbmcgYnkgYSBuZXdsaW5lIHdlIG5lZWQgdG8gc2tpcCBpdC5cbiAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICByb3dTdGF0ZSA9IFJPV19JRDtcbiAgICAgIHJvd1RhZyA9IDA7XG4gICAgICByb3dJRCA9IDA7XG4gICAgICByb3dMZW5ndGggPSAwO1xuICAgICAgYnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXN0IG9mIHRoaXMgcm93IGlzIGluIGEgZnV0dXJlIGNodW5rLiBXZSBzdGFzaCB0aGUgcmVzdCBvZiB0aGVcbiAgICAgIC8vIGN1cnJlbnQgY2h1bmsgdW50aWwgd2UgY2FuIHByb2Nlc3MgdGhlIGZ1bGwgcm93LlxuICAgICAgdmFyIF9sZW5ndGggPSBjaHVuay5ieXRlTGVuZ3RoIC0gaTtcblxuICAgICAgdmFyIHJlbWFpbmluZ1NsaWNlID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnVmZmVyLCBvZmZzZXQsIF9sZW5ndGgpO1xuICAgICAgYnVmZmVyLnB1c2gocmVtYWluaW5nU2xpY2UpOyAvLyBVcGRhdGUgaG93IG1hbnkgYnl0ZXMgd2UncmUgc3RpbGwgd2FpdGluZyBmb3IuIElmIHdlJ3JlIGxvb2tpbmcgZm9yXG4gICAgICAvLyBhIG5ld2xpbmUsIHRoaXMgZG9lc24ndCBodXJ0IHNpbmNlIHdlJ2xsIGp1c3QgaWdub3JlIGl0LlxuXG4gICAgICByb3dMZW5ndGggLT0gcmVtYWluaW5nU2xpY2UuYnl0ZUxlbmd0aDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJlc3BvbnNlLl9yb3dTdGF0ZSA9IHJvd1N0YXRlO1xuICByZXNwb25zZS5fcm93SUQgPSByb3dJRDtcbiAgcmVzcG9uc2UuX3Jvd1RhZyA9IHJvd1RhZztcbiAgcmVzcG9uc2UuX3Jvd0xlbmd0aCA9IHJvd0xlbmd0aDtcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RlbChyZXNwb25zZSwganNvbikge1xuICByZXR1cm4gSlNPTi5wYXJzZShqc29uLCByZXNwb25zZS5fZnJvbUpTT04pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcm9tSlNPTkNhbGxiYWNrKHJlc3BvbnNlKSB7XG4gIC8vICRGbG93Rml4TWVbbWlzc2luZy10aGlzLWFubm90XVxuICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gV2UgY2FuJ3QgdXNlIC5iaW5kIGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRoZSBcInRoaXNcIiB2YWx1ZS5cbiAgICAgIHJldHVybiBwYXJzZU1vZGVsU3RyaW5nKHJlc3BvbnNlLCB0aGlzLCBrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHBhcnNlTW9kZWxUdXBsZShyZXNwb25zZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xvc2UocmVzcG9uc2UpIHtcbiAgLy8gSW4gY2FzZSB0aGVyZSBhcmUgYW55IHJlbWFpbmluZyB1bnJlc29sdmVkIGNodW5rcywgdGhleSB3b24ndFxuICAvLyBiZSByZXNvbHZlZCBub3cuIFNvIHdlIG5lZWQgdG8gaXNzdWUgYW4gZXJyb3IgdG8gdGhvc2UuXG4gIC8vIElkZWFsbHkgd2Ugc2hvdWxkIGJlIGFibGUgdG8gZWFybHkgYmFpbCBvdXQgaWYgd2Uga2VwdCBhXG4gIC8vIHJlZiBjb3VudCBvZiBwZW5kaW5nIGNodW5rcy5cbiAgcmVwb3J0R2xvYmFsRXJyb3IocmVzcG9uc2UsIG5ldyBFcnJvcignQ29ubmVjdGlvbiBjbG9zZWQuJykpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZUZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlc3BvbnNlKG51bGwsIG51bGwsIG9wdGlvbnMgJiYgb3B0aW9ucy5jYWxsU2VydmVyID8gb3B0aW9ucy5jYWxsU2VydmVyIDogdW5kZWZpbmVkLCB1bmRlZmluZWQgLy8gbm9uY2VcbiAgKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRSZWFkaW5nRnJvbVN0cmVhbShyZXNwb25zZSwgc3RyZWFtKSB7XG4gIHZhciByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG5cbiAgZnVuY3Rpb24gcHJvZ3Jlc3MoX3JlZikge1xuICAgIHZhciBkb25lID0gX3JlZi5kb25lLFxuICAgICAgICB2YWx1ZSA9IF9yZWYudmFsdWU7XG5cbiAgICBpZiAoZG9uZSkge1xuICAgICAgY2xvc2UocmVzcG9uc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBidWZmZXIgPSB2YWx1ZTtcbiAgICBwcm9jZXNzQmluYXJ5Q2h1bmsocmVzcG9uc2UsIGJ1ZmZlcik7XG4gICAgcmV0dXJuIHJlYWRlci5yZWFkKCkudGhlbihwcm9ncmVzcykuY2F0Y2goZXJyb3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXJyb3IoZSkge1xuICAgIHJlcG9ydEdsb2JhbEVycm9yKHJlc3BvbnNlLCBlKTtcbiAgfVxuXG4gIHJlYWRlci5yZWFkKCkudGhlbihwcm9ncmVzcykuY2F0Y2goZXJyb3IpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtLCBvcHRpb25zKSB7XG4gIHZhciByZXNwb25zZSA9IGNyZWF0ZVJlc3BvbnNlRnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gIHN0YXJ0UmVhZGluZ0Zyb21TdHJlYW0ocmVzcG9uc2UsIHN0cmVhbSk7XG4gIHJldHVybiBnZXRSb290KHJlc3BvbnNlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnJvbUZldGNoKHByb21pc2VGb3JSZXNwb25zZSwgb3B0aW9ucykge1xuICB2YXIgcmVzcG9uc2UgPSBjcmVhdGVSZXNwb25zZUZyb21PcHRpb25zKG9wdGlvbnMpO1xuICBwcm9taXNlRm9yUmVzcG9uc2UudGhlbihmdW5jdGlvbiAocikge1xuICAgIHN0YXJ0UmVhZGluZ0Zyb21TdHJlYW0ocmVzcG9uc2UsIHIuYm9keSk7XG4gIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgcmVwb3J0R2xvYmFsRXJyb3IocmVzcG9uc2UsIGUpO1xuICB9KTtcbiAgcmV0dXJuIGdldFJvb3QocmVzcG9uc2UpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVSZXBseSh2YWx1ZSlcbi8qIFdlIGRvbid0IHVzZSBVUkxTZWFyY2hQYXJhbXMgeWV0IGJ1dCBtYXliZSAqL1xue1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHByb2Nlc3NSZXBseSh2YWx1ZSwgJycsIHJlc29sdmUsIHJlamVjdCk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmNyZWF0ZUZyb21GZXRjaCA9IGNyZWF0ZUZyb21GZXRjaDtcbmV4cG9ydHMuY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtID0gY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtO1xuZXhwb3J0cy5jcmVhdGVTZXJ2ZXJSZWZlcmVuY2UgPSBjcmVhdGVTZXJ2ZXJSZWZlcmVuY2U7XG5leHBvcnRzLmVuY29kZVJlcGx5ID0gZW5jb2RlUmVwbHk7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIlJlYWN0RE9NIiwicmVxdWlyZSIsIlJlYWN0IiwiZW5hYmxlQmluYXJ5RmxpZ2h0IiwiY3JlYXRlU3RyaW5nRGVjb2RlciIsIlRleHREZWNvZGVyIiwiZGVjb2Rlck9wdGlvbnMiLCJzdHJlYW0iLCJyZWFkUGFydGlhbFN0cmluZ0NodW5rIiwiZGVjb2RlciIsImJ1ZmZlciIsImRlY29kZSIsInJlYWRGaW5hbFN0cmluZ0NodW5rIiwiSUQiLCJDSFVOS1MiLCJOQU1FIiwiaXNBc3luY0ltcG9ydCIsIm1ldGFkYXRhIiwibGVuZ3RoIiwicmVzb2x2ZUNsaWVudFJlZmVyZW5jZSIsImJ1bmRsZXJDb25maWciLCJtb2R1bGVFeHBvcnRzIiwicmVzb2x2ZWRNb2R1bGVEYXRhIiwibmFtZSIsIkVycm9yIiwiaWQiLCJjaHVua3MiLCJjaHVua0NhY2hlIiwiTWFwIiwicmVxdWlyZUFzeW5jTW9kdWxlIiwicHJvbWlzZSIsIl9fd2VicGFja19yZXF1aXJlX18iLCJ0aGVuIiwic3RhdHVzIiwidmFsdWUiLCJmdWxmaWxsZWRUaGVuYWJsZSIsInJlYXNvbiIsInJlamVjdGVkVGhlbmFibGUiLCJpZ25vcmVSZWplY3QiLCJwcmVsb2FkTW9kdWxlIiwicHJvbWlzZXMiLCJpIiwiY2h1bmtJZCIsImNodW5rRmlsZW5hbWUiLCJlbnRyeSIsImdldCIsInVuZGVmaW5lZCIsInRoZW5hYmxlIiwibG9hZENodW5rIiwicHVzaCIsInJlc29sdmUiLCJzZXQiLCJiaW5kIiwiUHJvbWlzZSIsImFsbCIsInJlcXVpcmVNb2R1bGUiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsImNodW5rTWFwIiwid2VicGFja0dldENodW5rRmlsZW5hbWUiLCJ1IiwiZmxpZ2h0Q2h1bmsiLCJmaWxlbmFtZSIsIl9fd2VicGFja19jaHVua19sb2FkX18iLCJSZWFjdERPTVNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiUmVhY3RET01DdXJyZW50RGlzcGF0Y2hlciIsIkRpc3BhdGNoZXIiLCJkaXNwYXRjaEhpbnQiLCJjb2RlIiwibW9kZWwiLCJkaXNwYXRjaGVyIiwiY3VycmVudCIsInJlZmluZWQiLCJyZWZpbmVNb2RlbCIsImhyZWYiLCJwcmVmZXRjaEROUyIsIl9yZWZpbmVkIiwiX2hyZWYiLCJwcmVjb25uZWN0IiwiX2hyZWYyIiwiY3Jvc3NPcmlnaW4iLCJfcmVmaW5lZDIiLCJfaHJlZjMiLCJhcyIsIm9wdGlvbnMiLCJwcmVsb2FkIiwiX3JlZmluZWQzIiwiX2hyZWY0IiwiX2hyZWY1IiwiX29wdGlvbnMiLCJfcmVmaW5lZDQiLCJfaHJlZjYiLCJwcmVpbml0U3R5bGUiLCJfaHJlZjciLCJwcmVjZWRlbmNlIiwiX29wdGlvbnMyIiwiX3JlZmluZWQ1IiwiX2hyZWY4IiwicHJlaW5pdFNjcmlwdCIsIl9ocmVmOSIsIl9vcHRpb25zMyIsIl9yZWZpbmVkNiIsIl9ocmVmMTAiLCJwcmVpbml0TW9kdWxlU2NyaXB0IiwiX2hyZWYxMSIsIl9vcHRpb25zNCIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlN5bWJvbCIsImZvciIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9TRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERUQiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiaXNBcnJheUltcGwiLCJpc0FycmF5IiwiYSIsImdldFByb3RvdHlwZU9mIiwiT2JqZWN0IiwianN4UHJvcHNQYXJlbnRzIiwiV2Vha01hcCIsImpzeENoaWxkcmVuUGFyZW50cyIsImlzT2JqZWN0UHJvdG90eXBlIiwib2JqZWN0IiwiT2JqZWN0UHJvdG90eXBlIiwibmFtZXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiaXNTaW1wbGVPYmplY3QiLCJkZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsIm9iamVjdE5hbWUiLCJ0b1N0cmluZyIsInJlcGxhY2UiLCJtIiwicDAiLCJkZXNjcmliZUtleUZvckVycm9yTWVzc2FnZSIsImtleSIsImVuY29kZWRLZXkiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZSIsInNsaWNlIiwiZGVzY3JpYmVFbGVtZW50VHlwZSIsInR5cGUiLCIkJHR5cGVvZiIsInJlbmRlciIsImxhenlDb21wb25lbnQiLCJwYXlsb2FkIiwiX3BheWxvYWQiLCJpbml0IiwiX2luaXQiLCJ4IiwiZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UiLCJvYmplY3RPckFycmF5IiwiZXhwYW5kZWROYW1lIiwib2JqS2luZCIsInN0ciIsInN0YXJ0IiwiaGFzIiwiYXJyYXkiLCJzdWJzdHIiLCJfYXJyYXkiLCJfaSIsIl92YWx1ZSIsIl9zdWJzdHIiLCJfdHlwZSIsImtleXMiLCJfaTIiLCJfdmFsdWUyIiwiX3N1YnN0cjIiLCJfb2JqZWN0IiwiX25hbWVzIiwiX2kzIiwiX25hbWUiLCJfdmFsdWUzIiwiX3N1YnN0cjMiLCJoaWdobGlnaHQiLCJyZXBlYXQiLCJrbm93blNlcnZlclJlZmVyZW5jZXMiLCJzZXJpYWxpemVQcm9taXNlSUQiLCJzZXJpYWxpemVTZXJ2ZXJSZWZlcmVuY2VJRCIsInNlcmlhbGl6ZVN5bWJvbFJlZmVyZW5jZSIsInNlcmlhbGl6ZUZvcm1EYXRhUmVmZXJlbmNlIiwic2VyaWFsaXplTnVtYmVyIiwibnVtYmVyIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJJbmZpbml0eSIsInNlcmlhbGl6ZVVuZGVmaW5lZCIsInNlcmlhbGl6ZURhdGVGcm9tRGF0ZUpTT04iLCJkYXRlSlNPTiIsInNlcmlhbGl6ZUJpZ0ludCIsIm4iLCJzZXJpYWxpemVNYXBJRCIsInNlcmlhbGl6ZVNldElEIiwiZXNjYXBlU3RyaW5nVmFsdWUiLCJwcm9jZXNzUmVwbHkiLCJyb290IiwiZm9ybUZpZWxkUHJlZml4IiwicmVqZWN0IiwibmV4dFBhcnRJZCIsInBlbmRpbmdQYXJ0cyIsImZvcm1EYXRhIiwicmVzb2x2ZVRvSlNPTiIsInBhcmVudCIsIm9yaWdpbmFsVmFsdWUiLCJEYXRlIiwiRm9ybURhdGEiLCJwcm9taXNlSWQiLCJwYXJ0VmFsdWUiLCJwYXJ0SlNPTiIsImRhdGEiLCJhcHBlbmQiLCJyZWZJZCIsInByZWZpeCIsImZvckVhY2giLCJvcmlnaW5hbEtleSIsImZyb20iLCJtYXBJZCIsIlNldCIsIl9wYXJ0SlNPTiIsInNldElkIiwiaXRlcmF0b3JGbiIsInByb3RvIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsImRlc2NyaXB0aW9uIiwiX29yaWdpbmFsVmFsdWUiLCJtZXRhRGF0YSIsIm1ldGFEYXRhSlNPTiIsIl9yZWZJZCIsImpzb24iLCJyZWdpc3RlclNlcnZlclJlZmVyZW5jZSIsInByb3h5IiwicmVmZXJlbmNlIiwiY3JlYXRlU2VydmVyUmVmZXJlbmNlIiwiY2FsbFNlcnZlciIsImJvdW5kIiwiQ29udGV4dFJlZ2lzdHJ5IiwiZ2V0T3JDcmVhdGVTZXJ2ZXJDb250ZXh0IiwiZ2xvYmFsTmFtZSIsImNvbnRleHQiLCJfY3VycmVudFZhbHVlIiwiX2N1cnJlbnRWYWx1ZTIiLCJfZGVmYXVsdFZhbHVlIiwiX3RocmVhZENvdW50IiwiUHJvdmlkZXIiLCJDb25zdW1lciIsIl9nbG9iYWxOYW1lIiwiX2NvbnRleHQiLCJoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXIiLCJfY3VycmVudFJlbmRlcmVyIiwiX2N1cnJlbnRSZW5kZXJlcjIiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiUk9XX0lEIiwiUk9XX1RBRyIsIlJPV19MRU5HVEgiLCJST1dfQ0hVTktfQllfTkVXTElORSIsIlJPV19DSFVOS19CWV9MRU5HVEgiLCJQRU5ESU5HIiwiQkxPQ0tFRCIsIkNZQ0xJQyIsIlJFU09MVkVEX01PREVMIiwiUkVTT0xWRURfTU9EVUxFIiwiSU5JVElBTElaRUQiLCJFUlJPUkVEIiwiQ2h1bmsiLCJyZXNwb25zZSIsIl9yZXNwb25zZSIsImNyZWF0ZSIsImNodW5rIiwiaW5pdGlhbGl6ZU1vZGVsQ2h1bmsiLCJpbml0aWFsaXplTW9kdWxlQ2h1bmsiLCJyZWFkQ2h1bmsiLCJnZXRSb290IiwiZ2V0Q2h1bmsiLCJjcmVhdGVQZW5kaW5nQ2h1bmsiLCJjcmVhdGVCbG9ja2VkQ2h1bmsiLCJjcmVhdGVFcnJvckNodW5rIiwid2FrZUNodW5rIiwibGlzdGVuZXJzIiwibGlzdGVuZXIiLCJ3YWtlQ2h1bmtJZkluaXRpYWxpemVkIiwicmVzb2x2ZUxpc3RlbmVycyIsInJlamVjdExpc3RlbmVycyIsInRyaWdnZXJFcnJvck9uQ2h1bmsiLCJlcnJvcmVkQ2h1bmsiLCJjcmVhdGVSZXNvbHZlZE1vZGVsQ2h1bmsiLCJjcmVhdGVSZXNvbHZlZE1vZHVsZUNodW5rIiwiY3JlYXRlSW5pdGlhbGl6ZWRUZXh0Q2h1bmsiLCJyZXNvbHZlTW9kZWxDaHVuayIsInJlc29sdmVkQ2h1bmsiLCJyZXNvbHZlTW9kdWxlQ2h1bmsiLCJpbml0aWFsaXppbmdDaHVuayIsImluaXRpYWxpemluZ0NodW5rQmxvY2tlZE1vZGVsIiwicHJldkNodW5rIiwicHJldkJsb2NrZWQiLCJyZXNvbHZlZE1vZGVsIiwiY3ljbGljQ2h1bmsiLCJwYXJzZU1vZGVsIiwiZGVwcyIsImJsb2NrZWRDaHVuayIsImluaXRpYWxpemVkQ2h1bmsiLCJyZXBvcnRHbG9iYWxFcnJvciIsIl9jaHVua3MiLCJjcmVhdGVFbGVtZW50IiwicHJvcHMiLCJlbGVtZW50IiwicmVmIiwiX293bmVyIiwiX3N0b3JlIiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImNyZWF0ZUxhenlDaHVua1dyYXBwZXIiLCJsYXp5VHlwZSIsImNyZWF0ZU1vZGVsUmVzb2x2ZXIiLCJwYXJlbnRPYmplY3QiLCJjeWNsaWMiLCJibG9ja2VkIiwiY3JlYXRlTW9kZWxSZWplY3QiLCJjcmVhdGVTZXJ2ZXJSZWZlcmVuY2VQcm94eSIsIl9jYWxsU2VydmVyIiwicCIsImdldE91dGxpbmVkTW9kZWwiLCJwYXJzZU1vZGVsU3RyaW5nIiwicGFyc2VJbnQiLCJfaWQiLCJfY2h1bmsiLCJfaWQyIiwiX2lkMyIsIl9pZDQiLCJfZGF0YSIsIk5hTiIsInBhcnNlIiwiQmlnSW50IiwiX2lkNSIsIl9jaHVuazIiLCJwYXJlbnRDaHVuayIsInBhcnNlTW9kZWxUdXBsZSIsInR1cGxlIiwibWlzc2luZ0NhbGwiLCJjcmVhdGVSZXNwb25zZSIsIm1vZHVsZUxvYWRpbmciLCJub25jZSIsIl9idW5kbGVyQ29uZmlnIiwiX21vZHVsZUxvYWRpbmciLCJfbm9uY2UiLCJfc3RyaW5nRGVjb2RlciIsIl9mcm9tSlNPTiIsIl9yb3dTdGF0ZSIsIl9yb3dJRCIsIl9yb3dUYWciLCJfcm93TGVuZ3RoIiwiX2J1ZmZlciIsImNyZWF0ZUZyb21KU09OQ2FsbGJhY2siLCJyZXNvbHZlTW9kZWwiLCJyZXNvbHZlVGV4dCIsInRleHQiLCJyZXNvbHZlTW9kdWxlIiwiY2xpZW50UmVmZXJlbmNlTWV0YWRhdGEiLCJjbGllbnRSZWZlcmVuY2UiLCJyZXNvbHZlRXJyb3JEZXYiLCJkaWdlc3QiLCJtZXNzYWdlIiwiZXJyb3JXaXRoRGlnZXN0IiwicmVzb2x2ZUhpbnQiLCJoaW50TW9kZWwiLCJwcm9jZXNzRnVsbFJvdyIsInRhZyIsInN0cmluZ0RlY29kZXIiLCJyb3ciLCJlcnJvckluZm8iLCJwcm9jZXNzQmluYXJ5Q2h1bmsiLCJyb3dTdGF0ZSIsInJvd0lEIiwicm93VGFnIiwicm93TGVuZ3RoIiwiY2h1bmtMZW5ndGgiLCJsYXN0SWR4IiwiYnl0ZSIsInJlc29sdmVkUm93VGFnIiwiX2J5dGUiLCJpbmRleE9mIiwib2Zmc2V0IiwiYnl0ZU9mZnNldCIsImxhc3RDaHVuayIsIlVpbnQ4QXJyYXkiLCJfbGVuZ3RoIiwiYnl0ZUxlbmd0aCIsInJlbWFpbmluZ1NsaWNlIiwiY2xvc2UiLCJjcmVhdGVSZXNwb25zZUZyb21PcHRpb25zIiwic3RhcnRSZWFkaW5nRnJvbVN0cmVhbSIsInJlYWRlciIsImdldFJlYWRlciIsInByb2dyZXNzIiwiX3JlZiIsImRvbmUiLCJyZWFkIiwiY2F0Y2giLCJlIiwiY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtIiwiY3JlYXRlRnJvbUZldGNoIiwicHJvbWlzZUZvclJlc3BvbnNlIiwiciIsImJvZHkiLCJlbmNvZGVSZXBseSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.browser.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-server-dom-webpack/client.browser.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-server-dom-webpack-client.browser.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudC5icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLHFQQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnQuYnJvd3Nlci5qcz9mZTkwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2stY2xpZW50LmJyb3dzZXIucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrLWNsaWVudC5icm93c2VyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-server-dom-webpack/client.js ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nmodule.exports = __webpack_require__(/*! ./client.browser */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.browser.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxnS0FBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50LmpzPzIzNGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2xpZW50LmJyb3dzZXInKTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.js\n"));

/***/ })

}]);